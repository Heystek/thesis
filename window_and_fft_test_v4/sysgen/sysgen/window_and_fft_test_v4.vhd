--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_d5319d7881548c22.vhd when simulating
-- the core, bmg_72_d5319d7881548c22. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_d5319d7881548c22 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END bmg_72_d5319d7881548c22;

ARCHITECTURE bmg_72_d5319d7881548c22_a OF bmg_72_d5319d7881548c22 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_d5319d7881548c22
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_d5319d7881548c22 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 9,
      c_addrb_width => 9,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_d5319d7881548c22.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 512,
      c_read_depth_b => 512,
      c_read_width_a => 9,
      c_read_width_b => 9,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 512,
      c_write_depth_b => 512,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 9,
      c_write_width_b => 9,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_d5319d7881548c22
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_d5319d7881548c22_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_9966d4e54ef143a4.vhd when simulating
-- the core, cntr_11_0_9966d4e54ef143a4. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_9966d4e54ef143a4 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END cntr_11_0_9966d4e54ef143a4;

ARCHITECTURE cntr_11_0_9966d4e54ef143a4_a OF cntr_11_0_9966d4e54ef143a4 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_9966d4e54ef143a4
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_9966d4e54ef143a4 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 9,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_9966d4e54ef143a4
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_9966d4e54ef143a4_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file dmg_72_61c575268fb396d0.vhd when simulating
-- the core, dmg_72_61c575268fb396d0. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY dmg_72_61c575268fb396d0 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    d : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpra : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    clk : IN STD_LOGIC;
    we : IN STD_LOGIC;
    spo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END dmg_72_61c575268fb396d0;

ARCHITECTURE dmg_72_61c575268fb396d0_a OF dmg_72_61c575268fb396d0 IS
-- synthesis translate_off
COMPONENT wrapped_dmg_72_61c575268fb396d0
  PORT (
    a : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    d : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpra : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    clk : IN STD_LOGIC;
    we : IN STD_LOGIC;
    spo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_dmg_72_61c575268fb396d0 USE ENTITY XilinxCoreLib.dist_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addr_width => 4,
      c_default_data => "0",
      c_depth => 16,
      c_family => "virtex6",
      c_has_clk => 1,
      c_has_d => 1,
      c_has_dpo => 1,
      c_has_dpra => 1,
      c_has_i_ce => 0,
      c_has_qdpo => 0,
      c_has_qdpo_ce => 0,
      c_has_qdpo_clk => 0,
      c_has_qdpo_rst => 0,
      c_has_qdpo_srst => 0,
      c_has_qspo => 0,
      c_has_qspo_ce => 0,
      c_has_qspo_rst => 0,
      c_has_qspo_srst => 0,
      c_has_spo => 1,
      c_has_spra => 0,
      c_has_we => 1,
      c_mem_init_file => "dmg_72_61c575268fb396d0.mif",
      c_mem_type => 2,
      c_parser_type => 1,
      c_pipeline_stages => 0,
      c_qce_joined => 0,
      c_qualify_we => 0,
      c_read_mif => 1,
      c_reg_a_d_inputs => 0,
      c_reg_dpra_input => 0,
      c_sync_enable => 1,
      c_width => 18
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_dmg_72_61c575268fb396d0
  PORT MAP (
    a => a,
    d => d,
    dpra => dpra,
    clk => clk,
    we => we,
    spo => spo,
    dpo => dpo
  );
-- synthesis translate_on

END dmg_72_61c575268fb396d0_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_fc83b5c52a6ea9e3.vhd when simulating
-- the core, bmg_72_fc83b5c52a6ea9e3. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_fc83b5c52a6ea9e3 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END bmg_72_fc83b5c52a6ea9e3;

ARCHITECTURE bmg_72_fc83b5c52a6ea9e3_a OF bmg_72_fc83b5c52a6ea9e3 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_fc83b5c52a6ea9e3
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_fc83b5c52a6ea9e3 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_fc83b5c52a6ea9e3.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 8,
      c_read_width_b => 8,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 8,
      c_write_width_b => 8,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_fc83b5c52a6ea9e3
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_fc83b5c52a6ea9e3_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_5b4a22e47f2359ce.vhd when simulating
-- the core, addsb_11_0_5b4a22e47f2359ce. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_5b4a22e47f2359ce IS
  PORT (
    a : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    s : OUT STD_LOGIC_VECTOR(20 DOWNTO 0)
  );
END addsb_11_0_5b4a22e47f2359ce;

ARCHITECTURE addsb_11_0_5b4a22e47f2359ce_a OF addsb_11_0_5b4a22e47f2359ce IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_5b4a22e47f2359ce
  PORT (
    a : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    s : OUT STD_LOGIC_VECTOR(20 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_5b4a22e47f2359ce USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 21,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "000000000000000000000",
      c_b_width => 21,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 0,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 0,
      c_out_width => 21,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_5b4a22e47f2359ce
  PORT MAP (
    a => a,
    b => b,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_5b4a22e47f2359ce_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_9a187dd9cd5a0cfe.vhd when simulating
-- the core, bmg_72_9a187dd9cd5a0cfe. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_9a187dd9cd5a0cfe IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(35 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END bmg_72_9a187dd9cd5a0cfe;

ARCHITECTURE bmg_72_9a187dd9cd5a0cfe_a OF bmg_72_9a187dd9cd5a0cfe IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_9a187dd9cd5a0cfe
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(35 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_9a187dd9cd5a0cfe USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_9a187dd9cd5a0cfe.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 36,
      c_read_width_b => 36,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 36,
      c_write_width_b => 36,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_9a187dd9cd5a0cfe
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_9a187dd9cd5a0cfe_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_457d1583b36d1c7c.vhd when simulating
-- the core, cntr_11_0_457d1583b36d1c7c. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_457d1583b36d1c7c IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(15 DOWNTO 0)
  );
END cntr_11_0_457d1583b36d1c7c;

ARCHITECTURE cntr_11_0_457d1583b36d1c7c_a OF cntr_11_0_457d1583b36d1c7c IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_457d1583b36d1c7c
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(15 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_457d1583b36d1c7c USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1000000000000000",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 16,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_457d1583b36d1c7c
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_457d1583b36d1c7c_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_b7d413d71af73706.vhd when simulating
-- the core, bmg_72_b7d413d71af73706. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_b7d413d71af73706 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END bmg_72_b7d413d71af73706;

ARCHITECTURE bmg_72_b7d413d71af73706_a OF bmg_72_b7d413d71af73706 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_b7d413d71af73706
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_b7d413d71af73706 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 10,
      c_addrb_width => 10,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_b7d413d71af73706.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 1024,
      c_read_depth_b => 1024,
      c_read_width_a => 18,
      c_read_width_b => 18,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 1024,
      c_write_depth_b => 1024,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 18,
      c_write_width_b => 18,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_b7d413d71af73706
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_b7d413d71af73706_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_25cb9ebb8094dade.vhd when simulating
-- the core, bmg_72_25cb9ebb8094dade. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_25cb9ebb8094dade IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END bmg_72_25cb9ebb8094dade;

ARCHITECTURE bmg_72_25cb9ebb8094dade_a OF bmg_72_25cb9ebb8094dade IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_25cb9ebb8094dade
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_25cb9ebb8094dade USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 10,
      c_addrb_width => 10,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_25cb9ebb8094dade.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 1024,
      c_read_depth_b => 1024,
      c_read_width_a => 18,
      c_read_width_b => 18,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 1024,
      c_write_depth_b => 1024,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 18,
      c_write_width_b => 18,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_25cb9ebb8094dade
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_25cb9ebb8094dade_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_8610f827d96057ce.vhd when simulating
-- the core, addsb_11_0_8610f827d96057ce. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_8610f827d96057ce IS
  PORT (
    a : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(18 DOWNTO 0)
  );
END addsb_11_0_8610f827d96057ce;

ARCHITECTURE addsb_11_0_8610f827d96057ce_a OF addsb_11_0_8610f827d96057ce IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_8610f827d96057ce
  PORT (
    a : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(18 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_8610f827d96057ce USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 19,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "0000000000000000000",
      c_b_width => 19,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 19,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_8610f827d96057ce
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_8610f827d96057ce_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_6a49eeb869ee9525.vhd when simulating
-- the core, addsb_11_0_6a49eeb869ee9525. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_6a49eeb869ee9525 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(2 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(2 DOWNTO 0);
    s : OUT STD_LOGIC_VECTOR(2 DOWNTO 0)
  );
END addsb_11_0_6a49eeb869ee9525;

ARCHITECTURE addsb_11_0_6a49eeb869ee9525_a OF addsb_11_0_6a49eeb869ee9525 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_6a49eeb869ee9525
  PORT (
    a : IN STD_LOGIC_VECTOR(2 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(2 DOWNTO 0);
    s : OUT STD_LOGIC_VECTOR(2 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_6a49eeb869ee9525 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 1,
      c_a_width => 3,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 1,
      c_b_value => "000",
      c_b_width => 3,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 0,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 0,
      c_out_width => 3,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_6a49eeb869ee9525
  PORT MAP (
    a => a,
    b => b,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_6a49eeb869ee9525_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_88a7df48df176590.vhd when simulating
-- the core, bmg_72_88a7df48df176590. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_88a7df48df176590 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(35 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END bmg_72_88a7df48df176590;

ARCHITECTURE bmg_72_88a7df48df176590_a OF bmg_72_88a7df48df176590 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_88a7df48df176590
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(35 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_88a7df48df176590 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_88a7df48df176590.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 36,
      c_read_width_b => 36,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 36,
      c_write_width_b => 36,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_88a7df48df176590
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_88a7df48df176590_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_259024b6977697b1.vhd when simulating
-- the core, addsb_11_0_259024b6977697b1. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_259024b6977697b1 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(38 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(38 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(38 DOWNTO 0)
  );
END addsb_11_0_259024b6977697b1;

ARCHITECTURE addsb_11_0_259024b6977697b1_a OF addsb_11_0_259024b6977697b1 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_259024b6977697b1
  PORT (
    a : IN STD_LOGIC_VECTOR(38 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(38 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(38 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_259024b6977697b1 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 39,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "000000000000000000000000000000000000000",
      c_b_width => 39,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 39,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_259024b6977697b1
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_259024b6977697b1_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_88a3fd223f485e8a.vhd when simulating
-- the core, addsb_11_0_88a3fd223f485e8a. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_88a3fd223f485e8a IS
  PORT (
    a : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(18 DOWNTO 0)
  );
END addsb_11_0_88a3fd223f485e8a;

ARCHITECTURE addsb_11_0_88a3fd223f485e8a_a OF addsb_11_0_88a3fd223f485e8a IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_88a3fd223f485e8a
  PORT (
    a : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(18 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_88a3fd223f485e8a USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 19,
      c_add_mode => 1,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "0000000000000000000",
      c_b_width => 19,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 19,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_88a3fd223f485e8a
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_88a3fd223f485e8a_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_146e01525f281df8.vhd when simulating
-- the core, bmg_72_146e01525f281df8. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_146e01525f281df8 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END bmg_72_146e01525f281df8;

ARCHITECTURE bmg_72_146e01525f281df8_a OF bmg_72_146e01525f281df8 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_146e01525f281df8
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_146e01525f281df8 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 10,
      c_addrb_width => 10,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_146e01525f281df8.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 1024,
      c_read_depth_b => 1024,
      c_read_width_a => 18,
      c_read_width_b => 18,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 1024,
      c_write_depth_b => 1024,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 18,
      c_write_width_b => 18,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_146e01525f281df8
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_146e01525f281df8_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_3892e7a2bbe55936.vhd when simulating
-- the core, addsb_11_0_3892e7a2bbe55936. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_3892e7a2bbe55936 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    s : OUT STD_LOGIC_VECTOR(21 DOWNTO 0)
  );
END addsb_11_0_3892e7a2bbe55936;

ARCHITECTURE addsb_11_0_3892e7a2bbe55936_a OF addsb_11_0_3892e7a2bbe55936 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_3892e7a2bbe55936
  PORT (
    a : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    s : OUT STD_LOGIC_VECTOR(21 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_3892e7a2bbe55936 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 22,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "0000000000000000000000",
      c_b_width => 22,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 0,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 0,
      c_out_width => 22,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_3892e7a2bbe55936
  PORT MAP (
    a => a,
    b => b,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_3892e7a2bbe55936_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_e9a0d6c7631bff5b.vhd when simulating
-- the core, bmg_72_e9a0d6c7631bff5b. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_e9a0d6c7631bff5b IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END bmg_72_e9a0d6c7631bff5b;

ARCHITECTURE bmg_72_e9a0d6c7631bff5b_a OF bmg_72_e9a0d6c7631bff5b IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_e9a0d6c7631bff5b
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_e9a0d6c7631bff5b USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 10,
      c_addrb_width => 10,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_e9a0d6c7631bff5b.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 1024,
      c_read_depth_b => 1024,
      c_read_width_a => 18,
      c_read_width_b => 18,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 1024,
      c_write_depth_b => 1024,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 18,
      c_write_width_b => 18,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_e9a0d6c7631bff5b
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_e9a0d6c7631bff5b_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file dmg_72_28098a4ce465921e.vhd when simulating
-- the core, dmg_72_28098a4ce465921e. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY dmg_72_28098a4ce465921e IS
  PORT (
    a : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    d : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpra : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    clk : IN STD_LOGIC;
    we : IN STD_LOGIC;
    spo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END dmg_72_28098a4ce465921e;

ARCHITECTURE dmg_72_28098a4ce465921e_a OF dmg_72_28098a4ce465921e IS
-- synthesis translate_off
COMPONENT wrapped_dmg_72_28098a4ce465921e
  PORT (
    a : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    d : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpra : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    clk : IN STD_LOGIC;
    we : IN STD_LOGIC;
    spo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_dmg_72_28098a4ce465921e USE ENTITY XilinxCoreLib.dist_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addr_width => 4,
      c_default_data => "0",
      c_depth => 16,
      c_family => "virtex6",
      c_has_clk => 1,
      c_has_d => 1,
      c_has_dpo => 1,
      c_has_dpra => 1,
      c_has_i_ce => 0,
      c_has_qdpo => 0,
      c_has_qdpo_ce => 0,
      c_has_qdpo_clk => 0,
      c_has_qdpo_rst => 0,
      c_has_qdpo_srst => 0,
      c_has_qspo => 0,
      c_has_qspo_ce => 0,
      c_has_qspo_rst => 0,
      c_has_qspo_srst => 0,
      c_has_spo => 1,
      c_has_spra => 0,
      c_has_we => 1,
      c_mem_init_file => "dmg_72_28098a4ce465921e.mif",
      c_mem_type => 2,
      c_parser_type => 1,
      c_pipeline_stages => 0,
      c_qce_joined => 0,
      c_qualify_we => 0,
      c_read_mif => 1,
      c_reg_a_d_inputs => 0,
      c_reg_dpra_input => 0,
      c_sync_enable => 1,
      c_width => 18
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_dmg_72_28098a4ce465921e
  PORT MAP (
    a => a,
    d => d,
    dpra => dpra,
    clk => clk,
    we => we,
    spo => spo,
    dpo => dpo
  );
-- synthesis translate_on

END dmg_72_28098a4ce465921e_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_3f3c61289e7ba7ea.vhd when simulating
-- the core, bmg_72_3f3c61289e7ba7ea. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_3f3c61289e7ba7ea IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END bmg_72_3f3c61289e7ba7ea;

ARCHITECTURE bmg_72_3f3c61289e7ba7ea_a OF bmg_72_3f3c61289e7ba7ea IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_3f3c61289e7ba7ea
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_3f3c61289e7ba7ea USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_3f3c61289e7ba7ea.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 36,
      c_read_width_b => 36,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 36,
      c_write_width_b => 36,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_3f3c61289e7ba7ea
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_3f3c61289e7ba7ea_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_3673c2b46bfb142f.vhd when simulating
-- the core, bmg_72_3673c2b46bfb142f. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_3673c2b46bfb142f IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(8 DOWNTO 0);
    clkb : IN STD_LOGIC;
    enb : IN STD_LOGIC;
    web : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addrb : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dinb : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    doutb : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END bmg_72_3673c2b46bfb142f;

ARCHITECTURE bmg_72_3673c2b46bfb142f_a OF bmg_72_3673c2b46bfb142f IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_3673c2b46bfb142f
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(8 DOWNTO 0);
    clkb : IN STD_LOGIC;
    enb : IN STD_LOGIC;
    web : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addrb : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dinb : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    doutb : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_3673c2b46bfb142f USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 9,
      c_addrb_width => 9,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 1,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 1,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 1,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_3673c2b46bfb142f.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 2,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 512,
      c_read_depth_b => 512,
      c_read_width_a => 9,
      c_read_width_b => 9,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 512,
      c_write_depth_b => 512,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "READ_FIRST",
      c_write_width_a => 9,
      c_write_width_b => 9,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_3673c2b46bfb142f
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta,
    clkb => clkb,
    enb => enb,
    web => web,
    addrb => addrb,
    dinb => dinb,
    doutb => doutb
  );
-- synthesis translate_on

END bmg_72_3673c2b46bfb142f_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_a4cff0d500ff7adb.vhd when simulating
-- the core, bmg_72_a4cff0d500ff7adb. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_a4cff0d500ff7adb IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(63 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(63 DOWNTO 0)
  );
END bmg_72_a4cff0d500ff7adb;

ARCHITECTURE bmg_72_a4cff0d500ff7adb_a OF bmg_72_a4cff0d500ff7adb IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_a4cff0d500ff7adb
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(63 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(63 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_a4cff0d500ff7adb USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 10,
      c_addrb_width => 10,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_a4cff0d500ff7adb.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 1024,
      c_read_depth_b => 1024,
      c_read_width_a => 64,
      c_read_width_b => 64,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 1024,
      c_write_depth_b => 1024,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 64,
      c_write_width_b => 64,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_a4cff0d500ff7adb
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_a4cff0d500ff7adb_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_6c65a885198b42c3.vhd when simulating
-- the core, addsb_11_0_6c65a885198b42c3. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_6c65a885198b42c3 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(22 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(22 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(22 DOWNTO 0)
  );
END addsb_11_0_6c65a885198b42c3;

ARCHITECTURE addsb_11_0_6c65a885198b42c3_a OF addsb_11_0_6c65a885198b42c3 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_6c65a885198b42c3
  PORT (
    a : IN STD_LOGIC_VECTOR(22 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(22 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(22 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_6c65a885198b42c3 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 23,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000000000",
      c_b_width => 23,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 23,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_6c65a885198b42c3
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_6c65a885198b42c3_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_21ee79a31172f35f.vhd when simulating
-- the core, cntr_11_0_21ee79a31172f35f. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_21ee79a31172f35f IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    load : IN STD_LOGIC;
    l : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    q : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END cntr_11_0_21ee79a31172f35f;

ARCHITECTURE cntr_11_0_21ee79a31172f35f_a OF cntr_11_0_21ee79a31172f35f IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_21ee79a31172f35f
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    load : IN STD_LOGIC;
    l : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    q : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_21ee79a31172f35f USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 1,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 1,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 9,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_21ee79a31172f35f
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    load => load,
    l => l,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_21ee79a31172f35f_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_71453be4ec33d4ae.vhd when simulating
-- the core, bmg_72_71453be4ec33d4ae. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_71453be4ec33d4ae IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END bmg_72_71453be4ec33d4ae;

ARCHITECTURE bmg_72_71453be4ec33d4ae_a OF bmg_72_71453be4ec33d4ae IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_71453be4ec33d4ae
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_71453be4ec33d4ae USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_71453be4ec33d4ae.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 8,
      c_read_width_b => 8,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 8,
      c_write_width_b => 8,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_71453be4ec33d4ae
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_71453be4ec33d4ae_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_fba27241bcd4df38.vhd when simulating
-- the core, bmg_72_fba27241bcd4df38. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_fba27241bcd4df38 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END bmg_72_fba27241bcd4df38;

ARCHITECTURE bmg_72_fba27241bcd4df38_a OF bmg_72_fba27241bcd4df38 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_fba27241bcd4df38
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_fba27241bcd4df38 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 10,
      c_addrb_width => 10,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_fba27241bcd4df38.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 1024,
      c_read_depth_b => 1024,
      c_read_width_a => 18,
      c_read_width_b => 18,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 1024,
      c_write_depth_b => 1024,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 18,
      c_write_width_b => 18,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_fba27241bcd4df38
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_fba27241bcd4df38_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_5b8023f54686b589.vhd when simulating
-- the core, bmg_72_5b8023f54686b589. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_5b8023f54686b589 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(4 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END bmg_72_5b8023f54686b589;

ARCHITECTURE bmg_72_5b8023f54686b589_a OF bmg_72_5b8023f54686b589 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_5b8023f54686b589
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(4 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_5b8023f54686b589 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 5,
      c_addrb_width => 5,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_5b8023f54686b589.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 32,
      c_read_depth_b => 32,
      c_read_width_a => 36,
      c_read_width_b => 36,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 32,
      c_write_depth_b => 32,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 36,
      c_write_width_b => 36,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_5b8023f54686b589
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_5b8023f54686b589_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file mult_11_2_ecdcb40ad0958e64.vhd when simulating
-- the core, mult_11_2_ecdcb40ad0958e64. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY mult_11_2_ecdcb40ad0958e64 IS
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END mult_11_2_ecdcb40ad0958e64;

ARCHITECTURE mult_11_2_ecdcb40ad0958e64_a OF mult_11_2_ecdcb40ad0958e64 IS
-- synthesis translate_off
COMPONENT wrapped_mult_11_2_ecdcb40ad0958e64
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_mult_11_2_ecdcb40ad0958e64 USE ENTITY XilinxCoreLib.mult_gen_v11_2(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 18,
      c_b_type => 0,
      c_b_value => "10000001",
      c_b_width => 18,
      c_ccm_imp => 0,
      c_ce_overrides_sclr => 1,
      c_has_ce => 1,
      c_has_sclr => 1,
      c_has_zero_detect => 0,
      c_latency => 3,
      c_model_type => 0,
      c_mult_type => 1,
      c_optimize_goal => 1,
      c_out_high => 35,
      c_out_low => 0,
      c_round_output => 0,
      c_round_pt => 0,
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_mult_11_2_ecdcb40ad0958e64
  PORT MAP (
    clk => clk,
    a => a,
    b => b,
    ce => ce,
    sclr => sclr,
    p => p
  );
-- synthesis translate_on

END mult_11_2_ecdcb40ad0958e64_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_d11668e2ba580388.vhd when simulating
-- the core, addsb_11_0_d11668e2ba580388. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_d11668e2ba580388 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(21 DOWNTO 0)
  );
END addsb_11_0_d11668e2ba580388;

ARCHITECTURE addsb_11_0_d11668e2ba580388_a OF addsb_11_0_d11668e2ba580388 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_d11668e2ba580388
  PORT (
    a : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(21 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_d11668e2ba580388 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 22,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "0000000000000000000000",
      c_b_width => 22,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 22,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_d11668e2ba580388
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_d11668e2ba580388_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_2d8e9bcfdb574c10.vhd when simulating
-- the core, bmg_72_2d8e9bcfdb574c10. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_2d8e9bcfdb574c10 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(4 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END bmg_72_2d8e9bcfdb574c10;

ARCHITECTURE bmg_72_2d8e9bcfdb574c10_a OF bmg_72_2d8e9bcfdb574c10 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_2d8e9bcfdb574c10
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(4 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_2d8e9bcfdb574c10 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 5,
      c_addrb_width => 5,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_2d8e9bcfdb574c10.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 32,
      c_read_depth_b => 32,
      c_read_width_a => 36,
      c_read_width_b => 36,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 32,
      c_write_depth_b => 32,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 36,
      c_write_width_b => 36,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_2d8e9bcfdb574c10
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_2d8e9bcfdb574c10_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_51873a049072c953.vhd when simulating
-- the core, bmg_72_51873a049072c953. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_51873a049072c953 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END bmg_72_51873a049072c953;

ARCHITECTURE bmg_72_51873a049072c953_a OF bmg_72_51873a049072c953 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_51873a049072c953
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_51873a049072c953 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 10,
      c_addrb_width => 10,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_51873a049072c953.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 1024,
      c_read_depth_b => 1024,
      c_read_width_a => 18,
      c_read_width_b => 18,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 1024,
      c_write_depth_b => 1024,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 18,
      c_write_width_b => 18,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_51873a049072c953
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_51873a049072c953_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_f77670697183b527.vhd when simulating
-- the core, bmg_72_f77670697183b527. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_f77670697183b527 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END bmg_72_f77670697183b527;

ARCHITECTURE bmg_72_f77670697183b527_a OF bmg_72_f77670697183b527 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_f77670697183b527
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_f77670697183b527 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 10,
      c_addrb_width => 10,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_f77670697183b527.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 1024,
      c_read_depth_b => 1024,
      c_read_width_a => 18,
      c_read_width_b => 18,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 1024,
      c_write_depth_b => 1024,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 18,
      c_write_width_b => 18,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_f77670697183b527
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_f77670697183b527_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_a6d704d36eb848a5.vhd when simulating
-- the core, bmg_72_a6d704d36eb848a5. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_a6d704d36eb848a5 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(4 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END bmg_72_a6d704d36eb848a5;

ARCHITECTURE bmg_72_a6d704d36eb848a5_a OF bmg_72_a6d704d36eb848a5 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_a6d704d36eb848a5
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(4 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_a6d704d36eb848a5 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 5,
      c_addrb_width => 5,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_a6d704d36eb848a5.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 32,
      c_read_depth_b => 32,
      c_read_width_a => 36,
      c_read_width_b => 36,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 32,
      c_write_depth_b => 32,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 36,
      c_write_width_b => 36,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_a6d704d36eb848a5
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_a6d704d36eb848a5_a;
--------------------------------------------------------------------------------
--     (c) Copyright 1995 - 2010 Xilinx, Inc. All rights reserved.            --
--                                                                            --
--     This file contains confidential and proprietary information            --
--     of Xilinx, Inc. and is protected under U.S. and                        --
--     international copyright and other intellectual property                --
--     laws.                                                                  --
--                                                                            --
--     DISCLAIMER                                                             --
--     This disclaimer is not a license and does not grant any                --
--     rights to the materials distributed herewith. Except as                --
--     otherwise provided in a valid license issued to you by                 --
--     Xilinx, and to the maximum extent permitted by applicable              --
--     law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND                --
--     WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES            --
--     AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING              --
--     BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-                 --
--     INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and               --
--     (2) Xilinx shall not be liable (whether in contract or tort,           --
--     including negligence, or under any other theory of                     --
--     liability) for any loss or damage of any kind or nature                --
--     related to, arising under or in connection with these                  --
--     materials, including for any direct, or any indirect,                  --
--     special, incidental, or consequential loss or damage                   --
--     (including loss of data, profits, goodwill, or any type of             --
--     loss or damage suffered as a result of any action brought              --
--     by a third party) even if such damage or loss was                      --
--     reasonably foreseeable or Xilinx had been advised of the               --
--     possibility of the same.                                               --
--                                                                            --
--     CRITICAL APPLICATIONS                                                  --
--     Xilinx products are not designed or intended to be fail-               --
--     safe, or for use in any application requiring fail-safe                --
--     performance, such as life-support or safety devices or                 --
--     systems, Class III medical devices, nuclear facilities,                --
--     applications related to the deployment of airbags, or any              --
--     other applications that could lead to death, personal                  --
--     injury, or severe property or environmental damage                     --
--     (individually and collectively, "Critical                              --
--     Applications"). Customer assumes the sole risk and                     --
--     liability of any use of Xilinx products in Critical                    --
--     Applications, subject only to applicable laws and                      --
--     regulations governing limitations on product liability.                --
--                                                                            --
--     THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS               --
--     PART OF THIS FILE AT ALL TIMES.                                        --
--------------------------------------------------------------------------------

--  Generated from component ID: xilinx.com:ip:fir_compiler:5.0


-- You must compile the wrapper file fr_cmplr_v5_0_5d372747691e47c4.vhd when simulating
-- the core, fr_cmplr_v5_0_5d372747691e47c4. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY fr_cmplr_v5_0_5d372747691e47c4 IS
	port (
	clk: in std_logic;
	ce: in std_logic;
	nd: in std_logic;
	rfd: out std_logic;
	rdy: out std_logic;
	din: in std_logic_vector(15 downto 0);
	dout: out std_logic_vector(17 downto 0));
END fr_cmplr_v5_0_5d372747691e47c4;

ARCHITECTURE fr_cmplr_v5_0_5d372747691e47c4_a OF fr_cmplr_v5_0_5d372747691e47c4 IS
-- synthesis translate_off
component wrapped_fr_cmplr_v5_0_5d372747691e47c4
	port (
	clk: in std_logic;
	ce: in std_logic;
	nd: in std_logic;
	rfd: out std_logic;
	rdy: out std_logic;
	din: in std_logic_vector(15 downto 0);
	dout: out std_logic_vector(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_fr_cmplr_v5_0_5d372747691e47c4 use entity XilinxCoreLib.fir_compiler_v5_0(behavioral)
		generic map(
			coef_width => 25,
			c_has_sclr => 0,
			datapath_memtype => 0,
			c_component_name => "fr_cmplr_v5_0_5d372747691e47c4",
			c_family => "virtex6",
			round_mode => 4,
			output_width => 18,
			sclr_deterministic => 0,
			col_config => "12",
			coef_memtype => 0,
			clock_freq => 1,
			symmetry => 0,
			col_pipe_len => 4,
			c_latency => 20,
			chan_sel_width => 1,
			c_xdevicefamily => "virtex6",
			c_has_nd => 1,
			allow_approx => 0,
			num_channels => 1,
			data_width => 16,
			filter_sel_width => 1,
			sample_freq => 1,
			coef_reload => 0,
			neg_symmetry => 0,
			filter_type => 1,
			data_type => 0,
			accum_width => 49,
			rate_change_type => 0,
			ipbuff_memtype => 0,
			c_optimization => 1,
			output_reg => 1,
			data_memtype => 0,
			c_has_data_valid => 0,
			decim_rate => 50,
			coef_type => 1,
			filter_arch => 1,
			interp_rate => 1,
			num_taps => 507,
			c_mem_init_file => "fr_cmplr_v5_0_5d372747691e47c4.mif",
			zero_packing_factor => 1,
			num_paths => 1,
			num_filts => 1,
			col_mode => 0,
			c_has_ce => 1,
			chan_in_adv => 0,
			opbuff_memtype => 0,
			odd_symmetry => 1);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_fr_cmplr_v5_0_5d372747691e47c4
		port map (
			clk => clk,
			ce => ce,
			nd => nd,
			rfd => rfd,
			rdy => rdy,
			din => din,
			dout => dout);
-- synthesis translate_on

END fr_cmplr_v5_0_5d372747691e47c4_a;

--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_8e2f9d152d14263e.vhd when simulating
-- the core, bmg_72_8e2f9d152d14263e. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_8e2f9d152d14263e IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(6 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END bmg_72_8e2f9d152d14263e;

ARCHITECTURE bmg_72_8e2f9d152d14263e_a OF bmg_72_8e2f9d152d14263e IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_8e2f9d152d14263e
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(6 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_8e2f9d152d14263e USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 7,
      c_addrb_width => 7,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_8e2f9d152d14263e.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 128,
      c_read_depth_b => 128,
      c_read_width_a => 36,
      c_read_width_b => 36,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 128,
      c_write_depth_b => 128,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 36,
      c_write_width_b => 36,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_8e2f9d152d14263e
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_8e2f9d152d14263e_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_b3a5d690118dc305.vhd when simulating
-- the core, bmg_72_b3a5d690118dc305. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_b3a5d690118dc305 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(5 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END bmg_72_b3a5d690118dc305;

ARCHITECTURE bmg_72_b3a5d690118dc305_a OF bmg_72_b3a5d690118dc305 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_b3a5d690118dc305
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(5 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_b3a5d690118dc305 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 6,
      c_addrb_width => 6,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_b3a5d690118dc305.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 64,
      c_read_depth_b => 64,
      c_read_width_a => 36,
      c_read_width_b => 36,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 64,
      c_write_depth_b => 64,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 36,
      c_write_width_b => 36,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_b3a5d690118dc305
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_b3a5d690118dc305_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_1c3c830b668bf9ed.vhd when simulating
-- the core, addsb_11_0_1c3c830b668bf9ed. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_1c3c830b668bf9ed IS
  PORT (
    a : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(20 DOWNTO 0)
  );
END addsb_11_0_1c3c830b668bf9ed;

ARCHITECTURE addsb_11_0_1c3c830b668bf9ed_a OF addsb_11_0_1c3c830b668bf9ed IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_1c3c830b668bf9ed
  PORT (
    a : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(20 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_1c3c830b668bf9ed USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 21,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "000000000000000000000",
      c_b_width => 21,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 21,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_1c3c830b668bf9ed
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_1c3c830b668bf9ed_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_41035397f321bdbe.vhd when simulating
-- the core, addsb_11_0_41035397f321bdbe. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_41035397f321bdbe IS
  PORT (
    a : IN STD_LOGIC_VECTOR(44 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(44 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(44 DOWNTO 0)
  );
END addsb_11_0_41035397f321bdbe;

ARCHITECTURE addsb_11_0_41035397f321bdbe_a OF addsb_11_0_41035397f321bdbe IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_41035397f321bdbe
  PORT (
    a : IN STD_LOGIC_VECTOR(44 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(44 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(44 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_41035397f321bdbe USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 45,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "000000000000000000000000000000000000000000000",
      c_b_width => 45,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 1,
      c_out_width => 45,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_41035397f321bdbe
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_41035397f321bdbe_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_325ab3980d59a98e.vhd when simulating
-- the core, addsb_11_0_325ab3980d59a98e. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_325ab3980d59a98e IS
  PORT (
    a : IN STD_LOGIC_VECTOR(26 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(26 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(26 DOWNTO 0)
  );
END addsb_11_0_325ab3980d59a98e;

ARCHITECTURE addsb_11_0_325ab3980d59a98e_a OF addsb_11_0_325ab3980d59a98e IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_325ab3980d59a98e
  PORT (
    a : IN STD_LOGIC_VECTOR(26 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(26 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(26 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_325ab3980d59a98e USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 27,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "000000000000000000000000000",
      c_b_width => 27,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 27,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_325ab3980d59a98e
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_325ab3980d59a98e_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_5c0d8fded7f0a054.vhd when simulating
-- the core, cntr_11_0_5c0d8fded7f0a054. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_5c0d8fded7f0a054 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(9 DOWNTO 0)
  );
END cntr_11_0_5c0d8fded7f0a054;

ARCHITECTURE cntr_11_0_5c0d8fded7f0a054_a OF cntr_11_0_5c0d8fded7f0a054 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_5c0d8fded7f0a054
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(9 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_5c0d8fded7f0a054 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 10,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_5c0d8fded7f0a054
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_5c0d8fded7f0a054_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_d53572f04cfc7154.vhd when simulating
-- the core, bmg_72_d53572f04cfc7154. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_d53572f04cfc7154 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(35 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END bmg_72_d53572f04cfc7154;

ARCHITECTURE bmg_72_d53572f04cfc7154_a OF bmg_72_d53572f04cfc7154 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_d53572f04cfc7154
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(35 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_d53572f04cfc7154 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 9,
      c_addrb_width => 9,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_d53572f04cfc7154.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 512,
      c_read_depth_b => 512,
      c_read_width_a => 36,
      c_read_width_b => 36,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 512,
      c_write_depth_b => 512,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 36,
      c_write_width_b => 36,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_d53572f04cfc7154
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_d53572f04cfc7154_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_ed1b80fcdf1c3a46.vhd when simulating
-- the core, bmg_72_ed1b80fcdf1c3a46. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_ed1b80fcdf1c3a46 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END bmg_72_ed1b80fcdf1c3a46;

ARCHITECTURE bmg_72_ed1b80fcdf1c3a46_a OF bmg_72_ed1b80fcdf1c3a46 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_ed1b80fcdf1c3a46
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_ed1b80fcdf1c3a46 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 10,
      c_addrb_width => 10,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_ed1b80fcdf1c3a46.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 1024,
      c_read_depth_b => 1024,
      c_read_width_a => 18,
      c_read_width_b => 18,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 1024,
      c_write_depth_b => 1024,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 18,
      c_write_width_b => 18,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_ed1b80fcdf1c3a46
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_ed1b80fcdf1c3a46_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_eef67c1cc12cdbba.vhd when simulating
-- the core, addsb_11_0_eef67c1cc12cdbba. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_eef67c1cc12cdbba IS
  PORT (
    a : IN STD_LOGIC_VECTOR(43 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(43 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(43 DOWNTO 0)
  );
END addsb_11_0_eef67c1cc12cdbba;

ARCHITECTURE addsb_11_0_eef67c1cc12cdbba_a OF addsb_11_0_eef67c1cc12cdbba IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_eef67c1cc12cdbba
  PORT (
    a : IN STD_LOGIC_VECTOR(43 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(43 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(43 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_eef67c1cc12cdbba USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 44,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000000000000000000000000000000",
      c_b_width => 44,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 1,
      c_out_width => 44,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_eef67c1cc12cdbba
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_eef67c1cc12cdbba_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_5d708e36ddb23a80.vhd when simulating
-- the core, bmg_72_5d708e36ddb23a80. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_5d708e36ddb23a80 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END bmg_72_5d708e36ddb23a80;

ARCHITECTURE bmg_72_5d708e36ddb23a80_a OF bmg_72_5d708e36ddb23a80 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_5d708e36ddb23a80
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_5d708e36ddb23a80 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 10,
      c_addrb_width => 10,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_5d708e36ddb23a80.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 1024,
      c_read_depth_b => 1024,
      c_read_width_a => 18,
      c_read_width_b => 18,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 1024,
      c_write_depth_b => 1024,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 18,
      c_write_width_b => 18,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_5d708e36ddb23a80
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_5d708e36ddb23a80_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file dmg_72_3edbd32a5305b92d.vhd when simulating
-- the core, dmg_72_3edbd32a5305b92d. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY dmg_72_3edbd32a5305b92d IS
  PORT (
    a : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    d : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpra : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    clk : IN STD_LOGIC;
    we : IN STD_LOGIC;
    spo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END dmg_72_3edbd32a5305b92d;

ARCHITECTURE dmg_72_3edbd32a5305b92d_a OF dmg_72_3edbd32a5305b92d IS
-- synthesis translate_off
COMPONENT wrapped_dmg_72_3edbd32a5305b92d
  PORT (
    a : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    d : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpra : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    clk : IN STD_LOGIC;
    we : IN STD_LOGIC;
    spo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0);
    dpo : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_dmg_72_3edbd32a5305b92d USE ENTITY XilinxCoreLib.dist_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addr_width => 4,
      c_default_data => "0",
      c_depth => 16,
      c_family => "virtex6",
      c_has_clk => 1,
      c_has_d => 1,
      c_has_dpo => 1,
      c_has_dpra => 1,
      c_has_i_ce => 0,
      c_has_qdpo => 0,
      c_has_qdpo_ce => 0,
      c_has_qdpo_clk => 0,
      c_has_qdpo_rst => 0,
      c_has_qdpo_srst => 0,
      c_has_qspo => 0,
      c_has_qspo_ce => 0,
      c_has_qspo_rst => 0,
      c_has_qspo_srst => 0,
      c_has_spo => 1,
      c_has_spra => 0,
      c_has_we => 1,
      c_mem_init_file => "dmg_72_3edbd32a5305b92d.mif",
      c_mem_type => 2,
      c_parser_type => 1,
      c_pipeline_stages => 0,
      c_qce_joined => 0,
      c_qualify_we => 0,
      c_read_mif => 1,
      c_reg_a_d_inputs => 0,
      c_reg_dpra_input => 0,
      c_sync_enable => 1,
      c_width => 18
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_dmg_72_3edbd32a5305b92d
  PORT MAP (
    a => a,
    d => d,
    dpra => dpra,
    clk => clk,
    we => we,
    spo => spo,
    dpo => dpo
  );
-- synthesis translate_on

END dmg_72_3edbd32a5305b92d_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_ffcaf565dc759de1.vhd when simulating
-- the core, bmg_72_ffcaf565dc759de1. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_ffcaf565dc759de1 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(4 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END bmg_72_ffcaf565dc759de1;

ARCHITECTURE bmg_72_ffcaf565dc759de1_a OF bmg_72_ffcaf565dc759de1 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_ffcaf565dc759de1
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(4 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_ffcaf565dc759de1 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 5,
      c_addrb_width => 5,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_ffcaf565dc759de1.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 32,
      c_read_depth_b => 32,
      c_read_width_a => 36,
      c_read_width_b => 36,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 32,
      c_write_depth_b => 32,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 36,
      c_write_width_b => 36,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_ffcaf565dc759de1
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_ffcaf565dc759de1_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file mult_11_2_7f50ff10654d69e4.vhd when simulating
-- the core, mult_11_2_7f50ff10654d69e4. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY mult_11_2_7f50ff10654d69e4 IS
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(39 DOWNTO 0)
  );
END mult_11_2_7f50ff10654d69e4;

ARCHITECTURE mult_11_2_7f50ff10654d69e4_a OF mult_11_2_7f50ff10654d69e4 IS
-- synthesis translate_off
COMPONENT wrapped_mult_11_2_7f50ff10654d69e4
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(39 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_mult_11_2_7f50ff10654d69e4 USE ENTITY XilinxCoreLib.mult_gen_v11_2(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_value => "10000001",
      c_b_width => 32,
      c_ccm_imp => 0,
      c_ce_overrides_sclr => 1,
      c_has_ce => 1,
      c_has_sclr => 1,
      c_has_zero_detect => 0,
      c_latency => 5,
      c_model_type => 0,
      c_mult_type => 1,
      c_optimize_goal => 1,
      c_out_high => 39,
      c_out_low => 0,
      c_round_output => 0,
      c_round_pt => 0,
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_mult_11_2_7f50ff10654d69e4
  PORT MAP (
    clk => clk,
    a => a,
    b => b,
    ce => ce,
    sclr => sclr,
    p => p
  );
-- synthesis translate_on

END mult_11_2_7f50ff10654d69e4_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_92d96d23faa10f27.vhd when simulating
-- the core, bmg_72_92d96d23faa10f27. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_92d96d23faa10f27 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END bmg_72_92d96d23faa10f27;

ARCHITECTURE bmg_72_92d96d23faa10f27_a OF bmg_72_92d96d23faa10f27 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_92d96d23faa10f27
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_92d96d23faa10f27 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_92d96d23faa10f27.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 3,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 8,
      c_read_width_b => 8,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 8,
      c_write_width_b => 8,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_92d96d23faa10f27
  PORT MAP (
    clka => clka,
    ena => ena,
    addra => addra,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_92d96d23faa10f27_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2019 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file dmg_72_06baee6e81a49674.vhd when simulating
-- the core, dmg_72_06baee6e81a49674. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY dmg_72_06baee6e81a49674 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    d : IN STD_LOGIC_VECTOR(35 DOWNTO 0);
    dpra : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    clk : IN STD_LOGIC;
    we : IN STD_LOGIC;
    spo : OUT STD_LOGIC_VECTOR(35 DOWNTO 0);
    dpo : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END dmg_72_06baee6e81a49674;

ARCHITECTURE dmg_72_06baee6e81a49674_a OF dmg_72_06baee6e81a49674 IS
-- synthesis translate_off
COMPONENT wrapped_dmg_72_06baee6e81a49674
  PORT (
    a : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    d : IN STD_LOGIC_VECTOR(35 DOWNTO 0);
    dpra : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    clk : IN STD_LOGIC;
    we : IN STD_LOGIC;
    spo : OUT STD_LOGIC_VECTOR(35 DOWNTO 0);
    dpo : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_dmg_72_06baee6e81a49674 USE ENTITY XilinxCoreLib.dist_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addr_width => 4,
      c_default_data => "0",
      c_depth => 16,
      c_family => "virtex6",
      c_has_clk => 1,
      c_has_d => 1,
      c_has_dpo => 1,
      c_has_dpra => 1,
      c_has_i_ce => 0,
      c_has_qdpo => 0,
      c_has_qdpo_ce => 0,
      c_has_qdpo_clk => 0,
      c_has_qdpo_rst => 0,
      c_has_qdpo_srst => 0,
      c_has_qspo => 0,
      c_has_qspo_ce => 0,
      c_has_qspo_rst => 0,
      c_has_qspo_srst => 0,
      c_has_spo => 1,
      c_has_spra => 0,
      c_has_we => 1,
      c_mem_init_file => "dmg_72_06baee6e81a49674.mif",
      c_mem_type => 2,
      c_parser_type => 1,
      c_pipeline_stages => 0,
      c_qce_joined => 0,
      c_qualify_we => 0,
      c_read_mif => 1,
      c_reg_a_d_inputs => 0,
      c_reg_dpra_input => 0,
      c_sync_enable => 1,
      c_width => 36
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_dmg_72_06baee6e81a49674
  PORT MAP (
    a => a,
    d => d,
    dpra => dpra,
    clk => clk,
    we => we,
    spo => spo,
    dpo => dpo
  );
-- synthesis translate_on

END dmg_72_06baee6e81a49674_a;

-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
package conv_pkg is
    constant simulating : boolean := false
      -- synopsys translate_off
        or true
      -- synopsys translate_on
    ;
    constant xlUnsigned : integer := 1;
    constant xlSigned : integer := 2;
    constant xlFloat : integer := 3;
    constant xlWrap : integer := 1;
    constant xlSaturate : integer := 2;
    constant xlTruncate : integer := 1;
    constant xlRound : integer := 2;
    constant xlRoundBanker : integer := 3;
    constant xlAddMode : integer := 1;
    constant xlSubMode : integer := 2;
    attribute black_box : boolean;
    attribute syn_black_box : boolean;
    attribute fpga_dont_touch: string;
    attribute box_type :  string;
    attribute keep : string;
    attribute syn_keep : boolean;
    function std_logic_vector_to_unsigned(inp : std_logic_vector) return unsigned;
    function unsigned_to_std_logic_vector(inp : unsigned) return std_logic_vector;
    function std_logic_vector_to_signed(inp : std_logic_vector) return signed;
    function signed_to_std_logic_vector(inp : signed) return std_logic_vector;
    function unsigned_to_signed(inp : unsigned) return signed;
    function signed_to_unsigned(inp : signed) return unsigned;
    function pos(inp : std_logic_vector; arith : INTEGER) return boolean;
    function all_same(inp: std_logic_vector) return boolean;
    function all_zeros(inp: std_logic_vector) return boolean;
    function is_point_five(inp: std_logic_vector) return boolean;
    function all_ones(inp: std_logic_vector) return boolean;
    function convert_type (inp : std_logic_vector; old_width, old_bin_pt,
                           old_arith, new_width, new_bin_pt, new_arith,
                           quantization, overflow : INTEGER)
        return std_logic_vector;
    function cast (inp : std_logic_vector; old_bin_pt,
                   new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector;
    function shift_division_result(quotient, fraction: std_logic_vector;
                                   fraction_width, shift_value, shift_dir: INTEGER)
        return std_logic_vector;
    function shift_op (inp: std_logic_vector;
                       result_width, shift_value, shift_dir: INTEGER)
        return std_logic_vector;
    function vec_slice (inp : std_logic_vector; upper, lower : INTEGER)
        return std_logic_vector;
    function s2u_slice (inp : signed; upper, lower : INTEGER)
        return unsigned;
    function u2u_slice (inp : unsigned; upper, lower : INTEGER)
        return unsigned;
    function s2s_cast (inp : signed; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return signed;
    function u2s_cast (inp : unsigned; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return signed;
    function s2u_cast (inp : signed; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return unsigned;
    function u2u_cast (inp : unsigned; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return unsigned;
    function u2v_cast (inp : unsigned; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return std_logic_vector;
    function s2v_cast (inp : signed; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return std_logic_vector;
    function trunc (inp : std_logic_vector; old_width, old_bin_pt, old_arith,
                    new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector;
    function round_towards_inf (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt,
                                new_arith : INTEGER) return std_logic_vector;
    function round_towards_even (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt,
                                new_arith : INTEGER) return std_logic_vector;
    function max_signed(width : INTEGER) return std_logic_vector;
    function min_signed(width : INTEGER) return std_logic_vector;
    function saturation_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                              old_arith, new_width, new_bin_pt, new_arith
                              : INTEGER) return std_logic_vector;
    function wrap_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                        old_arith, new_width, new_bin_pt, new_arith : INTEGER)
                        return std_logic_vector;
    function fractional_bits(a_bin_pt, b_bin_pt: INTEGER) return INTEGER;
    function integer_bits(a_width, a_bin_pt, b_width, b_bin_pt: INTEGER)
        return INTEGER;
    function sign_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector;
    function zero_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector;
    function zero_ext(inp : std_logic; new_width : INTEGER)
        return std_logic_vector;
    function extend_MSB(inp : std_logic_vector; new_width, arith : INTEGER)
        return std_logic_vector;
    function align_input(inp : std_logic_vector; old_width, delta, new_arith,
                          new_width: INTEGER)
        return std_logic_vector;
    function pad_LSB(inp : std_logic_vector; new_width: integer)
        return std_logic_vector;
    function pad_LSB(inp : std_logic_vector; new_width, arith : integer)
        return std_logic_vector;
    function max(L, R: INTEGER) return INTEGER;
    function min(L, R: INTEGER) return INTEGER;
    function "="(left,right: STRING) return boolean;
    function boolean_to_signed (inp : boolean; width: integer)
        return signed;
    function boolean_to_unsigned (inp : boolean; width: integer)
        return unsigned;
    function boolean_to_vector (inp : boolean)
        return std_logic_vector;
    function std_logic_to_vector (inp : std_logic)
        return std_logic_vector;
    function integer_to_std_logic_vector (inp : integer;  width, arith : integer)
        return std_logic_vector;
    function std_logic_vector_to_integer (inp : std_logic_vector;  arith : integer)
        return integer;
    function std_logic_to_integer(constant inp : std_logic := '0')
        return integer;
    function bin_string_element_to_std_logic_vector (inp : string;  width, index : integer)
        return std_logic_vector;
    function bin_string_to_std_logic_vector (inp : string)
        return std_logic_vector;
    function hex_string_to_std_logic_vector (inp : string; width : integer)
        return std_logic_vector;
    function makeZeroBinStr (width : integer) return STRING;
    function and_reduce(inp: std_logic_vector) return std_logic;
    -- synopsys translate_off
    function is_binary_string_invalid (inp : string)
        return boolean;
    function is_binary_string_undefined (inp : string)
        return boolean;
    function is_XorU(inp : std_logic_vector)
        return boolean;
    function to_real(inp : std_logic_vector; bin_pt : integer; arith : integer)
        return real;
    function std_logic_to_real(inp : std_logic; bin_pt : integer; arith : integer)
        return real;
    function real_to_std_logic_vector (inp : real;  width, bin_pt, arith : integer)
        return std_logic_vector;
    function real_string_to_std_logic_vector (inp : string;  width, bin_pt, arith : integer)
        return std_logic_vector;
    constant display_precision : integer := 20;
    function real_to_string (inp : real) return string;
    function valid_bin_string(inp : string) return boolean;
    function std_logic_vector_to_bin_string(inp : std_logic_vector) return string;
    function std_logic_to_bin_string(inp : std_logic) return string;
    function std_logic_vector_to_bin_string_w_point(inp : std_logic_vector; bin_pt : integer)
        return string;
    function real_to_bin_string(inp : real;  width, bin_pt, arith : integer)
        return string;
    type stdlogic_to_char_t is array(std_logic) of character;
    constant to_char : stdlogic_to_char_t := (
        'U' => 'U',
        'X' => 'X',
        '0' => '0',
        '1' => '1',
        'Z' => 'Z',
        'W' => 'W',
        'L' => 'L',
        'H' => 'H',
        '-' => '-');
    -- synopsys translate_on
end conv_pkg;
package body conv_pkg is
    function std_logic_vector_to_unsigned(inp : std_logic_vector)
        return unsigned
    is
    begin
        return unsigned (inp);
    end;
    function unsigned_to_std_logic_vector(inp : unsigned)
        return std_logic_vector
    is
    begin
        return std_logic_vector(inp);
    end;
    function std_logic_vector_to_signed(inp : std_logic_vector)
        return signed
    is
    begin
        return  signed (inp);
    end;
    function signed_to_std_logic_vector(inp : signed)
        return std_logic_vector
    is
    begin
        return std_logic_vector(inp);
    end;
    function unsigned_to_signed (inp : unsigned)
        return signed
    is
    begin
        return signed(std_logic_vector(inp));
    end;
    function signed_to_unsigned (inp : signed)
        return unsigned
    is
    begin
        return unsigned(std_logic_vector(inp));
    end;
    function pos(inp : std_logic_vector; arith : INTEGER)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        if arith = xlUnsigned then
            return true;
        else
            if vec(width-1) = '0' then
                return true;
            else
                return false;
            end if;
        end if;
        return true;
    end;
    function max_signed(width : INTEGER)
        return std_logic_vector
    is
        variable ones : std_logic_vector(width-2 downto 0);
        variable result : std_logic_vector(width-1 downto 0);
    begin
        ones := (others => '1');
        result(width-1) := '0';
        result(width-2 downto 0) := ones;
        return result;
    end;
    function min_signed(width : INTEGER)
        return std_logic_vector
    is
        variable zeros : std_logic_vector(width-2 downto 0);
        variable result : std_logic_vector(width-1 downto 0);
    begin
        zeros := (others => '0');
        result(width-1) := '1';
        result(width-2 downto 0) := zeros;
        return result;
    end;
    function and_reduce(inp: std_logic_vector) return std_logic
    is
        variable result: std_logic;
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        result := vec(0);
        if width > 1 then
            for i in 1 to width-1 loop
                result := result and vec(i);
            end loop;
        end if;
        return result;
    end;
    function all_same(inp: std_logic_vector) return boolean
    is
        variable result: boolean;
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        result := true;
        if width > 0 then
            for i in 1 to width-1 loop
                if vec(i) /= vec(0) then
                    result := false;
                end if;
            end loop;
        end if;
        return result;
    end;
    function all_zeros(inp: std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable zero : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        zero := (others => '0');
        vec := inp;
        -- synopsys translate_off
        if (is_XorU(vec)) then
            return false;
        end if;
         -- synopsys translate_on
        if (std_logic_vector_to_unsigned(vec) = std_logic_vector_to_unsigned(zero)) then
            result := true;
        else
            result := false;
        end if;
        return result;
    end;
    function is_point_five(inp: std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        vec := inp;
        -- synopsys translate_off
        if (is_XorU(vec)) then
            return false;
        end if;
         -- synopsys translate_on
        if (width > 1) then
           if ((vec(width-1) = '1') and (all_zeros(vec(width-2 downto 0)) = true)) then
               result := true;
           else
               result := false;
           end if;
        else
           if (vec(width-1) = '1') then
               result := true;
           else
               result := false;
           end if;
        end if;
        return result;
    end;
    function all_ones(inp: std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable one : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        one := (others => '1');
        vec := inp;
        -- synopsys translate_off
        if (is_XorU(vec)) then
            return false;
        end if;
         -- synopsys translate_on
        if (std_logic_vector_to_unsigned(vec) = std_logic_vector_to_unsigned(one)) then
            result := true;
        else
            result := false;
        end if;
        return result;
    end;
    function full_precision_num_width(quantization, overflow, old_width,
                                      old_bin_pt, old_arith,
                                      new_width, new_bin_pt, new_arith : INTEGER)
        return integer
    is
        variable result : integer;
    begin
        result := old_width + 2;
        return result;
    end;
    function quantized_num_width(quantization, overflow, old_width, old_bin_pt,
                                 old_arith, new_width, new_bin_pt, new_arith
                                 : INTEGER)
        return integer
    is
        variable right_of_dp, left_of_dp, result : integer;
    begin
        right_of_dp := max(new_bin_pt, old_bin_pt);
        left_of_dp := max((new_width - new_bin_pt), (old_width - old_bin_pt));
        result := (old_width + 2) + (new_bin_pt - old_bin_pt);
        return result;
    end;
    function convert_type (inp : std_logic_vector; old_width, old_bin_pt,
                           old_arith, new_width, new_bin_pt, new_arith,
                           quantization, overflow : INTEGER)
        return std_logic_vector
    is
        constant fp_width : integer :=
            full_precision_num_width(quantization, overflow, old_width,
                                     old_bin_pt, old_arith, new_width,
                                     new_bin_pt, new_arith);
        constant fp_bin_pt : integer := old_bin_pt;
        constant fp_arith : integer := old_arith;
        variable full_precision_result : std_logic_vector(fp_width-1 downto 0);
        constant q_width : integer :=
            quantized_num_width(quantization, overflow, old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt, new_arith);
        constant q_bin_pt : integer := new_bin_pt;
        constant q_arith : integer := old_arith;
        variable quantized_result : std_logic_vector(q_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        result := (others => '0');
        full_precision_result := cast(inp, old_bin_pt, fp_width, fp_bin_pt,
                                      fp_arith);
        if (quantization = xlRound) then
            quantized_result := round_towards_inf(full_precision_result,
                                                  fp_width, fp_bin_pt,
                                                  fp_arith, q_width, q_bin_pt,
                                                  q_arith);
        elsif (quantization = xlRoundBanker) then
            quantized_result := round_towards_even(full_precision_result,
                                                  fp_width, fp_bin_pt,
                                                  fp_arith, q_width, q_bin_pt,
                                                  q_arith);
        else
            quantized_result := trunc(full_precision_result, fp_width, fp_bin_pt,
                                      fp_arith, q_width, q_bin_pt, q_arith);
        end if;
        if (overflow = xlSaturate) then
            result := saturation_arith(quantized_result, q_width, q_bin_pt,
                                       q_arith, new_width, new_bin_pt, new_arith);
        else
             result := wrap_arith(quantized_result, q_width, q_bin_pt, q_arith,
                                  new_width, new_bin_pt, new_arith);
        end if;
        return result;
    end;
    function cast (inp : std_logic_vector; old_bin_pt, new_width,
                   new_bin_pt, new_arith : INTEGER)
        return std_logic_vector
    is
        constant old_width : integer := inp'length;
        constant left_of_dp : integer := (new_width - new_bin_pt)
                                         - (old_width - old_bin_pt);
        constant right_of_dp : integer := (new_bin_pt - old_bin_pt);
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable j   : integer;
    begin
        vec := inp;
        for i in new_width-1 downto 0 loop
            j := i - right_of_dp;
            if ( j > old_width-1) then
                if (new_arith = xlUnsigned) then
                    result(i) := '0';
                else
                    result(i) := vec(old_width-1);
                end if;
            elsif ( j >= 0) then
                result(i) := vec(j);
            else
                result(i) := '0';
            end if;
        end loop;
        return result;
    end;
    function shift_division_result(quotient, fraction: std_logic_vector;
                                   fraction_width, shift_value, shift_dir: INTEGER)
        return std_logic_vector
    is
        constant q_width : integer := quotient'length;
        constant f_width : integer := fraction'length;
        constant vec_MSB : integer := q_width+f_width-1;
        constant result_MSB : integer := q_width+fraction_width-1;
        constant result_LSB : integer := vec_MSB-result_MSB;
        variable vec : std_logic_vector(vec_MSB downto 0);
        variable result : std_logic_vector(result_MSB downto 0);
    begin
        vec := ( quotient & fraction );
        if shift_dir = 1 then
            for i in vec_MSB downto 0 loop
                if (i < shift_value) then
                     vec(i) := '0';
                else
                    vec(i) := vec(i-shift_value);
                end if;
            end loop;
        else
            for i in 0 to vec_MSB loop
                if (i > vec_MSB-shift_value) then
                    vec(i) := vec(vec_MSB);
                else
                    vec(i) := vec(i+shift_value);
                end if;
            end loop;
        end if;
        result := vec(vec_MSB downto result_LSB);
        return result;
    end;
    function shift_op (inp: std_logic_vector;
                       result_width, shift_value, shift_dir: INTEGER)
        return std_logic_vector
    is
        constant inp_width : integer := inp'length;
        constant vec_MSB : integer := inp_width-1;
        constant result_MSB : integer := result_width-1;
        constant result_LSB : integer := vec_MSB-result_MSB;
        variable vec : std_logic_vector(vec_MSB downto 0);
        variable result : std_logic_vector(result_MSB downto 0);
    begin
        vec := inp;
        if shift_dir = 1 then
            for i in vec_MSB downto 0 loop
                if (i < shift_value) then
                     vec(i) := '0';
                else
                    vec(i) := vec(i-shift_value);
                end if;
            end loop;
        else
            for i in 0 to vec_MSB loop
                if (i > vec_MSB-shift_value) then
                    vec(i) := vec(vec_MSB);
                else
                    vec(i) := vec(i+shift_value);
                end if;
            end loop;
        end if;
        result := vec(vec_MSB downto result_LSB);
        return result;
    end;
    function vec_slice (inp : std_logic_vector; upper, lower : INTEGER)
      return std_logic_vector
    is
    begin
        return inp(upper downto lower);
    end;
    function s2u_slice (inp : signed; upper, lower : INTEGER)
      return unsigned
    is
    begin
        return unsigned(vec_slice(std_logic_vector(inp), upper, lower));
    end;
    function u2u_slice (inp : unsigned; upper, lower : INTEGER)
      return unsigned
    is
    begin
        return unsigned(vec_slice(std_logic_vector(inp), upper, lower));
    end;
    function s2s_cast (inp : signed; old_bin_pt, new_width, new_bin_pt : INTEGER)
        return signed
    is
    begin
        return signed(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlSigned));
    end;
    function s2u_cast (inp : signed; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return unsigned
    is
    begin
        return unsigned(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlSigned));
    end;
    function u2s_cast (inp : unsigned; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return signed
    is
    begin
        return signed(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlUnsigned));
    end;
    function u2u_cast (inp : unsigned; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return unsigned
    is
    begin
        return unsigned(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlUnsigned));
    end;
    function u2v_cast (inp : unsigned; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return std_logic_vector
    is
    begin
        return cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlUnsigned);
    end;
    function s2v_cast (inp : signed; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return std_logic_vector
    is
    begin
        return cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlSigned);
    end;
    function boolean_to_signed (inp : boolean; width : integer)
        return signed
    is
        variable result : signed(width - 1 downto 0);
    begin
        result := (others => '0');
        if inp then
          result(0) := '1';
        else
          result(0) := '0';
        end if;
        return result;
    end;
    function boolean_to_unsigned (inp : boolean; width : integer)
        return unsigned
    is
        variable result : unsigned(width - 1 downto 0);
    begin
        result := (others => '0');
        if inp then
          result(0) := '1';
        else
          result(0) := '0';
        end if;
        return result;
    end;
    function boolean_to_vector (inp : boolean)
        return std_logic_vector
    is
        variable result : std_logic_vector(1 - 1 downto 0);
    begin
        result := (others => '0');
        if inp then
          result(0) := '1';
        else
          result(0) := '0';
        end if;
        return result;
    end;
    function std_logic_to_vector (inp : std_logic)
        return std_logic_vector
    is
        variable result : std_logic_vector(1 - 1 downto 0);
    begin
        result(0) := inp;
        return result;
    end;
    function trunc (inp : std_logic_vector; old_width, old_bin_pt, old_arith,
                                new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector
    is
        constant right_of_dp : integer := (old_bin_pt - new_bin_pt);
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if right_of_dp >= 0 then
            if new_arith = xlUnsigned then
                result := zero_ext(vec(old_width-1 downto right_of_dp), new_width);
            else
                result := sign_ext(vec(old_width-1 downto right_of_dp), new_width);
            end if;
        else
            if new_arith = xlUnsigned then
                result := zero_ext(pad_LSB(vec, old_width +
                                           abs(right_of_dp)), new_width);
            else
                result := sign_ext(pad_LSB(vec, old_width +
                                           abs(right_of_dp)), new_width);
            end if;
        end if;
        return result;
    end;
    function round_towards_inf (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt, new_arith
                                : INTEGER)
        return std_logic_vector
    is
        constant right_of_dp : integer := (old_bin_pt - new_bin_pt);
        constant expected_new_width : integer :=  old_width - right_of_dp  + 1;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable one_or_zero : std_logic_vector(new_width-1 downto 0);
        variable truncated_val : std_logic_vector(new_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if right_of_dp >= 0 then
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            else
                truncated_val := sign_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            end if;
        else
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            else
                truncated_val := sign_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            end if;
        end if;
        one_or_zero := (others => '0');
        if (new_arith = xlSigned) then
            if (vec(old_width-1) = '0') then
                one_or_zero(0) := '1';
            end if;
            if (right_of_dp >= 2) and (right_of_dp <= old_width) then
                if (all_zeros(vec(right_of_dp-2 downto 0)) = false) then
                    one_or_zero(0) := '1';
                end if;
            end if;
            if (right_of_dp >= 1) and (right_of_dp <= old_width) then
                if vec(right_of_dp-1) = '0' then
                    one_or_zero(0) := '0';
                end if;
            else
                one_or_zero(0) := '0';
            end if;
        else
            if (right_of_dp >= 1) and (right_of_dp <= old_width) then
                one_or_zero(0) :=  vec(right_of_dp-1);
            end if;
        end if;
        if new_arith = xlSigned then
            result := signed_to_std_logic_vector(std_logic_vector_to_signed(truncated_val) +
                                                 std_logic_vector_to_signed(one_or_zero));
        else
            result := unsigned_to_std_logic_vector(std_logic_vector_to_unsigned(truncated_val) +
                                                  std_logic_vector_to_unsigned(one_or_zero));
        end if;
        return result;
    end;
    function round_towards_even (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt, new_arith
                                : INTEGER)
        return std_logic_vector
    is
        constant right_of_dp : integer := (old_bin_pt - new_bin_pt);
        constant expected_new_width : integer :=  old_width - right_of_dp  + 1;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable one_or_zero : std_logic_vector(new_width-1 downto 0);
        variable truncated_val : std_logic_vector(new_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if right_of_dp >= 0 then
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            else
                truncated_val := sign_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            end if;
        else
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            else
                truncated_val := sign_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            end if;
        end if;
        one_or_zero := (others => '0');
        if (right_of_dp >= 1) and (right_of_dp <= old_width) then
            if (is_point_five(vec(right_of_dp-1 downto 0)) = false) then
                one_or_zero(0) :=  vec(right_of_dp-1);
            else
                one_or_zero(0) :=  vec(right_of_dp);
            end if;
        end if;
        if new_arith = xlSigned then
            result := signed_to_std_logic_vector(std_logic_vector_to_signed(truncated_val) +
                                                 std_logic_vector_to_signed(one_or_zero));
        else
            result := unsigned_to_std_logic_vector(std_logic_vector_to_unsigned(truncated_val) +
                                                  std_logic_vector_to_unsigned(one_or_zero));
        end if;
        return result;
    end;
    function saturation_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                              old_arith, new_width, new_bin_pt, new_arith
                              : INTEGER)
        return std_logic_vector
    is
        constant left_of_dp : integer := (old_width - old_bin_pt) -
                                         (new_width - new_bin_pt);
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable overflow : boolean;
    begin
        vec := inp;
        overflow := true;
        result := (others => '0');
        if (new_width >= old_width) then
            overflow := false;
        end if;
        if ((old_arith = xlSigned and new_arith = xlSigned) and (old_width > new_width)) then
            if all_same(vec(old_width-1 downto new_width-1)) then
                overflow := false;
            end if;
        end if;
        if (old_arith = xlSigned and new_arith = xlUnsigned) then
            if (old_width > new_width) then
                if all_zeros(vec(old_width-1 downto new_width)) then
                    overflow := false;
                end if;
            else
                if (old_width = new_width) then
                    if (vec(new_width-1) = '0') then
                        overflow := false;
                    end if;
                end if;
            end if;
        end if;
        if (old_arith = xlUnsigned and new_arith = xlUnsigned) then
            if (old_width > new_width) then
                if all_zeros(vec(old_width-1 downto new_width)) then
                    overflow := false;
                end if;
            else
                if (old_width = new_width) then
                    overflow := false;
                end if;
            end if;
        end if;
        if ((old_arith = xlUnsigned and new_arith = xlSigned) and (old_width > new_width)) then
            if all_same(vec(old_width-1 downto new_width-1)) then
                overflow := false;
            end if;
        end if;
        if overflow then
            if new_arith = xlSigned then
                if vec(old_width-1) = '0' then
                    result := max_signed(new_width);
                else
                    result := min_signed(new_width);
                end if;
            else
                if ((old_arith = xlSigned) and vec(old_width-1) = '1') then
                    result := (others => '0');
                else
                    result := (others => '1');
                end if;
            end if;
        else
            if (old_arith = xlSigned) and (new_arith = xlUnsigned) then
                if (vec(old_width-1) = '1') then
                    vec := (others => '0');
                end if;
            end if;
            if new_width <= old_width then
                result := vec(new_width-1 downto 0);
            else
                if new_arith = xlUnsigned then
                    result := zero_ext(vec, new_width);
                else
                    result := sign_ext(vec, new_width);
                end if;
            end if;
        end if;
        return result;
    end;
   function wrap_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                       old_arith, new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector
    is
        variable result : std_logic_vector(new_width-1 downto 0);
        variable result_arith : integer;
    begin
        if (old_arith = xlSigned) and (new_arith = xlUnsigned) then
            result_arith := xlSigned;
        end if;
        result := cast(inp, old_bin_pt, new_width, new_bin_pt, result_arith);
        return result;
    end;
    function fractional_bits(a_bin_pt, b_bin_pt: INTEGER) return INTEGER is
    begin
        return max(a_bin_pt, b_bin_pt);
    end;
    function integer_bits(a_width, a_bin_pt, b_width, b_bin_pt: INTEGER)
        return INTEGER is
    begin
        return  max(a_width - a_bin_pt, b_width - b_bin_pt);
    end;
    function pad_LSB(inp : std_logic_vector; new_width: integer)
        return STD_LOGIC_VECTOR
    is
        constant orig_width : integer := inp'length;
        variable vec : std_logic_vector(orig_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable pos : integer;
        constant pad_pos : integer := new_width - orig_width - 1;
    begin
        vec := inp;
        pos := new_width-1;
        if (new_width >= orig_width) then
            for i in orig_width-1 downto 0 loop
                result(pos) := vec(i);
                pos := pos - 1;
            end loop;
            if pad_pos >= 0 then
                for i in pad_pos downto 0 loop
                    result(i) := '0';
                end loop;
            end if;
        end if;
        return result;
    end;
    function sign_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector
    is
        constant old_width : integer := inp'length;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if new_width >= old_width then
            result(old_width-1 downto 0) := vec;
            if new_width-1 >= old_width then
                for i in new_width-1 downto old_width loop
                    result(i) := vec(old_width-1);
                end loop;
            end if;
        else
            result(new_width-1 downto 0) := vec(new_width-1 downto 0);
        end if;
        return result;
    end;
    function zero_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector
    is
        constant old_width : integer := inp'length;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if new_width >= old_width then
            result(old_width-1 downto 0) := vec;
            if new_width-1 >= old_width then
                for i in new_width-1 downto old_width loop
                    result(i) := '0';
                end loop;
            end if;
        else
            result(new_width-1 downto 0) := vec(new_width-1 downto 0);
        end if;
        return result;
    end;
    function zero_ext(inp : std_logic; new_width : INTEGER)
        return std_logic_vector
    is
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        result(0) := inp;
        for i in new_width-1 downto 1 loop
            result(i) := '0';
        end loop;
        return result;
    end;
    function extend_MSB(inp : std_logic_vector; new_width, arith : INTEGER)
        return std_logic_vector
    is
        constant orig_width : integer := inp'length;
        variable vec : std_logic_vector(orig_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if arith = xlUnsigned then
            result := zero_ext(vec, new_width);
        else
            result := sign_ext(vec, new_width);
        end if;
        return result;
    end;
    function pad_LSB(inp : std_logic_vector; new_width, arith: integer)
        return STD_LOGIC_VECTOR
    is
        constant orig_width : integer := inp'length;
        variable vec : std_logic_vector(orig_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable pos : integer;
    begin
        vec := inp;
        pos := new_width-1;
        if (arith = xlUnsigned) then
            result(pos) := '0';
            pos := pos - 1;
        else
            result(pos) := vec(orig_width-1);
            pos := pos - 1;
        end if;
        if (new_width >= orig_width) then
            for i in orig_width-1 downto 0 loop
                result(pos) := vec(i);
                pos := pos - 1;
            end loop;
            if pos >= 0 then
                for i in pos downto 0 loop
                    result(i) := '0';
                end loop;
            end if;
        end if;
        return result;
    end;
    function align_input(inp : std_logic_vector; old_width, delta, new_arith,
                         new_width: INTEGER)
        return std_logic_vector
    is
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable padded_inp : std_logic_vector((old_width + delta)-1  downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if delta > 0 then
            padded_inp := pad_LSB(vec, old_width+delta);
            result := extend_MSB(padded_inp, new_width, new_arith);
        else
            result := extend_MSB(vec, new_width, new_arith);
        end if;
        return result;
    end;
    function max(L, R: INTEGER) return INTEGER is
    begin
        if L > R then
            return L;
        else
            return R;
        end if;
    end;
    function min(L, R: INTEGER) return INTEGER is
    begin
        if L < R then
            return L;
        else
            return R;
        end if;
    end;
    function "="(left,right: STRING) return boolean is
    begin
        if (left'length /= right'length) then
            return false;
        else
            test : for i in 1 to left'length loop
                if left(i) /= right(i) then
                    return false;
                end if;
            end loop test;
            return true;
        end if;
    end;
    -- synopsys translate_off
    function is_binary_string_invalid (inp : string)
        return boolean
    is
        variable vec : string(1 to inp'length);
        variable result : boolean;
    begin
        vec := inp;
        result := false;
        for i in 1 to vec'length loop
            if ( vec(i) = 'X' ) then
                result := true;
            end if;
        end loop;
        return result;
    end;
    function is_binary_string_undefined (inp : string)
        return boolean
    is
        variable vec : string(1 to inp'length);
        variable result : boolean;
    begin
        vec := inp;
        result := false;
        for i in 1 to vec'length loop
            if ( vec(i) = 'U' ) then
                result := true;
            end if;
        end loop;
        return result;
    end;
    function is_XorU(inp : std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        vec := inp;
        result := false;
        for i in 0 to width-1 loop
            if (vec(i) = 'U') or (vec(i) = 'X') then
                result := true;
            end if;
        end loop;
        return result;
    end;
    function to_real(inp : std_logic_vector; bin_pt : integer; arith : integer)
        return real
    is
        variable  vec : std_logic_vector(inp'length-1 downto 0);
        variable result, shift_val, undefined_real : real;
        variable neg_num : boolean;
    begin
        vec := inp;
        result := 0.0;
        neg_num := false;
        if vec(inp'length-1) = '1' then
            neg_num := true;
        end if;
        for i in 0 to inp'length-1 loop
            if  vec(i) = 'U' or vec(i) = 'X' then
                return undefined_real;
            end if;
            if arith = xlSigned then
                if neg_num then
                    if vec(i) = '0' then
                        result := result + 2.0**i;
                    end if;
                else
                    if vec(i) = '1' then
                        result := result + 2.0**i;
                    end if;
                end if;
            else
                if vec(i) = '1' then
                    result := result + 2.0**i;
                end if;
            end if;
        end loop;
        if arith = xlSigned then
            if neg_num then
                result := result + 1.0;
                result := result * (-1.0);
            end if;
        end if;
        shift_val := 2.0**(-1*bin_pt);
        result := result * shift_val;
        return result;
    end;
    function std_logic_to_real(inp : std_logic; bin_pt : integer; arith : integer)
        return real
    is
        variable result : real := 0.0;
    begin
        if inp = '1' then
            result := 1.0;
        end if;
        if arith = xlSigned then
            assert false
                report "It doesn't make sense to convert a 1 bit number to a signed real.";
        end if;
        return result;
    end;
    -- synopsys translate_on
    function integer_to_std_logic_vector (inp : integer;  width, arith : integer)
        return std_logic_vector
    is
        variable result : std_logic_vector(width-1 downto 0);
        variable unsigned_val : unsigned(width-1 downto 0);
        variable signed_val : signed(width-1 downto 0);
    begin
        if (arith = xlSigned) then
            signed_val := to_signed(inp, width);
            result := signed_to_std_logic_vector(signed_val);
        else
            unsigned_val := to_unsigned(inp, width);
            result := unsigned_to_std_logic_vector(unsigned_val);
        end if;
        return result;
    end;
    function std_logic_vector_to_integer (inp : std_logic_vector;  arith : integer)
        return integer
    is
        constant width : integer := inp'length;
        variable unsigned_val : unsigned(width-1 downto 0);
        variable signed_val : signed(width-1 downto 0);
        variable result : integer;
    begin
        if (arith = xlSigned) then
            signed_val := std_logic_vector_to_signed(inp);
            result := to_integer(signed_val);
        else
            unsigned_val := std_logic_vector_to_unsigned(inp);
            result := to_integer(unsigned_val);
        end if;
        return result;
    end;
    function std_logic_to_integer(constant inp : std_logic := '0')
        return integer
    is
    begin
        if inp = '1' then
            return 1;
        else
            return 0;
        end if;
    end;
    function makeZeroBinStr (width : integer) return STRING is
        variable result : string(1 to width+3);
    begin
        result(1) := '0';
        result(2) := 'b';
        for i in 3 to width+2 loop
            result(i) := '0';
        end loop;
        result(width+3) := '.';
        return result;
    end;
    -- synopsys translate_off
    function real_string_to_std_logic_vector (inp : string;  width, bin_pt, arith : integer)
        return std_logic_vector
    is
        variable result : std_logic_vector(width-1 downto 0);
    begin
        result := (others => '0');
        return result;
    end;
    function real_to_std_logic_vector (inp : real;  width, bin_pt, arith : integer)
        return std_logic_vector
    is
        variable real_val : real;
        variable int_val : integer;
        variable result : std_logic_vector(width-1 downto 0) := (others => '0');
        variable unsigned_val : unsigned(width-1 downto 0) := (others => '0');
        variable signed_val : signed(width-1 downto 0) := (others => '0');
    begin
        real_val := inp;
        int_val := integer(real_val * 2.0**(bin_pt));
        if (arith = xlSigned) then
            signed_val := to_signed(int_val, width);
            result := signed_to_std_logic_vector(signed_val);
        else
            unsigned_val := to_unsigned(int_val, width);
            result := unsigned_to_std_logic_vector(unsigned_val);
        end if;
        return result;
    end;
    -- synopsys translate_on
    function valid_bin_string (inp : string)
        return boolean
    is
        variable vec : string(1 to inp'length);
    begin
        vec := inp;
        if (vec(1) = '0' and vec(2) = 'b') then
            return true;
        else
            return false;
        end if;
    end;
    function hex_string_to_std_logic_vector(inp: string; width : integer)
        return std_logic_vector is
        constant strlen       : integer := inp'LENGTH;
        variable result       : std_logic_vector(width-1 downto 0);
        variable bitval       : std_logic_vector((strlen*4)-1 downto 0);
        variable posn         : integer;
        variable ch           : character;
        variable vec          : string(1 to strlen);
    begin
        vec := inp;
        result := (others => '0');
        posn := (strlen*4)-1;
        for i in 1 to strlen loop
            ch := vec(i);
            case ch is
                when '0' => bitval(posn downto posn-3) := "0000";
                when '1' => bitval(posn downto posn-3) := "0001";
                when '2' => bitval(posn downto posn-3) := "0010";
                when '3' => bitval(posn downto posn-3) := "0011";
                when '4' => bitval(posn downto posn-3) := "0100";
                when '5' => bitval(posn downto posn-3) := "0101";
                when '6' => bitval(posn downto posn-3) := "0110";
                when '7' => bitval(posn downto posn-3) := "0111";
                when '8' => bitval(posn downto posn-3) := "1000";
                when '9' => bitval(posn downto posn-3) := "1001";
                when 'A' | 'a' => bitval(posn downto posn-3) := "1010";
                when 'B' | 'b' => bitval(posn downto posn-3) := "1011";
                when 'C' | 'c' => bitval(posn downto posn-3) := "1100";
                when 'D' | 'd' => bitval(posn downto posn-3) := "1101";
                when 'E' | 'e' => bitval(posn downto posn-3) := "1110";
                when 'F' | 'f' => bitval(posn downto posn-3) := "1111";
                when others => bitval(posn downto posn-3) := "XXXX";
                               -- synopsys translate_off
                               ASSERT false
                                   REPORT "Invalid hex value" SEVERITY ERROR;
                               -- synopsys translate_on
            end case;
            posn := posn - 4;
        end loop;
        if (width <= strlen*4) then
            result :=  bitval(width-1 downto 0);
        else
            result((strlen*4)-1 downto 0) := bitval;
        end if;
        return result;
    end;
    function bin_string_to_std_logic_vector (inp : string)
        return std_logic_vector
    is
        variable pos : integer;
        variable vec : string(1 to inp'length);
        variable result : std_logic_vector(inp'length-1 downto 0);
    begin
        vec := inp;
        pos := inp'length-1;
        result := (others => '0');
        for i in 1 to vec'length loop
            -- synopsys translate_off
            if (pos < 0) and (vec(i) = '0' or vec(i) = '1' or vec(i) = 'X' or vec(i) = 'U')  then
                assert false
                    report "Input string is larger than output std_logic_vector. Truncating output.";
                return result;
            end if;
            -- synopsys translate_on
            if vec(i) = '0' then
                result(pos) := '0';
                pos := pos - 1;
            end if;
            if vec(i) = '1' then
                result(pos) := '1';
                pos := pos - 1;
            end if;
            -- synopsys translate_off
            if (vec(i) = 'X' or vec(i) = 'U') then
                result(pos) := 'U';
                pos := pos - 1;
            end if;
            -- synopsys translate_on
        end loop;
        return result;
    end;
    function bin_string_element_to_std_logic_vector (inp : string;  width, index : integer)
        return std_logic_vector
    is
        constant str_width : integer := width + 4;
        constant inp_len : integer := inp'length;
        constant num_elements : integer := (inp_len + 1)/str_width;
        constant reverse_index : integer := (num_elements-1) - index;
        variable left_pos : integer;
        variable right_pos : integer;
        variable vec : string(1 to inp'length);
        variable result : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        result := (others => '0');
        if (reverse_index = 0) and (reverse_index < num_elements) and (inp_len-3 >= width) then
            left_pos := 1;
            right_pos := width + 3;
            result := bin_string_to_std_logic_vector(vec(left_pos to right_pos));
        end if;
        if (reverse_index > 0) and (reverse_index < num_elements) and (inp_len-3 >= width) then
            left_pos := (reverse_index * str_width) + 1;
            right_pos := left_pos + width + 2;
            result := bin_string_to_std_logic_vector(vec(left_pos to right_pos));
        end if;
        return result;
    end;
   -- synopsys translate_off
    function std_logic_vector_to_bin_string(inp : std_logic_vector)
        return string
    is
        variable vec : std_logic_vector(1 to inp'length);
        variable result : string(vec'range);
    begin
        vec := inp;
        for i in vec'range loop
            result(i) := to_char(vec(i));
        end loop;
        return result;
    end;
    function std_logic_to_bin_string(inp : std_logic)
        return string
    is
        variable result : string(1 to 3);
    begin
        result(1) := '0';
        result(2) := 'b';
        result(3) := to_char(inp);
        return result;
    end;
    function std_logic_vector_to_bin_string_w_point(inp : std_logic_vector; bin_pt : integer)
        return string
    is
        variable width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable str_pos : integer;
        variable result : string(1 to width+3);
    begin
        vec := inp;
        str_pos := 1;
        result(str_pos) := '0';
        str_pos := 2;
        result(str_pos) := 'b';
        str_pos := 3;
        for i in width-1 downto 0  loop
            if (((width+3) - bin_pt) = str_pos) then
                result(str_pos) := '.';
                str_pos := str_pos + 1;
            end if;
            result(str_pos) := to_char(vec(i));
            str_pos := str_pos + 1;
        end loop;
        if (bin_pt = 0) then
            result(str_pos) := '.';
        end if;
        return result;
    end;
    function real_to_bin_string(inp : real;  width, bin_pt, arith : integer)
        return string
    is
        variable result : string(1 to width);
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := real_to_std_logic_vector(inp, width, bin_pt, arith);
        result := std_logic_vector_to_bin_string(vec);
        return result;
    end;
    function real_to_string (inp : real) return string
    is
        variable result : string(1 to display_precision) := (others => ' ');
    begin
        result(real'image(inp)'range) := real'image(inp);
        return result;
    end;
    -- synopsys translate_on
end conv_pkg;

-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library unisim;
use unisim.vcomponents.all;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity srl17e is
    generic (width : integer:=16;
             latency : integer :=8);
    port (clk   : in std_logic;
          ce    : in std_logic;
          d     : in std_logic_vector(width-1 downto 0);
          q     : out std_logic_vector(width-1 downto 0));
end srl17e;
architecture structural of srl17e is
    component SRL16E
        port (D   : in STD_ULOGIC;
              CE  : in STD_ULOGIC;
              CLK : in STD_ULOGIC;
              A0  : in STD_ULOGIC;
              A1  : in STD_ULOGIC;
              A2  : in STD_ULOGIC;
              A3  : in STD_ULOGIC;
              Q   : out STD_ULOGIC);
    end component;
    attribute syn_black_box of SRL16E : component is true;
    attribute fpga_dont_touch of SRL16E : component is "true";
    component FDE
        port(
            Q  :        out   STD_ULOGIC;
            D  :        in    STD_ULOGIC;
            C  :        in    STD_ULOGIC;
            CE :        in    STD_ULOGIC);
    end component;
    attribute syn_black_box of FDE : component is true;
    attribute fpga_dont_touch of FDE : component is "true";
    constant a : std_logic_vector(4 downto 0) :=
        integer_to_std_logic_vector(latency-2,5,xlSigned);
    signal d_delayed : std_logic_vector(width-1 downto 0);
    signal srl16_out : std_logic_vector(width-1 downto 0);
begin
    d_delayed <= d after 200 ps;
    reg_array : for i in 0 to width-1 generate
        srl16_used: if latency > 1 generate
            u1 : srl16e port map(clk => clk,
                                 d => d_delayed(i),
                                 q => srl16_out(i),
                                 ce => ce,
                                 a0 => a(0),
                                 a1 => a(1),
                                 a2 => a(2),
                                 a3 => a(3));
        end generate;
        srl16_not_used: if latency <= 1 generate
            srl16_out(i) <= d_delayed(i);
        end generate;
        fde_used: if latency /= 0  generate
            u2 : fde port map(c => clk,
                              d => srl16_out(i),
                              q => q(i),
                              ce => ce);
        end generate;
        fde_not_used: if latency = 0  generate
            q(i) <= srl16_out(i);
        end generate;
    end generate;
 end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity synth_reg is
    generic (width           : integer := 8;
             latency         : integer := 1);
    port (i       : in std_logic_vector(width-1 downto 0);
          ce      : in std_logic;
          clr     : in std_logic;
          clk     : in std_logic;
          o       : out std_logic_vector(width-1 downto 0));
end synth_reg;
architecture structural of synth_reg is
    component srl17e
        generic (width : integer:=16;
                 latency : integer :=8);
        port (clk : in std_logic;
              ce  : in std_logic;
              d   : in std_logic_vector(width-1 downto 0);
              q   : out std_logic_vector(width-1 downto 0));
    end component;
    function calc_num_srl17es (latency : integer)
        return integer
    is
        variable remaining_latency : integer;
        variable result : integer;
    begin
        result := latency / 17;
        remaining_latency := latency - (result * 17);
        if (remaining_latency /= 0) then
            result := result + 1;
        end if;
        return result;
    end;
    constant complete_num_srl17es : integer := latency / 17;
    constant num_srl17es : integer := calc_num_srl17es(latency);
    constant remaining_latency : integer := latency - (complete_num_srl17es * 17);
    type register_array is array (num_srl17es downto 0) of
        std_logic_vector(width-1 downto 0);
    signal z : register_array;
begin
    z(0) <= i;
    complete_ones : if complete_num_srl17es > 0 generate
        srl17e_array: for i in 0 to complete_num_srl17es-1 generate
            delay_comp : srl17e
                generic map (width => width,
                             latency => 17)
                port map (clk => clk,
                          ce  => ce,
                          d       => z(i),
                          q       => z(i+1));
        end generate;
    end generate;
    partial_one : if remaining_latency > 0 generate
        last_srl17e : srl17e
            generic map (width => width,
                         latency => remaining_latency)
            port map (clk => clk,
                      ce  => ce,
                      d   => z(num_srl17es-1),
                      q   => z(num_srl17es));
    end generate;
    o <= z(num_srl17es);
end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity synth_reg_reg is
    generic (width           : integer := 8;
             latency         : integer := 1);
    port (i       : in std_logic_vector(width-1 downto 0);
          ce      : in std_logic;
          clr     : in std_logic;
          clk     : in std_logic;
          o       : out std_logic_vector(width-1 downto 0));
end synth_reg_reg;
architecture behav of synth_reg_reg is
  type reg_array_type is array (latency-1 downto 0) of std_logic_vector(width -1 downto 0);
  signal reg_bank : reg_array_type := (others => (others => '0'));
  signal reg_bank_in : reg_array_type := (others => (others => '0'));
  attribute syn_allow_retiming : boolean;
  attribute syn_srlstyle : string;
  attribute syn_allow_retiming of reg_bank : signal is true;
  attribute syn_allow_retiming of reg_bank_in : signal is true;
  attribute syn_srlstyle of reg_bank : signal is "registers";
  attribute syn_srlstyle of reg_bank_in : signal is "registers";
begin
  latency_eq_0: if latency = 0 generate
    o <= i;
  end generate latency_eq_0;
  latency_gt_0: if latency >= 1 generate
    o <= reg_bank(latency-1);
    reg_bank_in(0) <= i;
    loop_gen: for idx in latency-2 downto 0 generate
      reg_bank_in(idx+1) <= reg_bank(idx);
    end generate loop_gen;
    sync_loop: for sync_idx in latency-1 downto 0 generate
      sync_proc: process (clk)
      begin
        if clk'event and clk = '1' then
          if clr = '1' then
            reg_bank_in <= (others => (others => '0'));
          elsif ce = '1'  then
            reg_bank(sync_idx) <= reg_bank_in(sync_idx);
          end if;
        end if;
      end process sync_proc;
    end generate sync_loop;
  end generate latency_gt_0;
end behav;

-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library unisim;
use unisim.vcomponents.all;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity single_reg_w_init is
  generic (
    width: integer := 8;
    init_index: integer := 0;
    init_value: bit_vector := b"0000"
  );
  port (
    i: in std_logic_vector(width - 1 downto 0);
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    o: out std_logic_vector(width - 1 downto 0)
  );
end single_reg_w_init;
architecture structural of single_reg_w_init is
  function build_init_const(width: integer;
                            init_index: integer;
                            init_value: bit_vector)
    return std_logic_vector
  is
    variable result: std_logic_vector(width - 1 downto 0);
  begin
    if init_index = 0 then
      result := (others => '0');
    elsif init_index = 1 then
      result := (others => '0');
      result(0) := '1';
    else
      result := to_stdlogicvector(init_value);
    end if;
    return result;
  end;
  component fdre
    port (
      q: out std_ulogic;
      d: in  std_ulogic;
      c: in  std_ulogic;
      ce: in  std_ulogic;
      r: in  std_ulogic
    );
  end component;
  attribute syn_black_box of fdre: component is true;
  attribute fpga_dont_touch of fdre: component is "true";
  component fdse
    port (
      q: out std_ulogic;
      d: in  std_ulogic;
      c: in  std_ulogic;
      ce: in  std_ulogic;
      s: in  std_ulogic
    );
  end component;
  attribute syn_black_box of fdse: component is true;
  attribute fpga_dont_touch of fdse: component is "true";
  constant init_const: std_logic_vector(width - 1 downto 0)
    := build_init_const(width, init_index, init_value);
begin
  fd_prim_array: for index in 0 to width - 1 generate
    bit_is_0: if (init_const(index) = '0') generate
      fdre_comp: fdre
        port map (
          c => clk,
          d => i(index),
          q => o(index),
          ce => ce,
          r => clr
        );
    end generate;
    bit_is_1: if (init_const(index) = '1') generate
      fdse_comp: fdse
        port map (
          c => clk,
          d => i(index),
          q => o(index),
          ce => ce,
          s => clr
        );
    end generate;
  end generate;
end architecture structural;
-- synopsys translate_off
library unisim;
use unisim.vcomponents.all;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity synth_reg_w_init is
  generic (
    width: integer := 8;
    init_index: integer := 0;
    init_value: bit_vector := b"0000";
    latency: integer := 1
  );
  port (
    i: in std_logic_vector(width - 1 downto 0);
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    o: out std_logic_vector(width - 1 downto 0)
  );
end synth_reg_w_init;
architecture structural of synth_reg_w_init is
  component single_reg_w_init
    generic (
      width: integer := 8;
      init_index: integer := 0;
      init_value: bit_vector := b"0000"
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  signal dly_i: std_logic_vector((latency + 1) * width - 1 downto 0);
  signal dly_clr: std_logic;
begin
  latency_eq_0: if (latency = 0) generate
    o <= i;
  end generate;
  latency_gt_0: if (latency >= 1) generate
    dly_i((latency + 1) * width - 1 downto latency * width) <= i
      after 200 ps;
    dly_clr <= clr after 200 ps;
    fd_array: for index in latency downto 1 generate
       reg_comp: single_reg_w_init
          generic map (
            width => width,
            init_index => init_index,
            init_value => init_value
          )
          port map (
            clk => clk,
            i => dly_i((index + 1) * width - 1 downto index * width),
            o => dly_i(index * width - 1 downto (index - 1) * width),
            ce => ce,
            clr => dly_clr
          );
    end generate;
    o <= dly_i(width - 1 downto 0);
  end generate;
end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_c13097e33e is
  port (
    a : in std_logic_vector((1 - 1) downto 0);
    b : in std_logic_vector((1 - 1) downto 0);
    s : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_c13097e33e;


architecture behavior of addsub_c13097e33e is
  signal a_17_32: unsigned((1 - 1) downto 0);
  signal b_17_35: unsigned((1 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0");
  signal op_mem_91_20_front_din: unsigned((1 - 1) downto 0);
  signal op_mem_91_20_back: unsigned((1 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((3 - 1) downto 0);
  signal cast_71_22: signed((3 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((3 - 1) downto 0);
  signal cast_internal_s_83_3_convert: unsigned((1 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_unsigned(a);
  b_17_35 <= std_logic_vector_to_unsigned(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= u2s_cast(a_17_32, 0, 3, 0);
  cast_71_22 <= u2s_cast(b_17_35, 0, 3, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2u_cast(internal_s_71_5_addsub, 0, 1, 0);
  op_mem_91_20_push_front_pop_back_en <= '0';
  cout_mem_92_22_push_front_pop_back_en <= '0';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= unsigned_to_std_logic_vector(cast_internal_s_83_3_convert);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_1d98d96b58 is
  port (
    in0 : in std_logic_vector((9 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_1d98d96b58;


architecture behavior of concat_1d98d96b58 is
  signal in0_1_23: unsigned((9 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((10 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_963ed6358a is
  port (
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_963ed6358a;


architecture behavior of constant_963ed6358a is
begin
  op <= "0";
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity convert_func_call is
    generic (
        din_width    : integer := 16;
        din_bin_pt   : integer := 4;
        din_arith    : integer := xlUnsigned;
        dout_width   : integer := 8;
        dout_bin_pt  : integer := 2;
        dout_arith   : integer := xlUnsigned;
        quantization : integer := xlTruncate;
        overflow     : integer := xlWrap);
    port (
        din : in std_logic_vector (din_width-1 downto 0);
        result : out std_logic_vector (dout_width-1 downto 0));
end convert_func_call;
architecture behavior of convert_func_call is
begin
    result <= convert_type(din, din_width, din_bin_pt, din_arith,
                           dout_width, dout_bin_pt, dout_arith,
                           quantization, overflow);
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlconvert is
    generic (
        din_width    : integer := 16;
        din_bin_pt   : integer := 4;
        din_arith    : integer := xlUnsigned;
        dout_width   : integer := 8;
        dout_bin_pt  : integer := 2;
        dout_arith   : integer := xlUnsigned;
        en_width     : integer := 1;
        en_bin_pt    : integer := 0;
        en_arith     : integer := xlUnsigned;
        bool_conversion : integer :=0;
        latency      : integer := 0;
        quantization : integer := xlTruncate;
        overflow     : integer := xlWrap);
    port (
        din : in std_logic_vector (din_width-1 downto 0);
        en  : in std_logic_vector (en_width-1 downto 0);
        ce  : in std_logic;
        clr : in std_logic;
        clk : in std_logic;
        dout : out std_logic_vector (dout_width-1 downto 0));
end xlconvert;
architecture behavior of xlconvert is
    component synth_reg
        generic (width       : integer;
                 latency     : integer);
        port (i       : in std_logic_vector(width-1 downto 0);
              ce      : in std_logic;
              clr     : in std_logic;
              clk     : in std_logic;
              o       : out std_logic_vector(width-1 downto 0));
    end component;
    component convert_func_call
        generic (
            din_width    : integer := 16;
            din_bin_pt   : integer := 4;
            din_arith    : integer := xlUnsigned;
            dout_width   : integer := 8;
            dout_bin_pt  : integer := 2;
            dout_arith   : integer := xlUnsigned;
            quantization : integer := xlTruncate;
            overflow     : integer := xlWrap);
        port (
            din : in std_logic_vector (din_width-1 downto 0);
            result : out std_logic_vector (dout_width-1 downto 0));
    end component;
    -- synopsys translate_off
    -- synopsys translate_on
    signal result : std_logic_vector(dout_width-1 downto 0);
    signal internal_ce : std_logic;
begin
    -- synopsys translate_off
    -- synopsys translate_on
    internal_ce <= ce and en(0);

    bool_conversion_generate : if (bool_conversion = 1)
    generate
      result <= din;
    end generate;
    std_conversion_generate : if (bool_conversion = 0)
    generate
      convert : convert_func_call
        generic map (
          din_width   => din_width,
          din_bin_pt  => din_bin_pt,
          din_arith   => din_arith,
          dout_width  => dout_width,
          dout_bin_pt => dout_bin_pt,
          dout_arith  => dout_arith,
          quantization => quantization,
          overflow     => overflow)
        port map (
          din => din,
          result => result);
    end generate;
    latency_test : if (latency > 0) generate
        reg : synth_reg
            generic map (
              width => dout_width,
              latency => latency
            )
            port map (
              i => result,
              ce => internal_ce,
              clr => clr,
              clk => clk,
              o => dout
            );
    end generate;
    latency0 : if (latency = 0)
    generate
        dout <= result;
    end generate latency0;
end  behavior;

-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xlslice is
    generic (
        new_msb      : integer := 9;
        new_lsb      : integer := 1;
        x_width      : integer := 16;
        y_width      : integer := 8);
    port (
        x : in std_logic_vector (x_width-1 downto 0);
        y : out std_logic_vector (y_width-1 downto 0));
end xlslice;
architecture behavior of xlslice is
begin
    y <= x(new_msb downto new_lsb);
end  behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_4fe5face7f is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((10 - 1) downto 0);
    d1 : in std_logic_vector((10 - 1) downto 0);
    y : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_4fe5face7f;


architecture behavior of mux_4fe5face7f is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((10 - 1) downto 0);
  signal d1_1_27: std_logic_vector((10 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((10 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  y <= unregy_join_6_1;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_ddc3ebdd7c is
  port (
    input_port : in std_logic_vector((16 - 1) downto 0);
    output_port : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_ddc3ebdd7c;


architecture behavior of reinterpret_ddc3ebdd7c is
  signal input_port_1_40: unsigned((16 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_dc139e7f7a is
  port (
    input_port : in std_logic_vector((32 - 1) downto 0);
    output_port : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_dc139e7f7a;


architecture behavior of reinterpret_dc139e7f7a is
  signal input_port_1_40: unsigned((32 - 1) downto 0);
  signal output_port_5_5_force: signed((32 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_9f5572ba51 is
  port (
    op : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_9f5572ba51;


architecture behavior of constant_9f5572ba51 is
begin
  op <= "0000000000000000";
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xlmult_window_and_fft_test_v4 is
  generic (
    core_name0: string := "";
    a_width: integer := 4;
    a_bin_pt: integer := 2;
    a_arith: integer := xlSigned;
    b_width: integer := 4;
    b_bin_pt: integer := 1;
    b_arith: integer := xlSigned;
    p_width: integer := 8;
    p_bin_pt: integer := 2;
    p_arith: integer := xlSigned;
    rst_width: integer := 1;
    rst_bin_pt: integer := 0;
    rst_arith: integer := xlUnsigned;
    en_width: integer := 1;
    en_bin_pt: integer := 0;
    en_arith: integer := xlUnsigned;
    quantization: integer := xlTruncate;
    overflow: integer := xlWrap;
    extra_registers: integer := 0;
    c_a_width: integer := 7;
    c_b_width: integer := 7;
    c_type: integer := 0;
    c_a_type: integer := 0;
    c_b_type: integer := 0;
    c_pipelined: integer := 1;
    c_baat: integer := 4;
    multsign: integer := xlSigned;
    c_output_width: integer := 16
  );
  port (
    a: in std_logic_vector(a_width - 1 downto 0);
    b: in std_logic_vector(b_width - 1 downto 0);
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    core_ce: in std_logic := '0';
    core_clr: in std_logic := '0';
    core_clk: in std_logic := '0';
    rst: in std_logic_vector(rst_width - 1 downto 0);
    en: in std_logic_vector(en_width - 1 downto 0);
    p: out std_logic_vector(p_width - 1 downto 0)
  );
end xlmult_window_and_fft_test_v4;
architecture behavior of xlmult_window_and_fft_test_v4 is
  component synth_reg
    generic (
      width: integer := 16;
      latency: integer := 5
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  component mult_11_2_7f50ff10654d69e4
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of mult_11_2_7f50ff10654d69e4:
    component is true;
  attribute fpga_dont_touch of mult_11_2_7f50ff10654d69e4:
    component is "true";
  attribute box_type of mult_11_2_7f50ff10654d69e4:
    component  is "black_box";
  component mult_11_2_ecdcb40ad0958e64
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of mult_11_2_ecdcb40ad0958e64:
    component is true;
  attribute fpga_dont_touch of mult_11_2_ecdcb40ad0958e64:
    component is "true";
  attribute box_type of mult_11_2_ecdcb40ad0958e64:
    component  is "black_box";
  signal tmp_a: std_logic_vector(c_a_width - 1 downto 0);
  signal conv_a: std_logic_vector(c_a_width - 1 downto 0);
  signal tmp_b: std_logic_vector(c_b_width - 1 downto 0);
  signal conv_b: std_logic_vector(c_b_width - 1 downto 0);
  signal tmp_p: std_logic_vector(c_output_width - 1 downto 0);
  signal conv_p: std_logic_vector(p_width - 1 downto 0);
  -- synopsys translate_off
  signal real_a, real_b, real_p: real;
  -- synopsys translate_on
  signal rfd: std_logic;
  signal rdy: std_logic;
  signal nd: std_logic;
  signal internal_ce: std_logic;
  signal internal_clr: std_logic;
  signal internal_core_ce: std_logic;
begin
-- synopsys translate_off
-- synopsys translate_on
  internal_ce <= ce and en(0);
  internal_core_ce <= core_ce and en(0);
  internal_clr <= (clr or rst(0)) and ce;
  nd <= internal_ce;
  input_process:  process (a,b)
  begin
    tmp_a <= zero_ext(a, c_a_width);
    tmp_b <= zero_ext(b, c_b_width);
  end process;
  output_process: process (tmp_p)
  begin
    conv_p <= convert_type(tmp_p, c_output_width, a_bin_pt+b_bin_pt, multsign,
                           p_width, p_bin_pt, p_arith, quantization, overflow);
  end process;
  comp0: if ((core_name0 = "mult_11_2_7f50ff10654d69e4")) generate
    core_instance0: mult_11_2_7f50ff10654d69e4
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp1: if ((core_name0 = "mult_11_2_ecdcb40ad0958e64")) generate
    core_instance1: mult_11_2_ecdcb40ad0958e64
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  latency_gt_0: if (extra_registers > 0) generate
    reg: synth_reg
      generic map (
        width => p_width,
        latency => extra_registers
      )
      port map (
        i => conv_p,
        ce => internal_ce,
        clr => internal_clr,
        clk => clk,
        o => p
      );
  end generate;
  latency_eq_0: if (extra_registers = 0) generate
    p <= conv_p;
  end generate;
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_ebec135d8a is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_ebec135d8a;


architecture behavior of delay_ebec135d8a is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "00000000");
  signal op_mem_20_24_front_din: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_672d2b8d1e is
  port (
    d : in std_logic_vector((32 - 1) downto 0);
    q : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_672d2b8d1e;


architecture behavior of delay_672d2b8d1e is
  signal d_1_22: std_logic_vector((32 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "00000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_4246ea65a9 is
  port (
    d : in std_logic_vector((16 - 1) downto 0);
    q : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_4246ea65a9;


architecture behavior of delay_4246ea65a9 is
  signal d_1_22: std_logic_vector((16 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((16 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "0000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((16 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((16 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_83e473517e is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((7 - 1) downto 0);
    y : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_83e473517e;


architecture behavior of concat_83e473517e is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((7 - 1) downto 0);
  signal y_2_1_concat: unsigned((8 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity inverter_e2b989a05e is
  port (
    ip : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end inverter_e2b989a05e;


architecture behavior of inverter_e2b989a05e is
  signal ip_1_26: unsigned((1 - 1) downto 0);
  type array_type_op_mem_22_20 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal op_mem_22_20: array_type_op_mem_22_20 := (
    0 => "0");
  signal op_mem_22_20_front_din: unsigned((1 - 1) downto 0);
  signal op_mem_22_20_back: unsigned((1 - 1) downto 0);
  signal op_mem_22_20_push_front_pop_back_en: std_logic;
  signal internal_ip_12_1_bitnot: unsigned((1 - 1) downto 0);
begin
  ip_1_26 <= std_logic_vector_to_unsigned(ip);
  op_mem_22_20_back <= op_mem_22_20(0);
  proc_op_mem_22_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_22_20_push_front_pop_back_en = '1')) then
        op_mem_22_20(0) <= op_mem_22_20_front_din;
      end if;
    end if;
  end process proc_op_mem_22_20;
  internal_ip_12_1_bitnot <= std_logic_vector_to_unsigned(not unsigned_to_std_logic_vector(ip_1_26));
  op_mem_22_20_push_front_pop_back_en <= '0';
  op <= unsigned_to_std_logic_vector(internal_ip_12_1_bitnot);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_4389dc89bf is
  port (
    input_port : in std_logic_vector((8 - 1) downto 0);
    output_port : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_4389dc89bf;


architecture behavior of reinterpret_4389dc89bf is
  signal input_port_1_40: unsigned((8 - 1) downto 0);
  signal output_port_5_5_force: signed((8 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_2b0feb00fb is
  port (
    d : in std_logic_vector((32 - 1) downto 0);
    q : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_2b0feb00fb;


architecture behavior of delay_2b0feb00fb is
  signal d_1_22: std_logic_vector((32 - 1) downto 0);
begin
  d_1_22 <= d;
  q <= d_1_22;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_6b1adb5d55 is
  port (
    input_port : in std_logic_vector((11 - 1) downto 0);
    output_port : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_6b1adb5d55;


architecture behavior of reinterpret_6b1adb5d55 is
  signal input_port_1_40: unsigned((11 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_151459306d is
  port (
    input_port : in std_logic_vector((16 - 1) downto 0);
    output_port : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_151459306d;


architecture behavior of reinterpret_151459306d is
  signal input_port_1_40: unsigned((16 - 1) downto 0);
  signal output_port_5_5_force: signed((16 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity convert_pipeline is
    generic (
        old_width   : integer := 16;
        old_bin_pt  : integer := 4;
        old_arith   : integer := xlUnsigned;
        new_width   : integer := 8;
        new_bin_pt  : integer := 2;
        new_arith   : integer := xlUnsigned;
        en_width    : integer := 1;
        en_bin_pt   : integer := 0;
        en_arith    : integer := xlUnsigned;
        quantization : integer := xlTruncate;
        overflow    : integer := xlWrap;
        latency     : integer := 1);
    port (
        din : in std_logic_vector (old_width-1 downto 0);
        en  : in std_logic_vector (en_width-1 downto 0);
        ce  : in std_logic;
        clr : in std_logic;
        clk : in std_logic;
        result : out std_logic_vector (new_width-1 downto 0));
end convert_pipeline;
architecture behavior of convert_pipeline is
    component synth_reg
        generic (width       : integer;
                 latency     : integer);
        port (i           : in std_logic_vector(width-1 downto 0);
              ce      : in std_logic;
              clr     : in std_logic;
              clk     : in std_logic;
              o       : out std_logic_vector(width-1 downto 0));
    end component;
    constant fp_width : integer := old_width + 2;
    constant fp_bin_pt : integer := old_bin_pt;
    constant fp_arith : integer := old_arith;
    constant q_width : integer := (old_width + 2) + (new_bin_pt - old_bin_pt);
    constant q_bin_pt : integer := new_bin_pt;
    constant q_arith : integer := old_arith;
    signal full_precision_result_in, full_precision_result_out
        : std_logic_vector(fp_width-1 downto 0);
    signal quantized_result_in, quantized_result_out
        : std_logic_vector(q_width-1 downto 0);
    signal result_in : std_logic_vector(new_width-1 downto 0):= (others => '0');
    signal internal_ce : std_logic;
begin
    internal_ce <= ce and en(0);

    fp_result : process (din)
    begin
        full_precision_result_in <= cast(din, old_bin_pt,
                                         fp_width, fp_bin_pt, fp_arith);
    end process;
    latency_fpr : if (latency > 2)
    generate
        reg_fpr : synth_reg
            generic map ( width => fp_width,
                          latency => 1)
            port map (i => full_precision_result_in,
                      ce => internal_ce,
                      clr => clr,
                      clk => clk,
                      o => full_precision_result_out);
    end generate;
    no_latency_fpr : if (latency < 3)
    generate
        full_precision_result_out <= full_precision_result_in;
    end generate;
    xlround_generate : if (quantization = xlRound)
    generate
      xlround_result : process (full_precision_result_out)
      begin
          quantized_result_in <= round_towards_inf(full_precision_result_out,
                                                   fp_width, fp_bin_pt,
                                                   fp_arith, q_width, q_bin_pt,
                                                   q_arith);
      end process;
    end generate;
    xlroundbanker_generate : if (quantization = xlRoundBanker)
    generate
      xlroundbanker_result : process (full_precision_result_out)
      begin
          quantized_result_in <= round_towards_even(full_precision_result_out,
                                                   fp_width, fp_bin_pt,
                                                   fp_arith, q_width, q_bin_pt,
                                                   q_arith);
      end process;
    end generate;
    xltruncate_generate : if (quantization = xlTruncate)
    generate
      xltruncate_result : process (full_precision_result_out)
      begin
          quantized_result_in <= trunc(full_precision_result_out,
                                       fp_width, fp_bin_pt,
                                       fp_arith, q_width, q_bin_pt,
                                       q_arith);
      end process;
    end generate;
    latency_qr : if (latency > 1)
    generate
        reg_qr : synth_reg
            generic map ( width => q_width,
                          latency => 1)
            port map (i => quantized_result_in,
                      ce => internal_ce,
                      clr => clr,
                      clk => clk,
                      o => quantized_result_out);
    end generate;
    no_latency_qr : if (latency < 2)
    generate
        quantized_result_out <= quantized_result_in;
    end generate;
    xlsaturate_generate : if (overflow = xlSaturate)
    generate
      xlsaturate_result : process (quantized_result_out)
      begin
          result_in <= saturation_arith(quantized_result_out, q_width, q_bin_pt,
                                       q_arith, new_width, new_bin_pt, new_arith);
      end process;
    end generate;
    xlwrap_generate : if (overflow = xlWrap)
    generate
      xlwrap_result : process (quantized_result_out)
      begin
          result_in <= wrap_arith(quantized_result_out, q_width, q_bin_pt,
                                  q_arith, new_width, new_bin_pt, new_arith);
      end process;
    end generate;
    latency_gt_3 : if (latency > 3)
    generate
        reg_out : synth_reg
            generic map ( width => new_width,
                          latency => latency-2)
            port map (i => result_in,
                      ce => internal_ce,
                      clr => clr,
                      clk => clk,
                      o => result);
    end generate;
    latency_lt_4 : if ((latency < 4) and (latency > 0))
    generate
        reg_out : synth_reg
            generic map ( width => new_width,
                          latency => 1)
            port map (i => result_in,
                      ce => internal_ce,
                      clr => clr,
                      clk => clk,
                      o => result);
    end generate;
    latency0 : if (latency = 0)
    generate
        result <= result_in;
    end generate latency0;
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlconvert_pipeline is
    generic (
        din_width    : integer := 16;
        din_bin_pt   : integer := 4;
        din_arith    : integer := xlUnsigned;
        dout_width   : integer := 8;
        dout_bin_pt  : integer := 2;
        dout_arith   : integer := xlUnsigned;
        en_width     : integer := 1;
        en_bin_pt    : integer := 0;
        en_arith     : integer := xlUnsigned;
        bool_conversion : integer :=0;
        latency      : integer := 0;
        quantization : integer := xlTruncate;
        overflow     : integer := xlWrap);
    port (
        din  : in std_logic_vector (din_width-1 downto 0);
        en   : in std_logic_vector (en_width-1 downto 0);
        ce   : in std_logic;
        clr  : in std_logic;
        clk  : in std_logic;
        dout : out std_logic_vector (dout_width-1 downto 0));
end xlconvert_pipeline;
architecture behavior of xlconvert_pipeline is
    component convert_pipeline
        generic (
            old_width    : integer := 16;
            old_bin_pt   : integer := 4;
            old_arith    : integer := xlUnsigned;
            new_width    : integer := 8;
            new_bin_pt   : integer := 2;
            new_arith    : integer := xlUnsigned;
            en_width     : integer := 1;
            en_bin_pt    : integer := 0;
            en_arith     : integer := xlUnsigned;
            quantization : integer := xlTruncate;
            overflow     : integer := xlWrap;
            latency      : integer := 1);
        port (
            din    : in std_logic_vector (din_width-1 downto 0);
            en     : in std_logic_vector (en_width-1 downto 0);
            ce     : in std_logic;
            clr    : in std_logic;
            clk    : in std_logic;
            result : out std_logic_vector (dout_width-1 downto 0));
    end component;
   begin
      convert : convert_pipeline
        generic map (
          old_width   => din_width,
          old_bin_pt  => din_bin_pt,
          old_arith   => din_arith,
          new_width   => dout_width,
          new_bin_pt  => dout_bin_pt,
          new_arith   => dout_arith,
          en_width    => en_width,
          en_bin_pt   => en_bin_pt,
          en_arith    => en_arith,
          quantization => quantization,
          overflow    => overflow,
          latency     => latency)
        port map (
          din => din,
          en => en,
          ce => ce,
          clr => clr,
          clk => clk,
          result => dout);
end  behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_38dd6afab7 is
  port (
    a : in std_logic_vector((42 - 1) downto 0);
    b : in std_logic_vector((42 - 1) downto 0);
    s : out std_logic_vector((43 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_38dd6afab7;


architecture behavior of addsub_38dd6afab7 is
  signal a_17_32: signed((42 - 1) downto 0);
  signal b_17_35: signed((42 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((43 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000000000000000000000000000000");
  signal op_mem_91_20_front_din: signed((43 - 1) downto 0);
  signal op_mem_91_20_back: signed((43 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((43 - 1) downto 0);
  signal cast_69_22: signed((43 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((43 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 39, 43, 39);
  cast_69_22 <= s2s_cast(b_17_35, 39, 43, 39);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xladdsub_window_and_fft_test_v4 is
  generic (
    core_name0: string := "";
    a_width: integer := 16;
    a_bin_pt: integer := 4;
    a_arith: integer := xlUnsigned;
    c_in_width: integer := 16;
    c_in_bin_pt: integer := 4;
    c_in_arith: integer := xlUnsigned;
    c_out_width: integer := 16;
    c_out_bin_pt: integer := 4;
    c_out_arith: integer := xlUnsigned;
    b_width: integer := 8;
    b_bin_pt: integer := 2;
    b_arith: integer := xlUnsigned;
    s_width: integer := 17;
    s_bin_pt: integer := 4;
    s_arith: integer := xlUnsigned;
    rst_width: integer := 1;
    rst_bin_pt: integer := 0;
    rst_arith: integer := xlUnsigned;
    en_width: integer := 1;
    en_bin_pt: integer := 0;
    en_arith: integer := xlUnsigned;
    full_s_width: integer := 17;
    full_s_arith: integer := xlUnsigned;
    mode: integer := xlAddMode;
    extra_registers: integer := 0;
    latency: integer := 0;
    quantization: integer := xlTruncate;
    overflow: integer := xlWrap;
    c_latency: integer := 0;
    c_output_width: integer := 17;
    c_has_c_in : integer := 0;
    c_has_c_out : integer := 0
  );
  port (
    a: in std_logic_vector(a_width - 1 downto 0);
    b: in std_logic_vector(b_width - 1 downto 0);
    c_in : in std_logic_vector (0 downto 0) := "0";
    ce: in std_logic;
    clr: in std_logic := '0';
    clk: in std_logic;
    rst: in std_logic_vector(rst_width - 1 downto 0) := "0";
    en: in std_logic_vector(en_width - 1 downto 0) := "1";
    c_out : out std_logic_vector (0 downto 0);
    s: out std_logic_vector(s_width - 1 downto 0)
  );
end xladdsub_window_and_fft_test_v4;
architecture behavior of xladdsub_window_and_fft_test_v4 is
  component synth_reg
    generic (
      width: integer := 16;
      latency: integer := 5
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  function format_input(inp: std_logic_vector; old_width, delta, new_arith,
                        new_width: integer)
    return std_logic_vector
  is
    variable vec: std_logic_vector(old_width-1 downto 0);
    variable padded_inp: std_logic_vector((old_width + delta)-1  downto 0);
    variable result: std_logic_vector(new_width-1 downto 0);
  begin
    vec := inp;
    if (delta > 0) then
      padded_inp := pad_LSB(vec, old_width+delta);
      result := extend_MSB(padded_inp, new_width, new_arith);
    else
      result := extend_MSB(vec, new_width, new_arith);
    end if;
    return result;
  end;
  constant full_s_bin_pt: integer := fractional_bits(a_bin_pt, b_bin_pt);
  constant full_a_width: integer := full_s_width;
  constant full_b_width: integer := full_s_width;
  signal full_a: std_logic_vector(full_a_width - 1 downto 0);
  signal full_b: std_logic_vector(full_b_width - 1 downto 0);
  signal core_s: std_logic_vector(full_s_width - 1 downto 0);
  signal conv_s: std_logic_vector(s_width - 1 downto 0);
  signal temp_cout : std_logic;
  signal internal_clr: std_logic;
  signal internal_ce: std_logic;
  signal extra_reg_ce: std_logic;
  signal override: std_logic;
  signal logic1: std_logic_vector(0 downto 0);
  component addsb_11_0_eef67c1cc12cdbba
    port (
          a: in std_logic_vector(44 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(44 - 1 downto 0)
    );
  end component;
  component addsb_11_0_41035397f321bdbe
    port (
          a: in std_logic_vector(45 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(45 - 1 downto 0)
    );
  end component;
  component addsb_11_0_8610f827d96057ce
    port (
          a: in std_logic_vector(19 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(19 - 1 downto 0)
    );
  end component;
  component addsb_11_0_1c3c830b668bf9ed
    port (
          a: in std_logic_vector(21 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(21 - 1 downto 0)
    );
  end component;
  component addsb_11_0_88a3fd223f485e8a
    port (
          a: in std_logic_vector(19 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(19 - 1 downto 0)
    );
  end component;
  component addsb_11_0_d11668e2ba580388
    port (
          a: in std_logic_vector(22 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(22 - 1 downto 0)
    );
  end component;
  component addsb_11_0_5b4a22e47f2359ce
    port (
          a: in std_logic_vector(21 - 1 downto 0);
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(21 - 1 downto 0)
    );
  end component;
  component addsb_11_0_6c65a885198b42c3
    port (
          a: in std_logic_vector(23 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(23 - 1 downto 0)
    );
  end component;
  component addsb_11_0_3892e7a2bbe55936
    port (
          a: in std_logic_vector(22 - 1 downto 0);
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(22 - 1 downto 0)
    );
  end component;
  component addsb_11_0_259024b6977697b1
    port (
          a: in std_logic_vector(39 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(39 - 1 downto 0)
    );
  end component;
  component addsb_11_0_6a49eeb869ee9525
    port (
          a: in std_logic_vector(3 - 1 downto 0);
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(3 - 1 downto 0)
    );
  end component;
  component addsb_11_0_325ab3980d59a98e
    port (
          a: in std_logic_vector(27 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(27 - 1 downto 0)
    );
  end component;
begin
  internal_clr <= (clr or (rst(0))) and ce;
  internal_ce <= ce and en(0);
  logic1(0) <= '1';
  addsub_process: process (a, b, core_s)
  begin
    full_a <= format_input (a, a_width, b_bin_pt - a_bin_pt, a_arith,
                            full_a_width);
    full_b <= format_input (b, b_width, a_bin_pt - b_bin_pt, b_arith,
                            full_b_width);
    conv_s <= convert_type (core_s, full_s_width, full_s_bin_pt, full_s_arith,
                            s_width, s_bin_pt, s_arith, quantization, overflow);
  end process addsub_process;

  comp0: if ((core_name0 = "addsb_11_0_eef67c1cc12cdbba")) generate
    core_instance0: addsb_11_0_eef67c1cc12cdbba
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp1: if ((core_name0 = "addsb_11_0_41035397f321bdbe")) generate
    core_instance1: addsb_11_0_41035397f321bdbe
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp2: if ((core_name0 = "addsb_11_0_8610f827d96057ce")) generate
    core_instance2: addsb_11_0_8610f827d96057ce
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp3: if ((core_name0 = "addsb_11_0_1c3c830b668bf9ed")) generate
    core_instance3: addsb_11_0_1c3c830b668bf9ed
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp4: if ((core_name0 = "addsb_11_0_88a3fd223f485e8a")) generate
    core_instance4: addsb_11_0_88a3fd223f485e8a
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp5: if ((core_name0 = "addsb_11_0_d11668e2ba580388")) generate
    core_instance5: addsb_11_0_d11668e2ba580388
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp6: if ((core_name0 = "addsb_11_0_5b4a22e47f2359ce")) generate
    core_instance6: addsb_11_0_5b4a22e47f2359ce
      port map (
         a => full_a,
         s => core_s,
         b => full_b
      );
  end generate;
  comp7: if ((core_name0 = "addsb_11_0_6c65a885198b42c3")) generate
    core_instance7: addsb_11_0_6c65a885198b42c3
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp8: if ((core_name0 = "addsb_11_0_3892e7a2bbe55936")) generate
    core_instance8: addsb_11_0_3892e7a2bbe55936
      port map (
         a => full_a,
         s => core_s,
         b => full_b
      );
  end generate;
  comp9: if ((core_name0 = "addsb_11_0_259024b6977697b1")) generate
    core_instance9: addsb_11_0_259024b6977697b1
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp10: if ((core_name0 = "addsb_11_0_6a49eeb869ee9525")) generate
    core_instance10: addsb_11_0_6a49eeb869ee9525
      port map (
         a => full_a,
         s => core_s,
         b => full_b
      );
  end generate;
  comp11: if ((core_name0 = "addsb_11_0_325ab3980d59a98e")) generate
    core_instance11: addsb_11_0_325ab3980d59a98e
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  latency_test: if (extra_registers > 0) generate
      override_test: if (c_latency > 1) generate
       override_pipe: synth_reg
          generic map (
            width => 1,
            latency => c_latency
          )
          port map (
            i => logic1,
            ce => internal_ce,
            clr => internal_clr,
            clk => clk,
            o(0) => override);
       extra_reg_ce <= ce and en(0) and override;
      end generate override_test;
      no_override: if ((c_latency = 0) or (c_latency = 1)) generate
       extra_reg_ce <= ce and en(0);
      end generate no_override;
      extra_reg: synth_reg
        generic map (
          width => s_width,
          latency => extra_registers
        )
        port map (
          i => conv_s,
          ce => extra_reg_ce,
          clr => internal_clr,
          clk => clk,
          o => s
        );
      cout_test: if (c_has_c_out = 1) generate
      c_out_extra_reg: synth_reg
        generic map (
          width => 1,
          latency => extra_registers
        )
        port map (
          i(0) => temp_cout,
          ce => extra_reg_ce,
          clr => internal_clr,
          clk => clk,
          o => c_out
        );
      end generate cout_test;
  end generate;
  latency_s: if ((latency = 0) or (extra_registers = 0)) generate
    s <= conv_s;
  end generate latency_s;
  latency0: if (((latency = 0) or (extra_registers = 0)) and
                 (c_has_c_out = 1)) generate
    c_out(0) <= temp_cout;
  end generate latency0;
  tie_dangling_cout: if (c_has_c_out = 0) generate
    c_out <= "0";
  end generate tie_dangling_cout;
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_24e94e69df is
  port (
    a : in std_logic_vector((16 - 1) downto 0);
    b : in std_logic_vector((16 - 1) downto 0);
    s : out std_logic_vector((17 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_24e94e69df;


architecture behavior of addsub_24e94e69df is
  signal a_17_32: signed((16 - 1) downto 0);
  signal b_17_35: signed((16 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((17 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000000");
  signal op_mem_91_20_front_din: signed((17 - 1) downto 0);
  signal op_mem_91_20_back: signed((17 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((17 - 1) downto 0);
  signal cast_69_22: signed((17 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((17 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 15, 17, 15);
  cast_69_22 <= s2s_cast(b_17_35, 15, 17, 15);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mult_931970af87 is
  port (
    a : in std_logic_vector((25 - 1) downto 0);
    b : in std_logic_vector((17 - 1) downto 0);
    p : out std_logic_vector((42 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mult_931970af87;


architecture behavior of mult_931970af87 is
  signal a_1_22: signed((25 - 1) downto 0);
  signal b_1_25: signed((17 - 1) downto 0);
  type array_type_op_mem_65_20 is array (0 to (2 - 1)) of signed((42 - 1) downto 0);
  signal op_mem_65_20: array_type_op_mem_65_20 := (
    "000000000000000000000000000000000000000000",
    "000000000000000000000000000000000000000000");
  signal op_mem_65_20_front_din: signed((42 - 1) downto 0);
  signal op_mem_65_20_back: signed((42 - 1) downto 0);
  signal op_mem_65_20_push_front_pop_back_en: std_logic;
  signal mult_46_56: signed((42 - 1) downto 0);
begin
  a_1_22 <= std_logic_vector_to_signed(a);
  b_1_25 <= std_logic_vector_to_signed(b);
  op_mem_65_20_back <= op_mem_65_20(1);
  proc_op_mem_65_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_65_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_65_20(i) <= op_mem_65_20(i-1);
        end loop;
        op_mem_65_20(0) <= op_mem_65_20_front_din;
      end if;
    end if;
  end process proc_op_mem_65_20;
  mult_46_56 <= (a_1_22 * b_1_25);
  op_mem_65_20_front_din <= mult_46_56;
  op_mem_65_20_push_front_pop_back_en <= '1';
  p <= signed_to_std_logic_vector(op_mem_65_20_back);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlregister is
   generic (d_width          : integer := 5;
            init_value       : bit_vector := b"00");
   port (d   : in std_logic_vector (d_width-1 downto 0);
         rst : in std_logic_vector(0 downto 0) := "0";
         en  : in std_logic_vector(0 downto 0) := "1";
         ce  : in std_logic;
         clk : in std_logic;
         q   : out std_logic_vector (d_width-1 downto 0));
end xlregister;
architecture behavior of xlregister is
   component synth_reg_w_init
      generic (width      : integer;
               init_index : integer;
               init_value : bit_vector;
               latency    : integer);
      port (i   : in std_logic_vector(width-1 downto 0);
            ce  : in std_logic;
            clr : in std_logic;
            clk : in std_logic;
            o   : out std_logic_vector(width-1 downto 0));
   end component;
   -- synopsys translate_off
   signal real_d, real_q           : real;
   -- synopsys translate_on
   signal internal_clr             : std_logic;
   signal internal_ce              : std_logic;
begin
   internal_clr <= rst(0) and ce;
   internal_ce  <= en(0) and ce;
   synth_reg_inst : synth_reg_w_init
      generic map (width      => d_width,
                   init_index => 2,
                   init_value => init_value,
                   latency    => 1)
      port map (i   => d,
                ce  => internal_ce,
                clr => internal_clr,
                clk => clk,
                o   => q);
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_7b9ebdaf6c is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_7b9ebdaf6c;


architecture behavior of constant_7b9ebdaf6c is
begin
  op <= "0000010010111111111111010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_22835c9c71 is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_22835c9c71;


architecture behavior of constant_22835c9c71 is
begin
  op <= "0000001011111000011100101";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_1ae64facd4 is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_1ae64facd4;


architecture behavior of constant_1ae64facd4 is
begin
  op <= "0000000110010100110100010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_c917c58776 is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_c917c58776;


architecture behavior of constant_c917c58776 is
begin
  op <= "0000000010111000010101001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_33fc251917 is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_33fc251917;


architecture behavior of constant_33fc251917 is
begin
  op <= "0000101011110011101000011";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_fd4ba908f2 is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_fd4ba908f2;


architecture behavior of constant_fd4ba908f2 is
begin
  op <= "0000101000011111101100000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_d404083146 is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_d404083146;


architecture behavior of constant_d404083146 is
begin
  op <= "0000100010100000010001001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_d4afade44e is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_d4afade44e;


architecture behavior of constant_d4afade44e is
begin
  op <= "0000011010111010101011100";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_9f02caa990 is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_9f02caa990;


architecture behavior of delay_9f02caa990 is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_a369e00c6b is
  port (
    in0 : in std_logic_vector((16 - 1) downto 0);
    in1 : in std_logic_vector((16 - 1) downto 0);
    y : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_a369e00c6b;


architecture behavior of concat_a369e00c6b is
  signal in0_1_23: unsigned((16 - 1) downto 0);
  signal in1_1_27: unsigned((16 - 1) downto 0);
  signal y_2_1_concat: unsigned((32 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_7025463ea8 is
  port (
    input_port : in std_logic_vector((16 - 1) downto 0);
    output_port : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_7025463ea8;


architecture behavior of reinterpret_7025463ea8 is
  signal input_port_1_40: signed((16 - 1) downto 0);
  signal output_port_5_5_force: unsigned((16 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xldelay is
   generic(width        : integer := -1;
           latency      : integer := -1;
           reg_retiming : integer :=  0;
           reset        : integer :=  0);
   port(d       : in std_logic_vector (width-1 downto 0);
        ce      : in std_logic;
        clk     : in std_logic;
        en      : in std_logic;
        rst     : in std_logic;
        q       : out std_logic_vector (width-1 downto 0));
end xldelay;
architecture behavior of xldelay is
   component synth_reg
      generic (width       : integer;
               latency     : integer);
      port (i       : in std_logic_vector(width-1 downto 0);
            ce      : in std_logic;
            clr     : in std_logic;
            clk     : in std_logic;
            o       : out std_logic_vector(width-1 downto 0));
   end component;
   component synth_reg_reg
      generic (width       : integer;
               latency     : integer);
      port (i       : in std_logic_vector(width-1 downto 0);
            ce      : in std_logic;
            clr     : in std_logic;
            clk     : in std_logic;
            o       : out std_logic_vector(width-1 downto 0));
   end component;
   signal internal_ce  : std_logic;
begin
   internal_ce  <= ce and en;
   srl_delay: if ((reg_retiming = 0) and (reset = 0)) or (latency < 1) generate
     synth_reg_srl_inst : synth_reg
       generic map (
         width   => width,
         latency => latency)
       port map (
         i   => d,
         ce  => internal_ce,
         clr => '0',
         clk => clk,
         o   => q);
   end generate srl_delay;
   reg_delay: if ((reg_retiming = 1) or (reset = 1)) and (latency >= 1) generate
     synth_reg_reg_inst : synth_reg_reg
       generic map (
         width   => width,
         latency => latency)
       port map (
         i   => d,
         ce  => internal_ce,
         clr => rst,
         clk => clk,
         o   => q);
   end generate reg_delay;
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity shift_92df6a3714 is
  port (
    ip : in std_logic_vector((45 - 1) downto 0);
    op : out std_logic_vector((45 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end shift_92df6a3714;


architecture behavior of shift_92df6a3714 is
  signal ip_1_23: signed((45 - 1) downto 0);
  type array_type_op_mem_46_20 is array (0 to (1 - 1)) of signed((45 - 1) downto 0);
  signal op_mem_46_20: array_type_op_mem_46_20 := (
    0 => "000000000000000000000000000000000000000000000");
  signal op_mem_46_20_front_din: signed((45 - 1) downto 0);
  signal op_mem_46_20_back: signed((45 - 1) downto 0);
  signal op_mem_46_20_push_front_pop_back_en: std_logic;
  signal cast_internal_ip_36_3_convert: signed((45 - 1) downto 0);
begin
  ip_1_23 <= std_logic_vector_to_signed(ip);
  op_mem_46_20_back <= op_mem_46_20(0);
  proc_op_mem_46_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_46_20_push_front_pop_back_en = '1')) then
        op_mem_46_20(0) <= op_mem_46_20_front_din;
      end if;
    end if;
  end process proc_op_mem_46_20;
  cast_internal_ip_36_3_convert <= s2s_cast(ip_1_23, 38, 45, 39);
  op_mem_46_20_push_front_pop_back_en <= '0';
  op <= signed_to_std_logic_vector(cast_internal_ip_36_3_convert);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_62c4475a80 is
  port (
    in0 : in std_logic_vector((32 - 1) downto 0);
    in1 : in std_logic_vector((32 - 1) downto 0);
    y : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_62c4475a80;


architecture behavior of concat_62c4475a80 is
  signal in0_1_23: unsigned((32 - 1) downto 0);
  signal in1_1_27: unsigned((32 - 1) downto 0);
  signal y_2_1_concat: unsigned((64 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_c5d4d59b73 is
  port (
    input_port : in std_logic_vector((32 - 1) downto 0);
    output_port : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_c5d4d59b73;


architecture behavior of reinterpret_c5d4d59b73 is
  signal input_port_1_40: unsigned((32 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_9a13f6a2a0 is
  port (
    input_port : in std_logic_vector((64 - 1) downto 0);
    output_port : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_9a13f6a2a0;


architecture behavior of reinterpret_9a13f6a2a0 is
  signal input_port_1_40: unsigned((64 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_6293007044 is
  port (
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_6293007044;


architecture behavior of constant_6293007044 is
begin
  op <= "1";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_7ac3eb264e is
  port (
    op : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_7ac3eb264e;


architecture behavior of counter_7ac3eb264e is
  signal count_reg_20_23: unsigned((8 - 1) downto 0) := "00000000";
  signal count_reg_20_23_rst: std_logic;
  signal rel_34_8: boolean;
  signal rst_limit_join_34_5: boolean;
  signal bool_44_4: boolean;
  signal rst_limit_join_44_1: boolean;
  signal count_reg_join_44_1: unsigned((9 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
begin
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "00000000";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("00000001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  rel_34_8 <= count_reg_20_23 = std_logic_vector_to_unsigned("11111101");
  proc_if_34_5: process (rel_34_8)
  is
  begin
    if rel_34_8 then
      rst_limit_join_34_5 <= true;
    else 
      rst_limit_join_34_5 <= false;
    end if;
  end process proc_if_34_5;
  bool_44_4 <= false or rst_limit_join_34_5;
  proc_if_44_1: process (bool_44_4, count_reg_20_23, rst_limit_join_34_5)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= rst_limit_join_34_5;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlspram_window_and_fft_test_v4 is
  generic (
    core_name0: string := "";
    c_width: integer := 12;
    c_address_width: integer := 4;
    latency: integer := 1
    );
  port (
    data_in: in std_logic_vector(c_width - 1 downto 0);
    addr: in std_logic_vector(c_address_width - 1 downto 0);
    we: in std_logic_vector(0 downto 0);
    en: in std_logic_vector(0 downto 0);
    rst: in std_logic_vector(0 downto 0);
    ce: in std_logic;
    clk: in std_logic;
    data_out: out std_logic_vector(c_width - 1 downto 0)
  );
end xlspram_window_and_fft_test_v4 ;
architecture behavior of xlspram_window_and_fft_test_v4 is
  component synth_reg
    generic (
      width: integer;
      latency: integer
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  signal core_data_out, dly_data_out: std_logic_vector(c_width - 1 downto 0);
  signal core_we, core_ce, sinit: std_logic;
  component bmg_72_9a187dd9cd5a0cfe
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_9a187dd9cd5a0cfe:
    component is true;
  attribute fpga_dont_touch of bmg_72_9a187dd9cd5a0cfe:
    component is "true";
  attribute box_type of bmg_72_9a187dd9cd5a0cfe:
    component  is "black_box";
  component bmg_72_88a7df48df176590
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_88a7df48df176590:
    component is true;
  attribute fpga_dont_touch of bmg_72_88a7df48df176590:
    component is "true";
  attribute box_type of bmg_72_88a7df48df176590:
    component  is "black_box";
  component bmg_72_d53572f04cfc7154
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_d53572f04cfc7154:
    component is true;
  attribute fpga_dont_touch of bmg_72_d53572f04cfc7154:
    component is "true";
  attribute box_type of bmg_72_d53572f04cfc7154:
    component  is "black_box";
  component bmg_72_25cb9ebb8094dade
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_25cb9ebb8094dade:
    component is true;
  attribute fpga_dont_touch of bmg_72_25cb9ebb8094dade:
    component is "true";
  attribute box_type of bmg_72_25cb9ebb8094dade:
    component  is "black_box";
  component bmg_72_a4cff0d500ff7adb
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_a4cff0d500ff7adb:
    component is true;
  attribute fpga_dont_touch of bmg_72_a4cff0d500ff7adb:
    component is "true";
  attribute box_type of bmg_72_a4cff0d500ff7adb:
    component  is "black_box";
begin
  data_out <= dly_data_out;
  core_we <= we(0);
  core_ce <= ce and en(0);
  sinit <= rst(0) and ce;
  comp0: if ((core_name0 = "bmg_72_9a187dd9cd5a0cfe")) generate
    core_instance0: bmg_72_9a187dd9cd5a0cfe
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp1: if ((core_name0 = "bmg_72_88a7df48df176590")) generate
    core_instance1: bmg_72_88a7df48df176590
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp2: if ((core_name0 = "bmg_72_d53572f04cfc7154")) generate
    core_instance2: bmg_72_d53572f04cfc7154
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp3: if ((core_name0 = "bmg_72_25cb9ebb8094dade")) generate
    core_instance3: bmg_72_25cb9ebb8094dade
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp4: if ((core_name0 = "bmg_72_a4cff0d500ff7adb")) generate
    core_instance4: bmg_72_a4cff0d500ff7adb
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  latency_test: if (latency > 1) generate
    reg: synth_reg
      generic map (
        width => c_width,
        latency => latency - 1
      )
      port map (
        i => core_data_out,
        ce => core_ce,
        clr => '0',
        clk => clk,
        o => dly_data_out
      );
  end generate;
  latency_1: if (latency <= 1) generate
    dly_data_out <= core_data_out;
  end generate;
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_9a0fa0f632 is
  port (
    input_port : in std_logic_vector((18 - 1) downto 0);
    output_port : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_9a0fa0f632;


architecture behavior of reinterpret_9a0fa0f632 is
  signal input_port_1_40: unsigned((18 - 1) downto 0);
  signal output_port_5_5_force: signed((18 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_bc4405cd1e is
  port (
    input_port : in std_logic_vector((19 - 1) downto 0);
    output_port : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_bc4405cd1e;


architecture behavior of reinterpret_bc4405cd1e is
  signal input_port_1_40: signed((19 - 1) downto 0);
  signal output_port_5_5_force: unsigned((19 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_a246e373e7 is
  port (
    in0 : in std_logic_vector((18 - 1) downto 0);
    in1 : in std_logic_vector((18 - 1) downto 0);
    in2 : in std_logic_vector((18 - 1) downto 0);
    in3 : in std_logic_vector((18 - 1) downto 0);
    y : out std_logic_vector((72 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_a246e373e7;


architecture behavior of concat_a246e373e7 is
  signal in0_1_23: unsigned((18 - 1) downto 0);
  signal in1_1_27: unsigned((18 - 1) downto 0);
  signal in2_1_31: unsigned((18 - 1) downto 0);
  signal in3_1_35: unsigned((18 - 1) downto 0);
  signal y_2_1_concat: unsigned((72 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_580feec131 is
  port (
    input_port : in std_logic_vector((18 - 1) downto 0);
    output_port : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_580feec131;


architecture behavior of reinterpret_580feec131 is
  signal input_port_1_40: signed((18 - 1) downto 0);
  signal output_port_5_5_force: unsigned((18 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_504cae28bd is
  port (
    in0 : in std_logic_vector((19 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_504cae28bd;


architecture behavior of concat_504cae28bd is
  signal in0_1_23: unsigned((19 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((20 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_4709ea49b5 is
  port (
    op : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_4709ea49b5;


architecture behavior of constant_4709ea49b5 is
begin
  op <= "0000000000000000001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_f661f8d9b7 is
  port (
    input_port : in std_logic_vector((20 - 1) downto 0);
    output_port : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_f661f8d9b7;


architecture behavior of reinterpret_f661f8d9b7 is
  signal input_port_1_40: unsigned((20 - 1) downto 0);
  signal output_port_5_5_force: signed((20 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_d2180c9169 is
  port (
    input_port : in std_logic_vector((19 - 1) downto 0);
    output_port : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_d2180c9169;


architecture behavior of reinterpret_d2180c9169 is
  signal input_port_1_40: unsigned((19 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_938d99ac11 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_938d99ac11;


architecture behavior of logical_938d99ac11 is
  signal d0_1_24: std_logic_vector((1 - 1) downto 0);
  signal d1_1_27: std_logic_vector((1 - 1) downto 0);
  signal fully_2_1_bit: std_logic_vector((1 - 1) downto 0);
begin
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  fully_2_1_bit <= d0_1_24 and d1_1_27;
  y <= fully_2_1_bit;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_63700884f5 is
  port (
    input_port : in std_logic_vector((19 - 1) downto 0);
    output_port : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_63700884f5;


architecture behavior of reinterpret_63700884f5 is
  signal input_port_1_40: unsigned((19 - 1) downto 0);
  signal output_port_5_5_force: signed((19 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_9306b5127f is
  port (
    input_port : in std_logic_vector((18 - 1) downto 0);
    output_port : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_9306b5127f;


architecture behavior of reinterpret_9306b5127f is
  signal input_port_1_40: unsigned((18 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_2aea51ccde is
  port (
    in0 : in std_logic_vector((19 - 1) downto 0);
    in1 : in std_logic_vector((19 - 1) downto 0);
    in2 : in std_logic_vector((19 - 1) downto 0);
    in3 : in std_logic_vector((19 - 1) downto 0);
    y : out std_logic_vector((76 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_2aea51ccde;


architecture behavior of concat_2aea51ccde is
  signal in0_1_23: unsigned((19 - 1) downto 0);
  signal in1_1_27: unsigned((19 - 1) downto 0);
  signal in2_1_31: unsigned((19 - 1) downto 0);
  signal in3_1_35: unsigned((19 - 1) downto 0);
  signal y_2_1_concat: unsigned((76 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_9f61027ba4 is
  port (
    ip : in std_logic_vector((19 - 1) downto 0);
    op : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_9f61027ba4;


architecture behavior of scale_9f61027ba4 is
  signal ip_17_23: signed((19 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_b198bd62b0 is
  port (
    in0 : in std_logic_vector((18 - 1) downto 0);
    in1 : in std_logic_vector((18 - 1) downto 0);
    y : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_b198bd62b0;


architecture behavior of concat_b198bd62b0 is
  signal in0_1_23: unsigned((18 - 1) downto 0);
  signal in1_1_27: unsigned((18 - 1) downto 0);
  signal y_2_1_concat: unsigned((36 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_86b044698f is
  port (
    input_port : in std_logic_vector((36 - 1) downto 0);
    output_port : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_86b044698f;


architecture behavior of reinterpret_86b044698f is
  signal input_port_1_40: unsigned((36 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity negate_f983e30a8b is
  port (
    ip : in std_logic_vector((18 - 1) downto 0);
    op : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end negate_f983e30a8b;


architecture behavior of negate_f983e30a8b is
  signal ip_18_25: signed((18 - 1) downto 0);
  type array_type_op_mem_48_20 is array (0 to (1 - 1)) of signed((18 - 1) downto 0);
  signal op_mem_48_20: array_type_op_mem_48_20 := (
    0 => "000000000000000000");
  signal op_mem_48_20_front_din: signed((18 - 1) downto 0);
  signal op_mem_48_20_back: signed((18 - 1) downto 0);
  signal op_mem_48_20_push_front_pop_back_en: std_logic;
  signal cast_35_24: signed((19 - 1) downto 0);
  signal internal_ip_35_9_neg: signed((19 - 1) downto 0);
  signal internal_ip_join_30_1: signed((19 - 1) downto 0);
  signal cast_internal_ip_40_3_convert: signed((18 - 1) downto 0);
begin
  ip_18_25 <= std_logic_vector_to_signed(ip);
  op_mem_48_20_back <= op_mem_48_20(0);
  proc_op_mem_48_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_48_20_push_front_pop_back_en = '1')) then
        op_mem_48_20(0) <= op_mem_48_20_front_din;
      end if;
    end if;
  end process proc_op_mem_48_20;
  cast_35_24 <= s2s_cast(ip_18_25, 17, 19, 17);
  internal_ip_35_9_neg <=  -cast_35_24;
  proc_if_30_1: process (internal_ip_35_9_neg)
  is
  begin
    if false then
      internal_ip_join_30_1 <= std_logic_vector_to_signed("0000000000000000000");
    else 
      internal_ip_join_30_1 <= internal_ip_35_9_neg;
    end if;
  end process proc_if_30_1;
  cast_internal_ip_40_3_convert <= s2s_cast(internal_ip_join_30_1, 17, 18, 17);
  op_mem_48_20_push_front_pop_back_en <= '0';
  op <= signed_to_std_logic_vector(cast_internal_ip_40_3_convert);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_6699ee0916 is
  port (
    d : in std_logic_vector((18 - 1) downto 0);
    q : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_6699ee0916;


architecture behavior of delay_6699ee0916 is
  signal d_1_22: std_logic_vector((18 - 1) downto 0);
begin
  d_1_22 <= d;
  q <= d_1_22;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_81130c7f2d is
  port (
    input_port : in std_logic_vector((1 - 1) downto 0);
    output_port : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_81130c7f2d;


architecture behavior of reinterpret_81130c7f2d is
  signal input_port_1_40: unsigned((1 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_4bb6f691f7 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((36 - 1) downto 0);
    d1 : in std_logic_vector((36 - 1) downto 0);
    y : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_4bb6f691f7;


architecture behavior of mux_4bb6f691f7 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((36 - 1) downto 0);
  signal d1_1_27: std_logic_vector((36 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "000000000000000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((36 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((36 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((36 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_112d91c147 is
  port (
    input_port : in std_logic_vector((1 - 1) downto 0);
    output_port : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_112d91c147;


architecture behavior of reinterpret_112d91c147 is
  signal input_port_1_40: boolean;
  signal output_port_7_5_convert: unsigned((1 - 1) downto 0);
begin
  input_port_1_40 <= ((input_port) = "1");
  output_port_7_5_convert <= u2u_cast(std_logic_vector_to_unsigned(boolean_to_vector(input_port_1_40)), 0, 1, 0);
  output_port <= unsigned_to_std_logic_vector(output_port_7_5_convert);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_4a391b9a0e is
  port (
    op : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_4a391b9a0e;


architecture behavior of constant_4a391b9a0e is
begin
  op <= "100000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_d5d467f1b8 is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_d5d467f1b8;


architecture behavior of counter_d5d467f1b8 is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((9 - 1) downto 0) := "000000000";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal rst_limit_join_44_1: boolean;
  signal count_reg_join_44_1: unsigned((10 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "000000000";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("000000001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_faa52967c8 is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_faa52967c8;


architecture behavior of delay_faa52967c8 is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (8 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(7);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 7 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_e962c41658 is
  port (
    a : in std_logic_vector((9 - 1) downto 0);
    b : in std_logic_vector((9 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_e962c41658;


architecture behavior of relational_e962c41658 is
  signal a_1_31: unsigned((9 - 1) downto 0);
  signal b_1_34: unsigned((9 - 1) downto 0);
  signal result_18_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_18_3_rel <= a_1_31 > b_1_34;
  op <= boolean_to_vector(result_18_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_14a6a51cbc is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_14a6a51cbc;


architecture behavior of delay_14a6a51cbc is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (8 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(7);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 7 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_f21e7f2ddf is
  port (
    input_port : in std_logic_vector((8 - 1) downto 0);
    output_port : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_f21e7f2ddf;


architecture behavior of reinterpret_f21e7f2ddf is
  signal input_port_1_40: unsigned((8 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_0c0a0420a6 is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_0c0a0420a6;


architecture behavior of delay_0c0a0420a6 is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
begin
  d_1_22 <= d;
  q <= d_1_22;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_b4ec9de7d1 is
  port (
    op : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_b4ec9de7d1;


architecture behavior of constant_b4ec9de7d1 is
begin
  op <= "000000001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_fd85eb7067 is
  port (
    op : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_fd85eb7067;


architecture behavior of constant_fd85eb7067 is
begin
  op <= "000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_1dea202a2f is
  port (
    load : in std_logic_vector((1 - 1) downto 0);
    din : in std_logic_vector((9 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_1dea202a2f;


architecture behavior of counter_1dea202a2f is
  signal load_1_29: boolean;
  signal din_1_35: unsigned((9 - 1) downto 0);
  signal en_1_45: boolean;
  signal count_reg_20_23_next: unsigned((9 - 1) downto 0);
  signal count_reg_20_23: unsigned((9 - 1) downto 0) := "000000000";
  signal count_reg_20_23_en: std_logic;
  signal cast_54_19: signed((11 - 1) downto 0);
  signal count_reg_54_7_addsub: signed((11 - 1) downto 0);
  signal count_reg_join_48_3: signed((11 - 1) downto 0);
  signal count_reg_join_44_1: signed((11 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal cast_count_reg_20_23_next: unsigned((9 - 1) downto 0);
begin
  load_1_29 <= ((load) = "1");
  din_1_35 <= std_logic_vector_to_unsigned(din);
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23_next;
      end if;
    end if;
  end process proc_count_reg_20_23;
  cast_54_19 <= u2s_cast(count_reg_20_23, 0, 11, 0);
  count_reg_54_7_addsub <= cast_54_19 - std_logic_vector_to_signed("00000000001");
  proc_if_48_3: process (count_reg_54_7_addsub, din_1_35, load_1_29)
  is
  begin
    if load_1_29 then
      count_reg_join_48_3 <= u2s_cast(din_1_35, 0, 11, 0);
    else 
      count_reg_join_48_3 <= count_reg_54_7_addsub;
    end if;
  end process proc_if_48_3;
  proc_if_44_1: process (count_reg_join_48_3, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    count_reg_join_44_1 <= count_reg_join_48_3;
  end process proc_if_44_1;
  cast_count_reg_20_23_next <= s2u_cast(count_reg_join_44_1, 0, 9, 0);
  count_reg_20_23_next <= cast_count_reg_20_23_next;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_aacf6e1b0e is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_aacf6e1b0e;


architecture behavior of logical_aacf6e1b0e is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  fully_2_1_bit <= d0_1_24 or d1_1_27;
  y <= std_logic_to_vector(fully_2_1_bit);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_80f90b97d0 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_80f90b97d0;


architecture behavior of logical_80f90b97d0 is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  fully_2_1_bit <= d0_1_24 and d1_1_27;
  y <= std_logic_to_vector(fully_2_1_bit);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_1bef4ba0e4 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_1bef4ba0e4;


architecture behavior of mux_1bef4ba0e4 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal unregy_join_6_1: std_logic;
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  y <= std_logic_to_vector(unregy_join_6_1);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_6c3ee657fa is
  port (
    a : in std_logic_vector((9 - 1) downto 0);
    b : in std_logic_vector((9 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_6c3ee657fa;


architecture behavior of relational_6c3ee657fa is
  signal a_1_31: unsigned((9 - 1) downto 0);
  signal b_1_34: unsigned((9 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_78eac2928d is
  port (
    a : in std_logic_vector((9 - 1) downto 0);
    b : in std_logic_vector((9 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_78eac2928d;


architecture behavior of relational_78eac2928d is
  signal a_1_31: unsigned((9 - 1) downto 0);
  signal b_1_34: unsigned((9 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_eeeda8f61f is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_eeeda8f61f;


architecture behavior of counter_eeeda8f61f is
  signal rst_1_40: boolean;
  signal en_1_45: boolean;
  signal count_reg_20_23: unsigned((9 - 1) downto 0) := "000000000";
  signal count_reg_20_23_rst: std_logic;
  signal count_reg_20_23_en: std_logic;
  signal bool_44_4: boolean;
  signal count_reg_join_44_1: unsigned((10 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal count_reg_join_44_1_rst: std_logic;
  signal rst_limit_join_44_1: boolean;
begin
  rst_1_40 <= ((rst) = "1");
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "000000000";
      elsif ((ce = '1') and (count_reg_20_23_en = '1')) then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("000000001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23, en_1_45)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    elsif en_1_45 then
      count_reg_join_44_1_rst <= '0';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    elsif en_1_45 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_7f6b7da686 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((8 - 1) downto 0);
    d1 : in std_logic_vector((8 - 1) downto 0);
    y : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_7f6b7da686;


architecture behavior of mux_7f6b7da686 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((8 - 1) downto 0);
  signal d1_1_27: std_logic_vector((8 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "00000000");
  signal pipe_16_22_front_din: std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((8 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_9565135955 is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_9565135955;


architecture behavior of delay_9565135955 is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (3 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000",
    "00000000",
    "00000000");
  signal op_mem_20_24_front_din: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(2);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_bdaf6c9e55 is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_bdaf6c9e55;


architecture behavior of delay_bdaf6c9e55 is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (4 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(3);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 3 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_423c6c1400 is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_423c6c1400;


architecture behavior of delay_423c6c1400 is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
begin
  d_1_22 <= d;
  q <= d_1_22;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_85c2ef968b is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_85c2ef968b;


architecture behavior of delay_85c2ef968b is
  signal d_1_22: std_logic_vector((1 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (3 - 1)) of std_logic_vector((1 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0",
    "0",
    "0");
  signal op_mem_20_24_front_din: std_logic_vector((1 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((1 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(2);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_c53de546ea is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_c53de546ea;


architecture behavior of delay_c53de546ea is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (4 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0',
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(3);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 3 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xlsprom_window_and_fft_test_v4 is
  generic (
    core_name0: string := "";
    c_width: integer := 12;
    c_address_width: integer := 4;
    latency: integer := 1
  );
  port (
    addr: in std_logic_vector(c_address_width - 1 downto 0);
    en: in std_logic_vector(0 downto 0);
    rst: in std_logic_vector(0 downto 0);
    ce: in std_logic;
    clk: in std_logic;
    data: out std_logic_vector(c_width - 1 downto 0)
  );
end xlsprom_window_and_fft_test_v4 ;
architecture behavior of xlsprom_window_and_fft_test_v4 is
  component synth_reg
    generic (
      width: integer;
      latency: integer
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  signal core_addr: std_logic_vector(c_address_width - 1 downto 0);
  signal core_data_out: std_logic_vector(c_width - 1 downto 0);
  signal core_ce, sinit: std_logic;
  component bmg_72_71453be4ec33d4ae
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_71453be4ec33d4ae:
    component is true;
  attribute fpga_dont_touch of bmg_72_71453be4ec33d4ae:
    component is "true";
  attribute box_type of bmg_72_71453be4ec33d4ae:
    component  is "black_box";
  component bmg_72_fc83b5c52a6ea9e3
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_fc83b5c52a6ea9e3:
    component is true;
  attribute fpga_dont_touch of bmg_72_fc83b5c52a6ea9e3:
    component is "true";
  attribute box_type of bmg_72_fc83b5c52a6ea9e3:
    component  is "black_box";
  component bmg_72_92d96d23faa10f27
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_92d96d23faa10f27:
    component is true;
  attribute fpga_dont_touch of bmg_72_92d96d23faa10f27:
    component is "true";
  attribute box_type of bmg_72_92d96d23faa10f27:
    component  is "black_box";
  component bmg_72_a6d704d36eb848a5
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_a6d704d36eb848a5:
    component is true;
  attribute fpga_dont_touch of bmg_72_a6d704d36eb848a5:
    component is "true";
  attribute box_type of bmg_72_a6d704d36eb848a5:
    component  is "black_box";
  component bmg_72_b3a5d690118dc305
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_b3a5d690118dc305:
    component is true;
  attribute fpga_dont_touch of bmg_72_b3a5d690118dc305:
    component is "true";
  attribute box_type of bmg_72_b3a5d690118dc305:
    component  is "black_box";
  component bmg_72_8e2f9d152d14263e
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_8e2f9d152d14263e:
    component is true;
  attribute fpga_dont_touch of bmg_72_8e2f9d152d14263e:
    component is "true";
  attribute box_type of bmg_72_8e2f9d152d14263e:
    component  is "black_box";
  component bmg_72_3f3c61289e7ba7ea
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_3f3c61289e7ba7ea:
    component is true;
  attribute fpga_dont_touch of bmg_72_3f3c61289e7ba7ea:
    component is "true";
  attribute box_type of bmg_72_3f3c61289e7ba7ea:
    component  is "black_box";
  component bmg_72_5b8023f54686b589
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_5b8023f54686b589:
    component is true;
  attribute fpga_dont_touch of bmg_72_5b8023f54686b589:
    component is "true";
  attribute box_type of bmg_72_5b8023f54686b589:
    component  is "black_box";
  component bmg_72_2d8e9bcfdb574c10
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_2d8e9bcfdb574c10:
    component is true;
  attribute fpga_dont_touch of bmg_72_2d8e9bcfdb574c10:
    component is "true";
  attribute box_type of bmg_72_2d8e9bcfdb574c10:
    component  is "black_box";
  component bmg_72_ffcaf565dc759de1
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_ffcaf565dc759de1:
    component is true;
  attribute fpga_dont_touch of bmg_72_ffcaf565dc759de1:
    component is "true";
  attribute box_type of bmg_72_ffcaf565dc759de1:
    component  is "black_box";
  component bmg_72_d5319d7881548c22
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_d5319d7881548c22:
    component is true;
  attribute fpga_dont_touch of bmg_72_d5319d7881548c22:
    component is "true";
  attribute box_type of bmg_72_d5319d7881548c22:
    component  is "black_box";
  component bmg_72_b7d413d71af73706
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_b7d413d71af73706:
    component is true;
  attribute fpga_dont_touch of bmg_72_b7d413d71af73706:
    component is "true";
  attribute box_type of bmg_72_b7d413d71af73706:
    component  is "black_box";
  component bmg_72_fba27241bcd4df38
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_fba27241bcd4df38:
    component is true;
  attribute fpga_dont_touch of bmg_72_fba27241bcd4df38:
    component is "true";
  attribute box_type of bmg_72_fba27241bcd4df38:
    component  is "black_box";
  component bmg_72_5d708e36ddb23a80
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_5d708e36ddb23a80:
    component is true;
  attribute fpga_dont_touch of bmg_72_5d708e36ddb23a80:
    component is "true";
  attribute box_type of bmg_72_5d708e36ddb23a80:
    component  is "black_box";
  component bmg_72_146e01525f281df8
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_146e01525f281df8:
    component is true;
  attribute fpga_dont_touch of bmg_72_146e01525f281df8:
    component is "true";
  attribute box_type of bmg_72_146e01525f281df8:
    component  is "black_box";
  component bmg_72_e9a0d6c7631bff5b
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_e9a0d6c7631bff5b:
    component is true;
  attribute fpga_dont_touch of bmg_72_e9a0d6c7631bff5b:
    component is "true";
  attribute box_type of bmg_72_e9a0d6c7631bff5b:
    component  is "black_box";
  component bmg_72_ed1b80fcdf1c3a46
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_ed1b80fcdf1c3a46:
    component is true;
  attribute fpga_dont_touch of bmg_72_ed1b80fcdf1c3a46:
    component is "true";
  attribute box_type of bmg_72_ed1b80fcdf1c3a46:
    component  is "black_box";
  component bmg_72_f77670697183b527
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_f77670697183b527:
    component is true;
  attribute fpga_dont_touch of bmg_72_f77670697183b527:
    component is "true";
  attribute box_type of bmg_72_f77670697183b527:
    component  is "black_box";
  component bmg_72_51873a049072c953
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_51873a049072c953:
    component is true;
  attribute fpga_dont_touch of bmg_72_51873a049072c953:
    component is "true";
  attribute box_type of bmg_72_51873a049072c953:
    component  is "black_box";
begin
  core_addr <= addr;
  core_ce <= ce and en(0);
  sinit <= rst(0) and ce;
  comp0: if ((core_name0 = "bmg_72_71453be4ec33d4ae")) generate
    core_instance0: bmg_72_71453be4ec33d4ae
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp1: if ((core_name0 = "bmg_72_fc83b5c52a6ea9e3")) generate
    core_instance1: bmg_72_fc83b5c52a6ea9e3
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp2: if ((core_name0 = "bmg_72_92d96d23faa10f27")) generate
    core_instance2: bmg_72_92d96d23faa10f27
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp3: if ((core_name0 = "bmg_72_a6d704d36eb848a5")) generate
    core_instance3: bmg_72_a6d704d36eb848a5
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp4: if ((core_name0 = "bmg_72_b3a5d690118dc305")) generate
    core_instance4: bmg_72_b3a5d690118dc305
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp5: if ((core_name0 = "bmg_72_8e2f9d152d14263e")) generate
    core_instance5: bmg_72_8e2f9d152d14263e
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp6: if ((core_name0 = "bmg_72_3f3c61289e7ba7ea")) generate
    core_instance6: bmg_72_3f3c61289e7ba7ea
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp7: if ((core_name0 = "bmg_72_5b8023f54686b589")) generate
    core_instance7: bmg_72_5b8023f54686b589
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp8: if ((core_name0 = "bmg_72_2d8e9bcfdb574c10")) generate
    core_instance8: bmg_72_2d8e9bcfdb574c10
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp9: if ((core_name0 = "bmg_72_ffcaf565dc759de1")) generate
    core_instance9: bmg_72_ffcaf565dc759de1
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp10: if ((core_name0 = "bmg_72_d5319d7881548c22")) generate
    core_instance10: bmg_72_d5319d7881548c22
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp11: if ((core_name0 = "bmg_72_b7d413d71af73706")) generate
    core_instance11: bmg_72_b7d413d71af73706
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp12: if ((core_name0 = "bmg_72_fba27241bcd4df38")) generate
    core_instance12: bmg_72_fba27241bcd4df38
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp13: if ((core_name0 = "bmg_72_5d708e36ddb23a80")) generate
    core_instance13: bmg_72_5d708e36ddb23a80
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp14: if ((core_name0 = "bmg_72_146e01525f281df8")) generate
    core_instance14: bmg_72_146e01525f281df8
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp15: if ((core_name0 = "bmg_72_e9a0d6c7631bff5b")) generate
    core_instance15: bmg_72_e9a0d6c7631bff5b
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp16: if ((core_name0 = "bmg_72_ed1b80fcdf1c3a46")) generate
    core_instance16: bmg_72_ed1b80fcdf1c3a46
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp17: if ((core_name0 = "bmg_72_f77670697183b527")) generate
    core_instance17: bmg_72_f77670697183b527
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp18: if ((core_name0 = "bmg_72_51873a049072c953")) generate
    core_instance18: bmg_72_51873a049072c953
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  latency_test: if (latency > 1) generate
    reg: synth_reg
      generic map (
        width => c_width,
        latency => latency - 1
      )
      port map (
        i => core_data_out,
        ce => core_ce,
        clr => '0',
        clk => clk,
        o => data
      );
  end generate;
  latency_1: if (latency <= 1) generate
    data <= core_data_out;
  end generate;
end  behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_e18fb31a3d is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_e18fb31a3d;


architecture behavior of delay_e18fb31a3d is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_a1e126f11c is
  port (
    in0 : in std_logic_vector((8 - 1) downto 0);
    in1 : in std_logic_vector((8 - 1) downto 0);
    in2 : in std_logic_vector((8 - 1) downto 0);
    in3 : in std_logic_vector((8 - 1) downto 0);
    y : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_a1e126f11c;


architecture behavior of concat_a1e126f11c is
  signal in0_1_23: unsigned((8 - 1) downto 0);
  signal in1_1_27: unsigned((8 - 1) downto 0);
  signal in2_1_31: unsigned((8 - 1) downto 0);
  signal in3_1_35: unsigned((8 - 1) downto 0);
  signal y_2_1_concat: unsigned((32 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_a0c7cd7a34 is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    in2 : in std_logic_vector((1 - 1) downto 0);
    in3 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_a0c7cd7a34;


architecture behavior of concat_a0c7cd7a34 is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal in2_1_31: unsigned((1 - 1) downto 0);
  signal in3_1_35: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((4 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_28d2c9d50c is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_28d2c9d50c;


architecture behavior of delay_28d2c9d50c is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (6 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(5);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 5 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlcounter_free_window_and_fft_test_v4 is
  generic (
    core_name0: string := "";
    op_width: integer := 5;
    op_arith: integer := xlSigned
  );
  port (
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    op: out std_logic_vector(op_width - 1 downto 0);
    up: in std_logic_vector(0 downto 0) := (others => '0');
    load: in std_logic_vector(0 downto 0) := (others => '0');
    din: in std_logic_vector(op_width - 1 downto 0) := (others => '0');
    en: in std_logic_vector(0 downto 0);
    rst: in std_logic_vector(0 downto 0)
  );
end xlcounter_free_window_and_fft_test_v4 ;
architecture behavior of xlcounter_free_window_and_fft_test_v4 is
  component cntr_11_0_21ee79a31172f35f
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      load: in std_logic;
      l: in std_logic_vector(op_width - 1 downto 0);
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_21ee79a31172f35f:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_21ee79a31172f35f:
    component is "true";
  attribute box_type of cntr_11_0_21ee79a31172f35f:
    component  is "black_box";
  component cntr_11_0_9966d4e54ef143a4
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_9966d4e54ef143a4:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_9966d4e54ef143a4:
    component is "true";
  attribute box_type of cntr_11_0_9966d4e54ef143a4:
    component  is "black_box";
  component cntr_11_0_5c0d8fded7f0a054
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_5c0d8fded7f0a054:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_5c0d8fded7f0a054:
    component is "true";
  attribute box_type of cntr_11_0_5c0d8fded7f0a054:
    component  is "black_box";
  component cntr_11_0_457d1583b36d1c7c
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_457d1583b36d1c7c:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_457d1583b36d1c7c:
    component is "true";
  attribute box_type of cntr_11_0_457d1583b36d1c7c:
    component  is "black_box";
-- synopsys translate_off
  constant zeroVec: std_logic_vector(op_width - 1 downto 0) := (others => '0');
  constant oneVec: std_logic_vector(op_width - 1 downto 0) := (others => '1');
  constant zeroStr: string(1 to op_width) :=
    std_logic_vector_to_bin_string(zeroVec);
  constant oneStr: string(1 to op_width) :=
    std_logic_vector_to_bin_string(oneVec);
-- synopsys translate_on
  signal core_sinit: std_logic;
  signal core_ce: std_logic;
  signal op_net: std_logic_vector(op_width - 1 downto 0);
begin
  core_ce <= ce and en(0);
  core_sinit <= (clr or rst(0)) and ce;
  op <= op_net;
  comp0: if ((core_name0 = "cntr_11_0_21ee79a31172f35f")) generate
    core_instance0: cntr_11_0_21ee79a31172f35f
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        load => load(0),
        l => din,
        q => op_net
      );
  end generate;
  comp1: if ((core_name0 = "cntr_11_0_9966d4e54ef143a4")) generate
    core_instance1: cntr_11_0_9966d4e54ef143a4
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp2: if ((core_name0 = "cntr_11_0_5c0d8fded7f0a054")) generate
    core_instance2: cntr_11_0_5c0d8fded7f0a054
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp3: if ((core_name0 = "cntr_11_0_457d1583b36d1c7c")) generate
    core_instance3: cntr_11_0_457d1583b36d1c7c
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_e4b9fcaf02 is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_e4b9fcaf02;


architecture behavior of delay_e4b9fcaf02 is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_23d71a76f2 is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_23d71a76f2;


architecture behavior of delay_23d71a76f2 is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (3 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(2);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_fca786f2ff is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((36 - 1) downto 0);
    d1 : in std_logic_vector((36 - 1) downto 0);
    y : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_fca786f2ff;


architecture behavior of mux_fca786f2ff is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((36 - 1) downto 0);
  signal d1_1_27: std_logic_vector((36 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "000000000000000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((36 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((36 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((36 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_5a12f8f9be is
  port (
    in0 : in std_logic_vector((19 - 1) downto 0);
    in1 : in std_logic_vector((19 - 1) downto 0);
    y : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_5a12f8f9be;


architecture behavior of concat_5a12f8f9be is
  signal in0_1_23: unsigned((19 - 1) downto 0);
  signal in1_1_27: unsigned((19 - 1) downto 0);
  signal y_2_1_concat: unsigned((38 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_e140b59ec8 is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((18 - 1) downto 0);
    s : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_e140b59ec8;


architecture behavior of addsub_e140b59ec8 is
  signal a_17_32: signed((18 - 1) downto 0);
  signal b_17_35: signed((18 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((19 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000000");
  signal op_mem_91_20_front_din: signed((19 - 1) downto 0);
  signal op_mem_91_20_back: signed((19 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((19 - 1) downto 0);
  signal cast_69_22: signed((19 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((19 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 17, 19, 17);
  cast_69_22 <= s2s_cast(b_17_35, 17, 19, 17);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_c615d93998 is
  port (
    in0 : in std_logic_vector((20 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((21 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_c615d93998;


architecture behavior of concat_c615d93998 is
  signal in0_1_23: unsigned((20 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((21 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_4a8cbc85ce is
  port (
    input_port : in std_logic_vector((20 - 1) downto 0);
    output_port : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_4a8cbc85ce;


architecture behavior of reinterpret_4a8cbc85ce is
  signal input_port_1_40: signed((20 - 1) downto 0);
  signal output_port_5_5_force: unsigned((20 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_d357e69fa3 is
  port (
    input_port : in std_logic_vector((21 - 1) downto 0);
    output_port : out std_logic_vector((21 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_d357e69fa3;


architecture behavior of reinterpret_d357e69fa3 is
  signal input_port_1_40: unsigned((21 - 1) downto 0);
  signal output_port_5_5_force: signed((21 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_9d76333483 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_9d76333483;


architecture behavior of logical_9d76333483 is
  signal d0_1_24: std_logic_vector((1 - 1) downto 0);
  signal d1_1_27: std_logic_vector((1 - 1) downto 0);
  signal fully_2_1_bit: std_logic_vector((1 - 1) downto 0);
begin
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  fully_2_1_bit <= d0_1_24 xor d1_1_27;
  y <= fully_2_1_bit;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_f86ebb6084 is
  port (
    in0 : in std_logic_vector((20 - 1) downto 0);
    in1 : in std_logic_vector((20 - 1) downto 0);
    in2 : in std_logic_vector((20 - 1) downto 0);
    in3 : in std_logic_vector((20 - 1) downto 0);
    y : out std_logic_vector((80 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_f86ebb6084;


architecture behavior of concat_f86ebb6084 is
  signal in0_1_23: unsigned((20 - 1) downto 0);
  signal in1_1_27: unsigned((20 - 1) downto 0);
  signal in2_1_31: unsigned((20 - 1) downto 0);
  signal in3_1_35: unsigned((20 - 1) downto 0);
  signal y_2_1_concat: unsigned((80 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_b366689086 is
  port (
    op : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_b366689086;


architecture behavior of constant_b366689086 is
begin
  op <= "0000000000000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_b1e9d7c303 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_b1e9d7c303;


architecture behavior of logical_b1e9d7c303 is
  signal d0_1_24: std_logic_vector((1 - 1) downto 0);
  signal d1_1_27: std_logic_vector((1 - 1) downto 0);
  signal bit_2_26: std_logic_vector((1 - 1) downto 0);
  signal fully_2_1_bitnot: std_logic_vector((1 - 1) downto 0);
begin
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  bit_2_26 <= d0_1_24 or d1_1_27;
  fully_2_1_bitnot <= not bit_2_26;
  y <= fully_2_1_bitnot;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_7461f1deba is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((18 - 1) downto 0);
    s : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_7461f1deba;


architecture behavior of addsub_7461f1deba is
  signal a_17_32: signed((18 - 1) downto 0);
  signal b_17_35: signed((18 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((19 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000000");
  signal op_mem_91_20_front_din: signed((19 - 1) downto 0);
  signal op_mem_91_20_back: signed((19 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((19 - 1) downto 0);
  signal cast_71_22: signed((19 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((19 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 17, 19, 17);
  cast_71_22 <= s2s_cast(b_17_35, 17, 19, 17);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_713b6c5d29 is
  port (
    input_port : in std_logic_vector((20 - 1) downto 0);
    output_port : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_713b6c5d29;


architecture behavior of reinterpret_713b6c5d29 is
  signal input_port_1_40: unsigned((20 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_ce20fdf7b8 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((20 - 1) downto 0);
    d1 : in std_logic_vector((20 - 1) downto 0);
    y : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_ce20fdf7b8;


architecture behavior of mux_ce20fdf7b8 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((20 - 1) downto 0);
  signal d1_1_27: std_logic_vector((20 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (2 - 1)) of std_logic_vector((20 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    "00000000000000000000",
    "00000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((20 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((20 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((20 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(1);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          pipe_16_22(i) <= pipe_16_22(i-1);
        end loop;
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_4822199898 is
  port (
    in0 : in std_logic_vector((38 - 1) downto 0);
    in1 : in std_logic_vector((38 - 1) downto 0);
    y : out std_logic_vector((76 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_4822199898;


architecture behavior of concat_4822199898 is
  signal in0_1_23: unsigned((38 - 1) downto 0);
  signal in1_1_27: unsigned((38 - 1) downto 0);
  signal y_2_1_concat: unsigned((76 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_1f855d073b is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_1f855d073b;


architecture behavior of delay_1f855d073b is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (256 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(255);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 255 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_0341f7be44 is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_0341f7be44;


architecture behavior of delay_0341f7be44 is
  signal d_1_22: std_logic;
begin
  d_1_22 <= d(0);
  q <= std_logic_to_vector(d_1_22);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity negate_a9c5a8edc5 is
  port (
    ip : in std_logic_vector((18 - 1) downto 0);
    op : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end negate_a9c5a8edc5;


architecture behavior of negate_a9c5a8edc5 is
  signal ip_18_25: signed((18 - 1) downto 0);
  type array_type_op_mem_48_20 is array (0 to (2 - 1)) of signed((18 - 1) downto 0);
  signal op_mem_48_20: array_type_op_mem_48_20 := (
    "000000000000000000",
    "000000000000000000");
  signal op_mem_48_20_front_din: signed((18 - 1) downto 0);
  signal op_mem_48_20_back: signed((18 - 1) downto 0);
  signal op_mem_48_20_push_front_pop_back_en: std_logic;
  signal cast_35_24: signed((19 - 1) downto 0);
  signal internal_ip_35_9_neg: signed((19 - 1) downto 0);
  signal internal_ip_join_30_1: signed((19 - 1) downto 0);
  signal internal_ip_40_3_convert: signed((18 - 1) downto 0);
begin
  ip_18_25 <= std_logic_vector_to_signed(ip);
  op_mem_48_20_back <= op_mem_48_20(1);
  proc_op_mem_48_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_48_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_48_20(i) <= op_mem_48_20(i-1);
        end loop;
        op_mem_48_20(0) <= op_mem_48_20_front_din;
      end if;
    end if;
  end process proc_op_mem_48_20;
  cast_35_24 <= s2s_cast(ip_18_25, 17, 19, 17);
  internal_ip_35_9_neg <=  -cast_35_24;
  proc_if_30_1: process (internal_ip_35_9_neg)
  is
  begin
    if false then
      internal_ip_join_30_1 <= std_logic_vector_to_signed("0000000000000000000");
    else 
      internal_ip_join_30_1 <= internal_ip_35_9_neg;
    end if;
  end process proc_if_30_1;
  internal_ip_40_3_convert <= std_logic_vector_to_signed(convert_type(signed_to_std_logic_vector(internal_ip_join_30_1), 19, 17, xlSigned, 18, 17, xlSigned, xlTruncate, xlSaturate));
  op_mem_48_20_front_din <= internal_ip_40_3_convert;
  op_mem_48_20_push_front_pop_back_en <= '1';
  op <= signed_to_std_logic_vector(op_mem_48_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_11ccef49a2 is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_11ccef49a2;


architecture behavior of counter_11ccef49a2 is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((8 - 1) downto 0) := "00000000";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal rst_limit_join_44_1: boolean;
  signal count_reg_join_44_1: unsigned((9 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "00000000";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("00000001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_328e8ebbb5 is
  port (
    d : in std_logic_vector((18 - 1) downto 0);
    q : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_328e8ebbb5;


architecture behavior of delay_328e8ebbb5 is
  signal d_1_22: std_logic_vector((18 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (3 - 1)) of std_logic_vector((18 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000",
    "000000000000000000",
    "000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((18 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((18 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(2);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_cbdfa55dc3 is
  port (
    d : in std_logic_vector((18 - 1) downto 0);
    q : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_cbdfa55dc3;


architecture behavior of delay_cbdfa55dc3 is
  signal d_1_22: std_logic_vector((18 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((18 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000",
    "000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((18 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((18 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_74a3397f06 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((18 - 1) downto 0);
    d1 : in std_logic_vector((18 - 1) downto 0);
    y : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_74a3397f06;


architecture behavior of mux_74a3397f06 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((18 - 1) downto 0);
  signal d1_1_27: std_logic_vector((18 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (4 - 1)) of std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    "000000000000000000",
    "000000000000000000",
    "000000000000000000",
    "000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((18 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(3);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        for i in 3 downto 1 loop 
          pipe_16_22(i) <= pipe_16_22(i-1);
        end loop;
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_181e58d842 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((18 - 1) downto 0);
    d1 : in std_logic_vector((18 - 1) downto 0);
    y : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_181e58d842;


architecture behavior of mux_181e58d842 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((18 - 1) downto 0);
  signal d1_1_27: std_logic_vector((18 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((18 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_c33e9b879a is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_c33e9b879a;


architecture behavior of delay_c33e9b879a is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (128 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(127);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 127 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_b437b02512 is
  port (
    op : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_b437b02512;


architecture behavior of constant_b437b02512 is
begin
  op <= "00000001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_91ef1678ca is
  port (
    op : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_91ef1678ca;


architecture behavior of constant_91ef1678ca is
begin
  op <= "00000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_e8aae5d3bb is
  port (
    op : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_e8aae5d3bb;


architecture behavior of constant_e8aae5d3bb is
begin
  op <= "10000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_a98fb09579 is
  port (
    load : in std_logic_vector((1 - 1) downto 0);
    din : in std_logic_vector((8 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_a98fb09579;


architecture behavior of counter_a98fb09579 is
  signal load_1_29: boolean;
  signal din_1_35: unsigned((8 - 1) downto 0);
  signal en_1_45: boolean;
  signal count_reg_20_23_next: unsigned((8 - 1) downto 0);
  signal count_reg_20_23: unsigned((8 - 1) downto 0) := "00000000";
  signal count_reg_20_23_en: std_logic;
  signal cast_54_19: signed((10 - 1) downto 0);
  signal count_reg_54_7_addsub: signed((10 - 1) downto 0);
  signal count_reg_join_48_3: signed((10 - 1) downto 0);
  signal count_reg_join_44_1: signed((10 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal cast_count_reg_20_23_next: unsigned((8 - 1) downto 0);
begin
  load_1_29 <= ((load) = "1");
  din_1_35 <= std_logic_vector_to_unsigned(din);
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23_next;
      end if;
    end if;
  end process proc_count_reg_20_23;
  cast_54_19 <= u2s_cast(count_reg_20_23, 0, 10, 0);
  count_reg_54_7_addsub <= cast_54_19 - std_logic_vector_to_signed("0000000001");
  proc_if_48_3: process (count_reg_54_7_addsub, din_1_35, load_1_29)
  is
  begin
    if load_1_29 then
      count_reg_join_48_3 <= u2s_cast(din_1_35, 0, 10, 0);
    else 
      count_reg_join_48_3 <= count_reg_54_7_addsub;
    end if;
  end process proc_if_48_3;
  proc_if_44_1: process (count_reg_join_48_3, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    count_reg_join_44_1 <= count_reg_join_48_3;
  end process proc_if_44_1;
  cast_count_reg_20_23_next <= s2u_cast(count_reg_join_44_1, 0, 8, 0);
  count_reg_20_23_next <= cast_count_reg_20_23_next;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_54048c8b02 is
  port (
    a : in std_logic_vector((8 - 1) downto 0);
    b : in std_logic_vector((8 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_54048c8b02;


architecture behavior of relational_54048c8b02 is
  signal a_1_31: unsigned((8 - 1) downto 0);
  signal b_1_34: unsigned((8 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_16235eb2bf is
  port (
    a : in std_logic_vector((8 - 1) downto 0);
    b : in std_logic_vector((8 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_16235eb2bf;


architecture behavior of relational_16235eb2bf is
  signal a_1_31: unsigned((8 - 1) downto 0);
  signal b_1_34: unsigned((8 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_9e724c4b50 is
  port (
    in0 : in std_logic_vector((20 - 1) downto 0);
    in1 : in std_logic_vector((20 - 1) downto 0);
    y : out std_logic_vector((40 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_9e724c4b50;


architecture behavior of concat_9e724c4b50 is
  signal in0_1_23: unsigned((20 - 1) downto 0);
  signal in1_1_27: unsigned((20 - 1) downto 0);
  signal y_2_1_concat: unsigned((40 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_c1b57d7d0a is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((19 - 1) downto 0);
    s : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_c1b57d7d0a;


architecture behavior of addsub_c1b57d7d0a is
  signal a_17_32: signed((18 - 1) downto 0);
  signal b_17_35: signed((19 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((20 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000000000");
  signal op_mem_91_20_front_din: signed((20 - 1) downto 0);
  signal op_mem_91_20_back: signed((20 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((20 - 1) downto 0);
  signal cast_69_22: signed((20 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((20 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 17, 20, 17);
  cast_69_22 <= s2s_cast(b_17_35, 17, 20, 17);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_e6bc20c81b is
  port (
    in0 : in std_logic_vector((21 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((22 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_e6bc20c81b;


architecture behavior of concat_e6bc20c81b is
  signal in0_1_23: unsigned((21 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((22 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_f0ca8483cb is
  port (
    input_port : in std_logic_vector((21 - 1) downto 0);
    output_port : out std_logic_vector((21 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_f0ca8483cb;


architecture behavior of reinterpret_f0ca8483cb is
  signal input_port_1_40: signed((21 - 1) downto 0);
  signal output_port_5_5_force: unsigned((21 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_c84451c80b is
  port (
    input_port : in std_logic_vector((22 - 1) downto 0);
    output_port : out std_logic_vector((22 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_c84451c80b;


architecture behavior of reinterpret_c84451c80b is
  signal input_port_1_40: unsigned((22 - 1) downto 0);
  signal output_port_5_5_force: signed((22 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_356a264444 is
  port (
    in0 : in std_logic_vector((21 - 1) downto 0);
    in1 : in std_logic_vector((21 - 1) downto 0);
    in2 : in std_logic_vector((21 - 1) downto 0);
    in3 : in std_logic_vector((21 - 1) downto 0);
    y : out std_logic_vector((84 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_356a264444;


architecture behavior of concat_356a264444 is
  signal in0_1_23: unsigned((21 - 1) downto 0);
  signal in1_1_27: unsigned((21 - 1) downto 0);
  signal in2_1_31: unsigned((21 - 1) downto 0);
  signal in3_1_35: unsigned((21 - 1) downto 0);
  signal y_2_1_concat: unsigned((84 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_97239b8ed2 is
  port (
    ip : in std_logic_vector((20 - 1) downto 0);
    op : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_97239b8ed2;


architecture behavior of scale_97239b8ed2 is
  signal ip_17_23: signed((20 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_5f641f1cd5 is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((19 - 1) downto 0);
    s : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_5f641f1cd5;


architecture behavior of addsub_5f641f1cd5 is
  signal a_17_32: signed((18 - 1) downto 0);
  signal b_17_35: signed((19 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((20 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000000000");
  signal op_mem_91_20_front_din: signed((20 - 1) downto 0);
  signal op_mem_91_20_back: signed((20 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((20 - 1) downto 0);
  signal cast_71_22: signed((20 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((20 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 17, 20, 17);
  cast_71_22 <= s2s_cast(b_17_35, 17, 20, 17);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_299ca43e25 is
  port (
    input_port : in std_logic_vector((21 - 1) downto 0);
    output_port : out std_logic_vector((21 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_299ca43e25;


architecture behavior of reinterpret_299ca43e25 is
  signal input_port_1_40: unsigned((21 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_46aae2a33a is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((21 - 1) downto 0);
    d1 : in std_logic_vector((21 - 1) downto 0);
    y : out std_logic_vector((21 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_46aae2a33a;


architecture behavior of mux_46aae2a33a is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((21 - 1) downto 0);
  signal d1_1_27: std_logic_vector((21 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (2 - 1)) of std_logic_vector((21 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    "000000000000000000000",
    "000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((21 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((21 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((21 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(1);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          pipe_16_22(i) <= pipe_16_22(i-1);
        end loop;
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_83820b2faf is
  port (
    in0 : in std_logic_vector((37 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_83820b2faf;


architecture behavior of concat_83820b2faf is
  signal in0_1_23: unsigned((37 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((38 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_db4c53ade5 is
  port (
    input_port : in std_logic_vector((37 - 1) downto 0);
    output_port : out std_logic_vector((37 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_db4c53ade5;


architecture behavior of reinterpret_db4c53ade5 is
  signal input_port_1_40: signed((37 - 1) downto 0);
  signal output_port_5_5_force: unsigned((37 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_2da6af93c2 is
  port (
    op : out std_logic_vector((35 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_2da6af93c2;


architecture behavior of constant_2da6af93c2 is
begin
  op <= "00000000000000000011111111111111111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_620dd01637 is
  port (
    input_port : in std_logic_vector((38 - 1) downto 0);
    output_port : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_620dd01637;


architecture behavior of reinterpret_620dd01637 is
  signal input_port_1_40: unsigned((38 - 1) downto 0);
  signal output_port_5_5_force: signed((38 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_ec14c62a89 is
  port (
    input_port : in std_logic_vector((35 - 1) downto 0);
    output_port : out std_logic_vector((35 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_ec14c62a89;


architecture behavior of reinterpret_ec14c62a89 is
  signal input_port_1_40: unsigned((35 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_5b4829fb41 is
  port (
    input_port : in std_logic_vector((37 - 1) downto 0);
    output_port : out std_logic_vector((37 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_5b4829fb41;


architecture behavior of reinterpret_5b4829fb41 is
  signal input_port_1_40: unsigned((37 - 1) downto 0);
  signal output_port_5_5_force: signed((37 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_cdda6c7e6c is
  port (
    d : in std_logic_vector((37 - 1) downto 0);
    q : out std_logic_vector((37 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_cdda6c7e6c;


architecture behavior of delay_cdda6c7e6c is
  signal d_1_22: std_logic_vector((37 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((37 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "0000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((37 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((37 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_b28df1ab2e is
  port (
    in0 : in std_logic_vector((36 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    in2 : in std_logic_vector((36 - 1) downto 0);
    y : out std_logic_vector((73 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_b28df1ab2e;


architecture behavior of concat_b28df1ab2e is
  signal in0_1_23: unsigned((36 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal in2_1_31: unsigned((36 - 1) downto 0);
  signal y_2_1_concat: unsigned((73 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_892b735f0d is
  port (
    input_port : in std_logic_vector((37 - 1) downto 0);
    output_port : out std_logic_vector((37 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_892b735f0d;


architecture behavior of reinterpret_892b735f0d is
  signal input_port_1_40: unsigned((37 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_efdf1c3890 is
  port (
    input_port : in std_logic_vector((74 - 1) downto 0);
    output_port : out std_logic_vector((74 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_efdf1c3890;


architecture behavior of reinterpret_efdf1c3890 is
  signal input_port_1_40: unsigned((74 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_c3ccc04d1a is
  port (
    in0 : in std_logic_vector((36 - 1) downto 0);
    in1 : in std_logic_vector((36 - 1) downto 0);
    y : out std_logic_vector((72 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_c3ccc04d1a;


architecture behavior of concat_c3ccc04d1a is
  signal in0_1_23: unsigned((36 - 1) downto 0);
  signal in1_1_27: unsigned((36 - 1) downto 0);
  signal y_2_1_concat: unsigned((72 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_56d57d2c92 is
  port (
    in0 : in std_logic_vector((37 - 1) downto 0);
    in1 : in std_logic_vector((37 - 1) downto 0);
    y : out std_logic_vector((74 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_56d57d2c92;


architecture behavior of concat_56d57d2c92 is
  signal in0_1_23: unsigned((37 - 1) downto 0);
  signal in1_1_27: unsigned((37 - 1) downto 0);
  signal y_2_1_concat: unsigned((74 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_44b396c607 is
  port (
    a : in std_logic_vector((36 - 1) downto 0);
    b : in std_logic_vector((36 - 1) downto 0);
    s : out std_logic_vector((37 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_44b396c607;


architecture behavior of addsub_44b396c607 is
  signal a_17_32: signed((36 - 1) downto 0);
  signal b_17_35: signed((36 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((37 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000000000000000000000000");
  signal op_mem_91_20_front_din: signed((37 - 1) downto 0);
  signal op_mem_91_20_back: signed((37 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((37 - 1) downto 0);
  signal cast_69_22: signed((37 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((37 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 34, 37, 34);
  cast_69_22 <= s2s_cast(b_17_35, 34, 37, 34);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_74747a130a is
  port (
    a : in std_logic_vector((36 - 1) downto 0);
    b : in std_logic_vector((36 - 1) downto 0);
    s : out std_logic_vector((37 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_74747a130a;


architecture behavior of addsub_74747a130a is
  signal a_17_32: signed((36 - 1) downto 0);
  signal b_17_35: signed((36 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((37 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000000000000000000000000");
  signal op_mem_91_20_front_din: signed((37 - 1) downto 0);
  signal op_mem_91_20_back: signed((37 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((37 - 1) downto 0);
  signal cast_71_22: signed((37 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((37 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 34, 37, 34);
  cast_71_22 <= s2s_cast(b_17_35, 34, 37, 34);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mult_f295e5f0f2 is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((18 - 1) downto 0);
    p : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mult_f295e5f0f2;


architecture behavior of mult_f295e5f0f2 is
  signal a_1_22: signed((18 - 1) downto 0);
  signal b_1_25: signed((18 - 1) downto 0);
  type array_type_op_mem_65_20 is array (0 to (2 - 1)) of signed((36 - 1) downto 0);
  signal op_mem_65_20: array_type_op_mem_65_20 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_65_20_front_din: signed((36 - 1) downto 0);
  signal op_mem_65_20_back: signed((36 - 1) downto 0);
  signal op_mem_65_20_push_front_pop_back_en: std_logic;
  signal mult_46_56: signed((36 - 1) downto 0);
begin
  a_1_22 <= std_logic_vector_to_signed(a);
  b_1_25 <= std_logic_vector_to_signed(b);
  op_mem_65_20_back <= op_mem_65_20(1);
  proc_op_mem_65_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_65_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_65_20(i) <= op_mem_65_20(i-1);
        end loop;
        op_mem_65_20(0) <= op_mem_65_20_front_din;
      end if;
    end if;
  end process proc_op_mem_65_20;
  mult_46_56 <= (a_1_22 * b_1_25);
  op_mem_65_20_front_din <= mult_46_56;
  op_mem_65_20_push_front_pop_back_en <= '1';
  p <= signed_to_std_logic_vector(op_mem_65_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_c24bb045ac is
  port (
    d : in std_logic_vector((37 - 1) downto 0);
    q : out std_logic_vector((37 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_c24bb045ac;


architecture behavior of delay_c24bb045ac is
  signal d_1_22: std_logic_vector((37 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (4 - 1)) of std_logic_vector((37 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0000000000000000000000000000000000000",
    "0000000000000000000000000000000000000",
    "0000000000000000000000000000000000000",
    "0000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((37 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((37 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(3);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 3 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_e6f5ee726b is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_e6f5ee726b;


architecture behavior of concat_e6f5ee726b is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((2 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_4a9a9a25a3 is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((2 - 1) downto 0);
    y : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_4a9a9a25a3;


architecture behavior of concat_4a9a9a25a3 is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((2 - 1) downto 0);
  signal y_2_1_concat: unsigned((3 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_cda50df78a is
  port (
    op : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_cda50df78a;


architecture behavior of constant_cda50df78a is
begin
  op <= "00";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_6160d7387c is
  port (
    in0 : in std_logic_vector((2 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_6160d7387c;


architecture behavior of concat_6160d7387c is
  signal in0_1_23: unsigned((2 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((3 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_fcebea29b9 is
  port (
    d : in std_logic_vector((2 - 1) downto 0);
    q : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_fcebea29b9;


architecture behavior of delay_fcebea29b9 is
  signal d_1_22: std_logic_vector((2 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((2 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00",
    "00");
  signal op_mem_20_24_front_din: std_logic_vector((2 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((2 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_a7e2bb9e12 is
  port (
    op : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_a7e2bb9e12;


architecture behavior of constant_a7e2bb9e12 is
begin
  op <= "01";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_4e967fa4b7 is
  port (
    d : in std_logic_vector((73 - 1) downto 0);
    q : out std_logic_vector((73 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_4e967fa4b7;


architecture behavior of delay_4e967fa4b7 is
  signal d_1_22: std_logic_vector((73 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (4 - 1)) of std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(3);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 3 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_1896e7760c is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((18 - 1) downto 0);
    d1 : in std_logic_vector((18 - 1) downto 0);
    y : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_1896e7760c;


architecture behavior of mux_1896e7760c is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((18 - 1) downto 0);
  signal d1_1_27: std_logic_vector((18 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (2 - 1)) of std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    "000000000000000000",
    "000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((18 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(1);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          pipe_16_22(i) <= pipe_16_22(i-1);
        end loop;
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_95b0f967bc is
  port (
    op : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_95b0f967bc;


architecture behavior of constant_95b0f967bc is
begin
  op <= "000000000000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_7097453b2c is
  port (
    d : in std_logic_vector((73 - 1) downto 0);
    q : out std_logic_vector((73 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_7097453b2c;


architecture behavior of delay_7097453b2c is
  signal d_1_22: std_logic_vector((73 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlpassthrough is
    generic (
        din_width    : integer := 16;
        dout_width   : integer := 16
        );
    port (
        din : in std_logic_vector (din_width-1 downto 0);
        dout : out std_logic_vector (dout_width-1 downto 0));
end xlpassthrough;
architecture passthrough_arch of xlpassthrough is
begin
  dout <= din;
end passthrough_arch;

-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xldpram_dist_window_and_fft_test_v4 is
  generic (
    core_name0: string := "";
    c_width: integer := 12;
    addr_width: integer := 12;
    c_address_width: integer := 4;
    latency: integer := 1
  );
  port (
    dina: in std_logic_vector(c_width - 1 downto 0);
    addra: in std_logic_vector(addr_width - 1 downto 0);
    wea: in std_logic_vector(0 downto 0);
    ena: in std_logic_vector(0 downto 0) := (others => '1');
    a_ce: in std_logic;
    a_clk: in std_logic;
    douta: out std_logic_vector(c_width - 1 downto 0);
    addrb: in std_logic_vector(addr_width - 1 downto 0);
    enb: in std_logic_vector(0 downto 0) := (others => '1');
    b_ce: in std_logic;
    b_clk: in std_logic;
    doutb: out std_logic_vector(c_width - 1 downto 0)
  );
end xldpram_dist_window_and_fft_test_v4 ;
architecture behavior of xldpram_dist_window_and_fft_test_v4 is
  component synth_reg is
    generic (
      width: integer := 8;
      latency: integer := 1
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  constant num_extra_addr_bits: integer := (c_address_width - addr_width);
  signal core_addra, core_addrb: std_logic_vector(c_address_width - 1 downto 0);
  signal core_data_in, core_douta, core_doutb: std_logic_vector(c_width - 1 downto 0);
  signal reg_douta, reg_doutb: std_logic_vector(c_width - 1 downto 0);
  signal core_we: std_logic_vector(0 downto 0);
  signal core_cea, core_ceb: std_logic;
  component dmg_72_61c575268fb396d0
    port (
      a: in std_logic_vector(c_address_width - 1 downto 0);
      clk: in std_logic;
      d: in std_logic_vector(c_width - 1 downto 0);
      we: in std_logic;
      dpra: in std_logic_vector(c_address_width - 1 downto 0);
      spo: out std_logic_vector(c_width - 1 downto 0);
      dpo: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of dmg_72_61c575268fb396d0:
    component is true;
  attribute fpga_dont_touch of dmg_72_61c575268fb396d0:
    component is "true";
  attribute box_type of dmg_72_61c575268fb396d0:
    component  is "black_box";
  component dmg_72_3edbd32a5305b92d
    port (
      a: in std_logic_vector(c_address_width - 1 downto 0);
      clk: in std_logic;
      d: in std_logic_vector(c_width - 1 downto 0);
      we: in std_logic;
      dpra: in std_logic_vector(c_address_width - 1 downto 0);
      spo: out std_logic_vector(c_width - 1 downto 0);
      dpo: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of dmg_72_3edbd32a5305b92d:
    component is true;
  attribute fpga_dont_touch of dmg_72_3edbd32a5305b92d:
    component is "true";
  attribute box_type of dmg_72_3edbd32a5305b92d:
    component  is "black_box";
  component dmg_72_28098a4ce465921e
    port (
      a: in std_logic_vector(c_address_width - 1 downto 0);
      clk: in std_logic;
      d: in std_logic_vector(c_width - 1 downto 0);
      we: in std_logic;
      dpra: in std_logic_vector(c_address_width - 1 downto 0);
      spo: out std_logic_vector(c_width - 1 downto 0);
      dpo: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of dmg_72_28098a4ce465921e:
    component is true;
  attribute fpga_dont_touch of dmg_72_28098a4ce465921e:
    component is "true";
  attribute box_type of dmg_72_28098a4ce465921e:
    component  is "black_box";
  component dmg_72_06baee6e81a49674
    port (
      a: in std_logic_vector(c_address_width - 1 downto 0);
      clk: in std_logic;
      d: in std_logic_vector(c_width - 1 downto 0);
      we: in std_logic;
      dpra: in std_logic_vector(c_address_width - 1 downto 0);
      spo: out std_logic_vector(c_width - 1 downto 0);
      dpo: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of dmg_72_06baee6e81a49674:
    component is true;
  attribute fpga_dont_touch of dmg_72_06baee6e81a49674:
    component is "true";
  attribute box_type of dmg_72_06baee6e81a49674:
    component  is "black_box";
begin
  need_to_pad_addr : if num_extra_addr_bits > 0 generate
      core_addra(c_address_width - 1 downto addr_width) <= (others => '0');
      core_addra(addr_width - 1 downto 0) <= addra;
      core_addrb(c_address_width - 1 downto addr_width) <= (others => '0');
      core_addrb(addr_width - 1 downto 0) <= addrb;
  end generate;
  no_need_to_pad_addr: if num_extra_addr_bits = 0 generate
    core_addra <= addra;
    core_addrb <= addrb;
  end generate;
  douta <= reg_douta;
  doutb <= reg_doutb;
  core_cea <= a_ce and ena(0);
  core_ceb <= b_ce and enb(0);
  core_we(0) <= wea(0) and core_cea;
  registered_dpram : if latency > 0 generate
    output_rega: synth_reg
      generic map (
        width   => c_width,
        latency => latency
      )
      port map (
        i   => core_douta,
        ce  => core_cea,
        clr => '0',
        clk => a_clk,
        o   => reg_douta
      );
    output_regb: synth_reg
      generic map (
        width   => c_width,
        latency => latency
      )
      port map (
        i   => core_doutb,
        ce  => core_ceb,
        clr => '0',
        clk => b_clk,
        o   => reg_doutb
      );
  end generate;
  nonregistered_ram : if latency = 0 generate
    reg_douta <= core_douta;
    reg_doutb <= core_doutb;
  end generate;
  comp0: if ((core_name0 = "dmg_72_61c575268fb396d0")) generate
    core_instance0: dmg_72_61c575268fb396d0
      port map (
        a => core_addra,
        clk => a_clk,
        d => dina,
        we => core_we(0),
        dpra => core_addrb,
        spo => core_douta,
        dpo => core_doutb
      );
  end generate;
  comp1: if ((core_name0 = "dmg_72_3edbd32a5305b92d")) generate
    core_instance1: dmg_72_3edbd32a5305b92d
      port map (
        a => core_addra,
        clk => a_clk,
        d => dina,
        we => core_we(0),
        dpra => core_addrb,
        spo => core_douta,
        dpo => core_doutb
      );
  end generate;
  comp2: if ((core_name0 = "dmg_72_28098a4ce465921e")) generate
    core_instance2: dmg_72_28098a4ce465921e
      port map (
        a => core_addra,
        clk => a_clk,
        d => dina,
        we => core_we(0),
        dpra => core_addrb,
        spo => core_douta,
        dpo => core_doutb
      );
  end generate;
  comp3: if ((core_name0 = "dmg_72_06baee6e81a49674")) generate
    core_instance3: dmg_72_06baee6e81a49674
      port map (
        a => core_addra,
        clk => a_clk,
        d => dina,
        we => core_we(0),
        dpra => core_addrb,
        spo => core_douta,
        dpo => core_doutb
      );
  end generate;
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_cfdc93535e is
  port (
    in0 : in std_logic_vector((40 - 1) downto 0);
    in1 : in std_logic_vector((40 - 1) downto 0);
    y : out std_logic_vector((80 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_cfdc93535e;


architecture behavior of concat_cfdc93535e is
  signal in0_1_23: unsigned((40 - 1) downto 0);
  signal in1_1_27: unsigned((40 - 1) downto 0);
  signal y_2_1_concat: unsigned((80 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_9b6c7a899e is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_9b6c7a899e;


architecture behavior of delay_9b6c7a899e is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (64 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(63);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 63 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_180df391de is
  port (
    op : out std_logic_vector((7 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_180df391de;


architecture behavior of constant_180df391de is
begin
  op <= "0000001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_7244cd602b is
  port (
    op : out std_logic_vector((7 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_7244cd602b;


architecture behavior of constant_7244cd602b is
begin
  op <= "0000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_7b07120b87 is
  port (
    op : out std_logic_vector((7 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_7b07120b87;


architecture behavior of constant_7b07120b87 is
begin
  op <= "1000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_82d8714dde is
  port (
    load : in std_logic_vector((1 - 1) downto 0);
    din : in std_logic_vector((7 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((7 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_82d8714dde;


architecture behavior of counter_82d8714dde is
  signal load_1_29: boolean;
  signal din_1_35: unsigned((7 - 1) downto 0);
  signal en_1_45: boolean;
  signal count_reg_20_23_next: unsigned((7 - 1) downto 0);
  signal count_reg_20_23: unsigned((7 - 1) downto 0) := "0000000";
  signal count_reg_20_23_en: std_logic;
  signal cast_54_19: signed((9 - 1) downto 0);
  signal count_reg_54_7_addsub: signed((9 - 1) downto 0);
  signal count_reg_join_48_3: signed((9 - 1) downto 0);
  signal count_reg_join_44_1: signed((9 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal cast_count_reg_20_23_next: unsigned((7 - 1) downto 0);
begin
  load_1_29 <= ((load) = "1");
  din_1_35 <= std_logic_vector_to_unsigned(din);
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23_next;
      end if;
    end if;
  end process proc_count_reg_20_23;
  cast_54_19 <= u2s_cast(count_reg_20_23, 0, 9, 0);
  count_reg_54_7_addsub <= cast_54_19 - std_logic_vector_to_signed("000000001");
  proc_if_48_3: process (count_reg_54_7_addsub, din_1_35, load_1_29)
  is
  begin
    if load_1_29 then
      count_reg_join_48_3 <= u2s_cast(din_1_35, 0, 9, 0);
    else 
      count_reg_join_48_3 <= count_reg_54_7_addsub;
    end if;
  end process proc_if_48_3;
  proc_if_44_1: process (count_reg_join_48_3, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    count_reg_join_44_1 <= count_reg_join_48_3;
  end process proc_if_44_1;
  cast_count_reg_20_23_next <= s2u_cast(count_reg_join_44_1, 0, 7, 0);
  count_reg_20_23_next <= cast_count_reg_20_23_next;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_9a3978c602 is
  port (
    a : in std_logic_vector((7 - 1) downto 0);
    b : in std_logic_vector((7 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_9a3978c602;


architecture behavior of relational_9a3978c602 is
  signal a_1_31: unsigned((7 - 1) downto 0);
  signal b_1_34: unsigned((7 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_23065a6aa3 is
  port (
    a : in std_logic_vector((7 - 1) downto 0);
    b : in std_logic_vector((7 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_23065a6aa3;


architecture behavior of relational_23065a6aa3 is
  signal a_1_31: unsigned((7 - 1) downto 0);
  signal b_1_34: unsigned((7 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_e63924e4e7 is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((7 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_e63924e4e7;


architecture behavior of counter_e63924e4e7 is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((7 - 1) downto 0) := "0000000";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal count_reg_join_44_1: unsigned((8 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
  signal rst_limit_join_44_1: boolean;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "0000000";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("0000001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_452c4d3410 is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    in2 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_452c4d3410;


architecture behavior of concat_452c4d3410 is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal in2_1_31: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((3 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_949f038a6d is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((3 - 1) downto 0);
    y : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_949f038a6d;


architecture behavior of concat_949f038a6d is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((3 - 1) downto 0);
  signal y_2_1_concat: unsigned((4 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_bd20dd351d is
  port (
    in0 : in std_logic_vector((2 - 1) downto 0);
    in1 : in std_logic_vector((2 - 1) downto 0);
    y : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_bd20dd351d;


architecture behavior of concat_bd20dd351d is
  signal in0_1_23: unsigned((2 - 1) downto 0);
  signal in1_1_27: unsigned((2 - 1) downto 0);
  signal y_2_1_concat: unsigned((4 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_6edcd04662 is
  port (
    d : in std_logic_vector((3 - 1) downto 0);
    q : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_6edcd04662;


architecture behavior of delay_6edcd04662 is
  signal d_1_22: std_logic_vector((3 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((3 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000",
    "000");
  signal op_mem_20_24_front_din: std_logic_vector((3 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((3 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_895e998e80 is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_895e998e80;


architecture behavior of delay_895e998e80 is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (32 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(31);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 31 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_a267c870be is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_a267c870be;


architecture behavior of constant_a267c870be is
begin
  op <= "000001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_7ea0f2fff7 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_7ea0f2fff7;


architecture behavior of constant_7ea0f2fff7 is
begin
  op <= "000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_961b61f8a1 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_961b61f8a1;


architecture behavior of constant_961b61f8a1 is
begin
  op <= "100000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_9686286f74 is
  port (
    load : in std_logic_vector((1 - 1) downto 0);
    din : in std_logic_vector((6 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_9686286f74;


architecture behavior of counter_9686286f74 is
  signal load_1_29: boolean;
  signal din_1_35: unsigned((6 - 1) downto 0);
  signal en_1_45: boolean;
  signal count_reg_20_23_next: unsigned((6 - 1) downto 0);
  signal count_reg_20_23: unsigned((6 - 1) downto 0) := "000000";
  signal count_reg_20_23_en: std_logic;
  signal cast_54_19: signed((8 - 1) downto 0);
  signal count_reg_54_7_addsub: signed((8 - 1) downto 0);
  signal count_reg_join_48_3: signed((8 - 1) downto 0);
  signal count_reg_join_44_1: signed((8 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal cast_count_reg_20_23_next: unsigned((6 - 1) downto 0);
begin
  load_1_29 <= ((load) = "1");
  din_1_35 <= std_logic_vector_to_unsigned(din);
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23_next;
      end if;
    end if;
  end process proc_count_reg_20_23;
  cast_54_19 <= u2s_cast(count_reg_20_23, 0, 8, 0);
  count_reg_54_7_addsub <= cast_54_19 - std_logic_vector_to_signed("00000001");
  proc_if_48_3: process (count_reg_54_7_addsub, din_1_35, load_1_29)
  is
  begin
    if load_1_29 then
      count_reg_join_48_3 <= u2s_cast(din_1_35, 0, 8, 0);
    else 
      count_reg_join_48_3 <= count_reg_54_7_addsub;
    end if;
  end process proc_if_48_3;
  proc_if_44_1: process (count_reg_join_48_3, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    count_reg_join_44_1 <= count_reg_join_48_3;
  end process proc_if_44_1;
  cast_count_reg_20_23_next <= s2u_cast(count_reg_join_44_1, 0, 6, 0);
  count_reg_20_23_next <= cast_count_reg_20_23_next;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_931d61fb72 is
  port (
    a : in std_logic_vector((6 - 1) downto 0);
    b : in std_logic_vector((6 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_931d61fb72;


architecture behavior of relational_931d61fb72 is
  signal a_1_31: unsigned((6 - 1) downto 0);
  signal b_1_34: unsigned((6 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_fe487ce1c7 is
  port (
    a : in std_logic_vector((6 - 1) downto 0);
    b : in std_logic_vector((6 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_fe487ce1c7;


architecture behavior of relational_fe487ce1c7 is
  signal a_1_31: unsigned((6 - 1) downto 0);
  signal b_1_34: unsigned((6 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_7888581f80 is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_7888581f80;


architecture behavior of counter_7888581f80 is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((6 - 1) downto 0) := "000000";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal count_reg_join_44_1: unsigned((7 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
  signal rst_limit_join_44_1: boolean;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "000000";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("000001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_cf540617d5 is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((4 - 1) downto 0);
    y : out std_logic_vector((5 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_cf540617d5;


architecture behavior of concat_cf540617d5 is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((4 - 1) downto 0);
  signal y_2_1_concat: unsigned((5 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_8f12c32de0 is
  port (
    in0 : in std_logic_vector((2 - 1) downto 0);
    in1 : in std_logic_vector((3 - 1) downto 0);
    y : out std_logic_vector((5 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_8f12c32de0;


architecture behavior of concat_8f12c32de0 is
  signal in0_1_23: unsigned((2 - 1) downto 0);
  signal in1_1_27: unsigned((3 - 1) downto 0);
  signal y_2_1_concat: unsigned((5 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_4f82bd00e5 is
  port (
    d : in std_logic_vector((4 - 1) downto 0);
    q : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_4f82bd00e5;


architecture behavior of delay_4f82bd00e5 is
  signal d_1_22: std_logic_vector((4 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((4 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0000",
    "0000");
  signal op_mem_20_24_front_din: std_logic_vector((4 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((4 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_3a3620b5a6 is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_3a3620b5a6;


architecture behavior of delay_3a3620b5a6 is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (16 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(15);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 15 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_582a3706dd is
  port (
    op : out std_logic_vector((5 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_582a3706dd;


architecture behavior of constant_582a3706dd is
begin
  op <= "00001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_fe72737ca0 is
  port (
    op : out std_logic_vector((5 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_fe72737ca0;


architecture behavior of constant_fe72737ca0 is
begin
  op <= "00000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_ef0e2e5fc6 is
  port (
    op : out std_logic_vector((5 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_ef0e2e5fc6;


architecture behavior of constant_ef0e2e5fc6 is
begin
  op <= "10000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_9e5adb68be is
  port (
    load : in std_logic_vector((1 - 1) downto 0);
    din : in std_logic_vector((5 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((5 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_9e5adb68be;


architecture behavior of counter_9e5adb68be is
  signal load_1_29: boolean;
  signal din_1_35: unsigned((5 - 1) downto 0);
  signal en_1_45: boolean;
  signal count_reg_20_23_next: unsigned((5 - 1) downto 0);
  signal count_reg_20_23: unsigned((5 - 1) downto 0) := "00000";
  signal count_reg_20_23_en: std_logic;
  signal cast_54_19: signed((7 - 1) downto 0);
  signal count_reg_54_7_addsub: signed((7 - 1) downto 0);
  signal count_reg_join_48_3: signed((7 - 1) downto 0);
  signal count_reg_join_44_1: signed((7 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal cast_count_reg_20_23_next: unsigned((5 - 1) downto 0);
begin
  load_1_29 <= ((load) = "1");
  din_1_35 <= std_logic_vector_to_unsigned(din);
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23_next;
      end if;
    end if;
  end process proc_count_reg_20_23;
  cast_54_19 <= u2s_cast(count_reg_20_23, 0, 7, 0);
  count_reg_54_7_addsub <= cast_54_19 - std_logic_vector_to_signed("0000001");
  proc_if_48_3: process (count_reg_54_7_addsub, din_1_35, load_1_29)
  is
  begin
    if load_1_29 then
      count_reg_join_48_3 <= u2s_cast(din_1_35, 0, 7, 0);
    else 
      count_reg_join_48_3 <= count_reg_54_7_addsub;
    end if;
  end process proc_if_48_3;
  proc_if_44_1: process (count_reg_join_48_3, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    count_reg_join_44_1 <= count_reg_join_48_3;
  end process proc_if_44_1;
  cast_count_reg_20_23_next <= s2u_cast(count_reg_join_44_1, 0, 5, 0);
  count_reg_20_23_next <= cast_count_reg_20_23_next;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_9ece3c8c4e is
  port (
    a : in std_logic_vector((5 - 1) downto 0);
    b : in std_logic_vector((5 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_9ece3c8c4e;


architecture behavior of relational_9ece3c8c4e is
  signal a_1_31: unsigned((5 - 1) downto 0);
  signal b_1_34: unsigned((5 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_dc5bc996c9 is
  port (
    a : in std_logic_vector((5 - 1) downto 0);
    b : in std_logic_vector((5 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_dc5bc996c9;


architecture behavior of relational_dc5bc996c9 is
  signal a_1_31: unsigned((5 - 1) downto 0);
  signal b_1_34: unsigned((5 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_a2ece21d6a is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((5 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_a2ece21d6a;


architecture behavior of counter_a2ece21d6a is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((5 - 1) downto 0) := "00000";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal rst_limit_join_44_1: boolean;
  signal count_reg_join_44_1: unsigned((6 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "00000";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("00001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_2b3acb49f4 is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    in2 : in std_logic_vector((1 - 1) downto 0);
    in3 : in std_logic_vector((1 - 1) downto 0);
    in4 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((5 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_2b3acb49f4;


architecture behavior of concat_2b3acb49f4 is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal in2_1_31: unsigned((1 - 1) downto 0);
  signal in3_1_35: unsigned((1 - 1) downto 0);
  signal in4_1_39: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((5 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_ac785d9b37 is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((5 - 1) downto 0);
    y : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_ac785d9b37;


architecture behavior of concat_ac785d9b37 is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((5 - 1) downto 0);
  signal y_2_1_concat: unsigned((6 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_ae3f02567e is
  port (
    in0 : in std_logic_vector((2 - 1) downto 0);
    in1 : in std_logic_vector((4 - 1) downto 0);
    y : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_ae3f02567e;


architecture behavior of concat_ae3f02567e is
  signal in0_1_23: unsigned((2 - 1) downto 0);
  signal in1_1_27: unsigned((4 - 1) downto 0);
  signal y_2_1_concat: unsigned((6 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_38f665f8aa is
  port (
    d : in std_logic_vector((5 - 1) downto 0);
    q : out std_logic_vector((5 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_38f665f8aa;


architecture behavior of delay_38f665f8aa is
  signal d_1_22: std_logic_vector((5 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((5 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000",
    "00000");
  signal op_mem_20_24_front_din: std_logic_vector((5 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((5 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_67ad97ca70 is
  port (
    op : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_67ad97ca70;


architecture behavior of constant_67ad97ca70 is
begin
  op <= "0001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_4c449dd556 is
  port (
    op : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_4c449dd556;


architecture behavior of constant_4c449dd556 is
begin
  op <= "0000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_145086465d is
  port (
    op : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_145086465d;


architecture behavior of constant_145086465d is
begin
  op <= "1000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_230536be32 is
  port (
    load : in std_logic_vector((1 - 1) downto 0);
    din : in std_logic_vector((4 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_230536be32;


architecture behavior of counter_230536be32 is
  signal load_1_29: boolean;
  signal din_1_35: unsigned((4 - 1) downto 0);
  signal en_1_45: boolean;
  signal count_reg_20_23_next: unsigned((4 - 1) downto 0);
  signal count_reg_20_23: unsigned((4 - 1) downto 0) := "0000";
  signal count_reg_20_23_en: std_logic;
  signal cast_54_19: signed((6 - 1) downto 0);
  signal count_reg_54_7_addsub: signed((6 - 1) downto 0);
  signal count_reg_join_48_3: signed((6 - 1) downto 0);
  signal count_reg_join_44_1: signed((6 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal cast_count_reg_20_23_next: unsigned((4 - 1) downto 0);
begin
  load_1_29 <= ((load) = "1");
  din_1_35 <= std_logic_vector_to_unsigned(din);
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23_next;
      end if;
    end if;
  end process proc_count_reg_20_23;
  cast_54_19 <= u2s_cast(count_reg_20_23, 0, 6, 0);
  count_reg_54_7_addsub <= cast_54_19 - std_logic_vector_to_signed("000001");
  proc_if_48_3: process (count_reg_54_7_addsub, din_1_35, load_1_29)
  is
  begin
    if load_1_29 then
      count_reg_join_48_3 <= u2s_cast(din_1_35, 0, 6, 0);
    else 
      count_reg_join_48_3 <= count_reg_54_7_addsub;
    end if;
  end process proc_if_48_3;
  proc_if_44_1: process (count_reg_join_48_3, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    count_reg_join_44_1 <= count_reg_join_48_3;
  end process proc_if_44_1;
  cast_count_reg_20_23_next <= s2u_cast(count_reg_join_44_1, 0, 4, 0);
  count_reg_20_23_next <= cast_count_reg_20_23_next;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_4d3cfceaf4 is
  port (
    a : in std_logic_vector((4 - 1) downto 0);
    b : in std_logic_vector((4 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_4d3cfceaf4;


architecture behavior of relational_4d3cfceaf4 is
  signal a_1_31: unsigned((4 - 1) downto 0);
  signal b_1_34: unsigned((4 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_d930162434 is
  port (
    a : in std_logic_vector((4 - 1) downto 0);
    b : in std_logic_vector((4 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_d930162434;


architecture behavior of relational_d930162434 is
  signal a_1_31: unsigned((4 - 1) downto 0);
  signal b_1_34: unsigned((4 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_6068817c97 is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_6068817c97;


architecture behavior of counter_6068817c97 is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((4 - 1) downto 0) := "0000";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal count_reg_join_44_1: unsigned((5 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
  signal rst_limit_join_44_1: boolean;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "0000";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("0001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_2dc093ca7a is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    in2 : in std_logic_vector((1 - 1) downto 0);
    in3 : in std_logic_vector((1 - 1) downto 0);
    in4 : in std_logic_vector((1 - 1) downto 0);
    in5 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_2dc093ca7a;


architecture behavior of concat_2dc093ca7a is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal in2_1_31: unsigned((1 - 1) downto 0);
  signal in3_1_35: unsigned((1 - 1) downto 0);
  signal in4_1_39: unsigned((1 - 1) downto 0);
  signal in5_1_43: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((6 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  in5_1_43 <= std_logic_vector_to_unsigned(in5);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39) & unsigned_to_std_logic_vector(in5_1_43));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_c6a9b6687e is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((6 - 1) downto 0);
    y : out std_logic_vector((7 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_c6a9b6687e;


architecture behavior of concat_c6a9b6687e is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((6 - 1) downto 0);
  signal y_2_1_concat: unsigned((7 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_75261c7c53 is
  port (
    in0 : in std_logic_vector((2 - 1) downto 0);
    in1 : in std_logic_vector((5 - 1) downto 0);
    y : out std_logic_vector((7 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_75261c7c53;


architecture behavior of concat_75261c7c53 is
  signal in0_1_23: unsigned((2 - 1) downto 0);
  signal in1_1_27: unsigned((5 - 1) downto 0);
  signal y_2_1_concat: unsigned((7 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_da3bb0b159 is
  port (
    d : in std_logic_vector((6 - 1) downto 0);
    q : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_da3bb0b159;


architecture behavior of delay_da3bb0b159 is
  signal d_1_22: std_logic_vector((6 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((6 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000",
    "000000");
  signal op_mem_20_24_front_din: std_logic_vector((6 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((6 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_a1c496ea88 is
  port (
    op : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_a1c496ea88;


architecture behavior of constant_a1c496ea88 is
begin
  op <= "001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_822933f89b is
  port (
    op : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_822933f89b;


architecture behavior of constant_822933f89b is
begin
  op <= "000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_469094441c is
  port (
    op : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_469094441c;


architecture behavior of constant_469094441c is
begin
  op <= "100";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_ed7367cb5c is
  port (
    load : in std_logic_vector((1 - 1) downto 0);
    din : in std_logic_vector((3 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_ed7367cb5c;


architecture behavior of counter_ed7367cb5c is
  signal load_1_29: boolean;
  signal din_1_35: unsigned((3 - 1) downto 0);
  signal en_1_45: boolean;
  signal count_reg_20_23_next: unsigned((3 - 1) downto 0);
  signal count_reg_20_23: unsigned((3 - 1) downto 0) := "000";
  signal count_reg_20_23_en: std_logic;
  signal cast_54_19: signed((5 - 1) downto 0);
  signal count_reg_54_7_addsub: signed((5 - 1) downto 0);
  signal count_reg_join_48_3: signed((5 - 1) downto 0);
  signal count_reg_join_44_1: signed((5 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal cast_count_reg_20_23_next: unsigned((3 - 1) downto 0);
begin
  load_1_29 <= ((load) = "1");
  din_1_35 <= std_logic_vector_to_unsigned(din);
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23_next;
      end if;
    end if;
  end process proc_count_reg_20_23;
  cast_54_19 <= u2s_cast(count_reg_20_23, 0, 5, 0);
  count_reg_54_7_addsub <= cast_54_19 - std_logic_vector_to_signed("00001");
  proc_if_48_3: process (count_reg_54_7_addsub, din_1_35, load_1_29)
  is
  begin
    if load_1_29 then
      count_reg_join_48_3 <= u2s_cast(din_1_35, 0, 5, 0);
    else 
      count_reg_join_48_3 <= count_reg_54_7_addsub;
    end if;
  end process proc_if_48_3;
  proc_if_44_1: process (count_reg_join_48_3, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    count_reg_join_44_1 <= count_reg_join_48_3;
  end process proc_if_44_1;
  cast_count_reg_20_23_next <= s2u_cast(count_reg_join_44_1, 0, 3, 0);
  count_reg_20_23_next <= cast_count_reg_20_23_next;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_8fc7f5539b is
  port (
    a : in std_logic_vector((3 - 1) downto 0);
    b : in std_logic_vector((3 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_8fc7f5539b;


architecture behavior of relational_8fc7f5539b is
  signal a_1_31: unsigned((3 - 1) downto 0);
  signal b_1_34: unsigned((3 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_47b317dab6 is
  port (
    a : in std_logic_vector((3 - 1) downto 0);
    b : in std_logic_vector((3 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_47b317dab6;


architecture behavior of relational_47b317dab6 is
  signal a_1_31: unsigned((3 - 1) downto 0);
  signal b_1_34: unsigned((3 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_191d4874ab is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_191d4874ab;


architecture behavior of counter_191d4874ab is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((3 - 1) downto 0) := "000";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal rst_limit_join_44_1: boolean;
  signal count_reg_join_44_1: unsigned((4 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "000";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_eb5f1ca7f9 is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    in2 : in std_logic_vector((1 - 1) downto 0);
    in3 : in std_logic_vector((1 - 1) downto 0);
    in4 : in std_logic_vector((1 - 1) downto 0);
    in5 : in std_logic_vector((1 - 1) downto 0);
    in6 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((7 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_eb5f1ca7f9;


architecture behavior of concat_eb5f1ca7f9 is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal in2_1_31: unsigned((1 - 1) downto 0);
  signal in3_1_35: unsigned((1 - 1) downto 0);
  signal in4_1_39: unsigned((1 - 1) downto 0);
  signal in5_1_43: unsigned((1 - 1) downto 0);
  signal in6_1_47: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((7 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  in5_1_43 <= std_logic_vector_to_unsigned(in5);
  in6_1_47 <= std_logic_vector_to_unsigned(in6);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39) & unsigned_to_std_logic_vector(in5_1_43) & unsigned_to_std_logic_vector(in6_1_47));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_dc245eb1d2 is
  port (
    in0 : in std_logic_vector((2 - 1) downto 0);
    in1 : in std_logic_vector((6 - 1) downto 0);
    y : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_dc245eb1d2;


architecture behavior of concat_dc245eb1d2 is
  signal in0_1_23: unsigned((2 - 1) downto 0);
  signal in1_1_27: unsigned((6 - 1) downto 0);
  signal y_2_1_concat: unsigned((8 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_8a9e828e57 is
  port (
    d : in std_logic_vector((7 - 1) downto 0);
    q : out std_logic_vector((7 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_8a9e828e57;


architecture behavior of delay_8a9e828e57 is
  signal d_1_22: std_logic_vector((7 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((7 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0000000",
    "0000000");
  signal op_mem_20_24_front_din: std_logic_vector((7 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((7 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_38898c80c0 is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_38898c80c0;


architecture behavior of delay_38898c80c0 is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_e8ddc079e9 is
  port (
    op : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_e8ddc079e9;


architecture behavior of constant_e8ddc079e9 is
begin
  op <= "10";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_e095645f0c is
  port (
    load : in std_logic_vector((1 - 1) downto 0);
    din : in std_logic_vector((2 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_e095645f0c;


architecture behavior of counter_e095645f0c is
  signal load_1_29: boolean;
  signal din_1_35: unsigned((2 - 1) downto 0);
  signal en_1_45: boolean;
  signal count_reg_20_23_next: unsigned((2 - 1) downto 0);
  signal count_reg_20_23: unsigned((2 - 1) downto 0) := "00";
  signal count_reg_20_23_en: std_logic;
  signal cast_54_19: signed((4 - 1) downto 0);
  signal count_reg_54_7_addsub: signed((4 - 1) downto 0);
  signal count_reg_join_48_3: signed((4 - 1) downto 0);
  signal count_reg_join_44_1: signed((4 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal cast_count_reg_20_23_next: unsigned((2 - 1) downto 0);
begin
  load_1_29 <= ((load) = "1");
  din_1_35 <= std_logic_vector_to_unsigned(din);
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23_next;
      end if;
    end if;
  end process proc_count_reg_20_23;
  cast_54_19 <= u2s_cast(count_reg_20_23, 0, 4, 0);
  count_reg_54_7_addsub <= cast_54_19 - std_logic_vector_to_signed("0001");
  proc_if_48_3: process (count_reg_54_7_addsub, din_1_35, load_1_29)
  is
  begin
    if load_1_29 then
      count_reg_join_48_3 <= u2s_cast(din_1_35, 0, 4, 0);
    else 
      count_reg_join_48_3 <= count_reg_54_7_addsub;
    end if;
  end process proc_if_48_3;
  proc_if_44_1: process (count_reg_join_48_3, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    count_reg_join_44_1 <= count_reg_join_48_3;
  end process proc_if_44_1;
  cast_count_reg_20_23_next <= s2u_cast(count_reg_join_44_1, 0, 2, 0);
  count_reg_20_23_next <= cast_count_reg_20_23_next;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_5f1eb17108 is
  port (
    a : in std_logic_vector((2 - 1) downto 0);
    b : in std_logic_vector((2 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_5f1eb17108;


architecture behavior of relational_5f1eb17108 is
  signal a_1_31: unsigned((2 - 1) downto 0);
  signal b_1_34: unsigned((2 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_f9928864ea is
  port (
    a : in std_logic_vector((2 - 1) downto 0);
    b : in std_logic_vector((2 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_f9928864ea;


architecture behavior of relational_f9928864ea is
  signal a_1_31: unsigned((2 - 1) downto 0);
  signal b_1_34: unsigned((2 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_107ada62c3 is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_107ada62c3;


architecture behavior of counter_107ada62c3 is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((2 - 1) downto 0) := "00";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal count_reg_join_44_1: unsigned((3 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
  signal rst_limit_join_44_1: boolean;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "00";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("01");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_7673b9b993 is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    in2 : in std_logic_vector((1 - 1) downto 0);
    in3 : in std_logic_vector((1 - 1) downto 0);
    in4 : in std_logic_vector((1 - 1) downto 0);
    in5 : in std_logic_vector((1 - 1) downto 0);
    in6 : in std_logic_vector((1 - 1) downto 0);
    in7 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_7673b9b993;


architecture behavior of concat_7673b9b993 is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal in2_1_31: unsigned((1 - 1) downto 0);
  signal in3_1_35: unsigned((1 - 1) downto 0);
  signal in4_1_39: unsigned((1 - 1) downto 0);
  signal in5_1_43: unsigned((1 - 1) downto 0);
  signal in6_1_47: unsigned((1 - 1) downto 0);
  signal in7_1_51: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((8 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  in5_1_43 <= std_logic_vector_to_unsigned(in5);
  in6_1_47 <= std_logic_vector_to_unsigned(in6);
  in7_1_51 <= std_logic_vector_to_unsigned(in7);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39) & unsigned_to_std_logic_vector(in5_1_43) & unsigned_to_std_logic_vector(in6_1_47) & unsigned_to_std_logic_vector(in7_1_51));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_1ece14600f is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((8 - 1) downto 0);
    y : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_1ece14600f;


architecture behavior of concat_1ece14600f is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((8 - 1) downto 0);
  signal y_2_1_concat: unsigned((9 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_f62149b02a is
  port (
    in0 : in std_logic_vector((2 - 1) downto 0);
    in1 : in std_logic_vector((7 - 1) downto 0);
    y : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_f62149b02a;


architecture behavior of concat_f62149b02a is
  signal in0_1_23: unsigned((2 - 1) downto 0);
  signal in1_1_27: unsigned((7 - 1) downto 0);
  signal y_2_1_concat: unsigned((9 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_23f848c85b is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_23f848c85b;


architecture behavior of delay_23f848c85b is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000",
    "00000000");
  signal op_mem_20_24_front_din: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_223a0f3237 is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_223a0f3237;


architecture behavior of counter_223a0f3237 is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((1 - 1) downto 0) := "0";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal count_reg_join_44_1: unsigned((2 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
  signal rst_limit_join_44_1: boolean;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "0";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("1");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_341bdeba15 is
  port (
    in0 : in std_logic_vector((18 - 1) downto 0);
    in1 : in std_logic_vector((18 - 1) downto 0);
    in2 : in std_logic_vector((18 - 1) downto 0);
    in3 : in std_logic_vector((18 - 1) downto 0);
    in4 : in std_logic_vector((18 - 1) downto 0);
    in5 : in std_logic_vector((18 - 1) downto 0);
    in6 : in std_logic_vector((18 - 1) downto 0);
    in7 : in std_logic_vector((18 - 1) downto 0);
    y : out std_logic_vector((144 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_341bdeba15;


architecture behavior of concat_341bdeba15 is
  signal in0_1_23: unsigned((18 - 1) downto 0);
  signal in1_1_27: unsigned((18 - 1) downto 0);
  signal in2_1_31: unsigned((18 - 1) downto 0);
  signal in3_1_35: unsigned((18 - 1) downto 0);
  signal in4_1_39: unsigned((18 - 1) downto 0);
  signal in5_1_43: unsigned((18 - 1) downto 0);
  signal in6_1_47: unsigned((18 - 1) downto 0);
  signal in7_1_51: unsigned((18 - 1) downto 0);
  signal y_2_1_concat: unsigned((144 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  in5_1_43 <= std_logic_vector_to_unsigned(in5);
  in6_1_47 <= std_logic_vector_to_unsigned(in6);
  in7_1_51 <= std_logic_vector_to_unsigned(in7);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39) & unsigned_to_std_logic_vector(in5_1_43) & unsigned_to_std_logic_vector(in6_1_47) & unsigned_to_std_logic_vector(in7_1_51));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_8b4279cdc5 is
  port (
    input_port : in std_logic_vector((72 - 1) downto 0);
    output_port : out std_logic_vector((72 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_8b4279cdc5;


architecture behavior of reinterpret_8b4279cdc5 is
  signal input_port_1_40: unsigned((72 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_7cb1306ccc is
  port (
    in0 : in std_logic_vector((21 - 1) downto 0);
    in1 : in std_logic_vector((21 - 1) downto 0);
    in2 : in std_logic_vector((21 - 1) downto 0);
    in3 : in std_logic_vector((21 - 1) downto 0);
    in4 : in std_logic_vector((21 - 1) downto 0);
    in5 : in std_logic_vector((21 - 1) downto 0);
    in6 : in std_logic_vector((21 - 1) downto 0);
    in7 : in std_logic_vector((21 - 1) downto 0);
    y : out std_logic_vector((168 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_7cb1306ccc;


architecture behavior of concat_7cb1306ccc is
  signal in0_1_23: unsigned((21 - 1) downto 0);
  signal in1_1_27: unsigned((21 - 1) downto 0);
  signal in2_1_31: unsigned((21 - 1) downto 0);
  signal in3_1_35: unsigned((21 - 1) downto 0);
  signal in4_1_39: unsigned((21 - 1) downto 0);
  signal in5_1_43: unsigned((21 - 1) downto 0);
  signal in6_1_47: unsigned((21 - 1) downto 0);
  signal in7_1_51: unsigned((21 - 1) downto 0);
  signal y_2_1_concat: unsigned((168 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  in5_1_43 <= std_logic_vector_to_unsigned(in5);
  in6_1_47 <= std_logic_vector_to_unsigned(in6);
  in7_1_51 <= std_logic_vector_to_unsigned(in7);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39) & unsigned_to_std_logic_vector(in5_1_43) & unsigned_to_std_logic_vector(in6_1_47) & unsigned_to_std_logic_vector(in7_1_51));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_babbadab38 is
  port (
    in0 : in std_logic_vector((20 - 1) downto 0);
    in1 : in std_logic_vector((20 - 1) downto 0);
    in2 : in std_logic_vector((20 - 1) downto 0);
    in3 : in std_logic_vector((20 - 1) downto 0);
    in4 : in std_logic_vector((20 - 1) downto 0);
    in5 : in std_logic_vector((20 - 1) downto 0);
    in6 : in std_logic_vector((20 - 1) downto 0);
    in7 : in std_logic_vector((20 - 1) downto 0);
    y : out std_logic_vector((160 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_babbadab38;


architecture behavior of concat_babbadab38 is
  signal in0_1_23: unsigned((20 - 1) downto 0);
  signal in1_1_27: unsigned((20 - 1) downto 0);
  signal in2_1_31: unsigned((20 - 1) downto 0);
  signal in3_1_35: unsigned((20 - 1) downto 0);
  signal in4_1_39: unsigned((20 - 1) downto 0);
  signal in5_1_43: unsigned((20 - 1) downto 0);
  signal in6_1_47: unsigned((20 - 1) downto 0);
  signal in7_1_51: unsigned((20 - 1) downto 0);
  signal y_2_1_concat: unsigned((160 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  in5_1_43 <= std_logic_vector_to_unsigned(in5);
  in6_1_47 <= std_logic_vector_to_unsigned(in6);
  in7_1_51 <= std_logic_vector_to_unsigned(in7);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39) & unsigned_to_std_logic_vector(in5_1_43) & unsigned_to_std_logic_vector(in6_1_47) & unsigned_to_std_logic_vector(in7_1_51));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_153a31495d is
  port (
    d : in std_logic_vector((73 - 1) downto 0);
    q : out std_logic_vector((73 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_153a31495d;


architecture behavior of delay_153a31495d is
  signal d_1_22: std_logic_vector((73 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "0000000000000000000000000000000000000000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_b15c89b6cc is
  port (
    in0 : in std_logic_vector((72 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    in2 : in std_logic_vector((72 - 1) downto 0);
    y : out std_logic_vector((145 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_b15c89b6cc;


architecture behavior of concat_b15c89b6cc is
  signal in0_1_23: unsigned((72 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal in2_1_31: unsigned((72 - 1) downto 0);
  signal y_2_1_concat: unsigned((145 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_3a91fc640e is
  port (
    input_port : in std_logic_vector((73 - 1) downto 0);
    output_port : out std_logic_vector((73 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_3a91fc640e;


architecture behavior of reinterpret_3a91fc640e is
  signal input_port_1_40: unsigned((73 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_1cac477702 is
  port (
    in0 : in std_logic_vector((74 - 1) downto 0);
    in1 : in std_logic_vector((74 - 1) downto 0);
    y : out std_logic_vector((148 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_1cac477702;


architecture behavior of concat_1cac477702 is
  signal in0_1_23: unsigned((74 - 1) downto 0);
  signal in1_1_27: unsigned((74 - 1) downto 0);
  signal y_2_1_concat: unsigned((148 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_3ffe3e5660 is
  port (
    d : in std_logic_vector((73 - 1) downto 0);
    q : out std_logic_vector((73 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_3ffe3e5660;


architecture behavior of delay_3ffe3e5660 is
  signal d_1_22: std_logic_vector((73 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (5 - 1)) of std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(4);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 4 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_60ea556961 is
  port (
    input_port : in std_logic_vector((25 - 1) downto 0);
    output_port : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_60ea556961;


architecture behavior of reinterpret_60ea556961 is
  signal input_port_1_40: unsigned((25 - 1) downto 0);
  signal output_port_5_5_force: signed((25 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_402eae042e is
  port (
    in0 : in std_logic_vector((50 - 1) downto 0);
    in1 : in std_logic_vector((50 - 1) downto 0);
    y : out std_logic_vector((100 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_402eae042e;


architecture behavior of concat_402eae042e is
  signal in0_1_23: unsigned((50 - 1) downto 0);
  signal in1_1_27: unsigned((50 - 1) downto 0);
  signal y_2_1_concat: unsigned((100 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_0ad37a7234 is
  port (
    input_port : in std_logic_vector((50 - 1) downto 0);
    output_port : out std_logic_vector((50 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_0ad37a7234;


architecture behavior of reinterpret_0ad37a7234 is
  signal input_port_1_40: unsigned((50 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_dffba22f79 is
  port (
    a : in std_logic_vector((43 - 1) downto 0);
    b : in std_logic_vector((43 - 1) downto 0);
    s : out std_logic_vector((44 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_dffba22f79;


architecture behavior of addsub_dffba22f79 is
  signal a_17_32: signed((43 - 1) downto 0);
  signal b_17_35: signed((43 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((44 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000000000000000000000000000000000");
  signal op_mem_91_20_front_din: signed((44 - 1) downto 0);
  signal op_mem_91_20_back: signed((44 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((44 - 1) downto 0);
  signal cast_69_22: signed((44 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((44 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 41, 44, 41);
  cast_69_22 <= s2s_cast(b_17_35, 41, 44, 41);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_e326baca6b is
  port (
    a : in std_logic_vector((43 - 1) downto 0);
    b : in std_logic_vector((43 - 1) downto 0);
    s : out std_logic_vector((44 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_e326baca6b;


architecture behavior of addsub_e326baca6b is
  signal a_17_32: signed((43 - 1) downto 0);
  signal b_17_35: signed((43 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((44 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000000000000000000000000000000000");
  signal op_mem_91_20_front_din: signed((44 - 1) downto 0);
  signal op_mem_91_20_back: signed((44 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((44 - 1) downto 0);
  signal cast_71_22: signed((44 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((44 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 41, 44, 41);
  cast_71_22 <= s2s_cast(b_17_35, 41, 44, 41);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mult_4d389c6c89 is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((25 - 1) downto 0);
    p : out std_logic_vector((43 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mult_4d389c6c89;


architecture behavior of mult_4d389c6c89 is
  signal a_1_22: signed((18 - 1) downto 0);
  signal b_1_25: signed((25 - 1) downto 0);
  type array_type_op_mem_65_20 is array (0 to (2 - 1)) of signed((43 - 1) downto 0);
  signal op_mem_65_20: array_type_op_mem_65_20 := (
    "0000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000");
  signal op_mem_65_20_front_din: signed((43 - 1) downto 0);
  signal op_mem_65_20_back: signed((43 - 1) downto 0);
  signal op_mem_65_20_push_front_pop_back_en: std_logic;
  signal mult_46_56: signed((43 - 1) downto 0);
begin
  a_1_22 <= std_logic_vector_to_signed(a);
  b_1_25 <= std_logic_vector_to_signed(b);
  op_mem_65_20_back <= op_mem_65_20(1);
  proc_op_mem_65_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_65_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_65_20(i) <= op_mem_65_20(i-1);
        end loop;
        op_mem_65_20(0) <= op_mem_65_20_front_din;
      end if;
    end if;
  end process proc_op_mem_65_20;
  mult_46_56 <= (a_1_22 * b_1_25);
  op_mem_65_20_front_din <= mult_46_56;
  op_mem_65_20_push_front_pop_back_en <= '1';
  p <= signed_to_std_logic_vector(op_mem_65_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_b0d8099706 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((18 - 1) downto 0);
    d1 : in std_logic_vector((18 - 1) downto 0);
    y : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_b0d8099706;


architecture behavior of mux_b0d8099706 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((18 - 1) downto 0);
  signal d1_1_27: std_logic_vector((18 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (2 - 1)) of std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    "000000000000000000",
    "000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((18 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(1);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          pipe_16_22(i) <= pipe_16_22(i-1);
        end loop;
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_ed1960f5a8 is
  port (
    in0 : in std_logic_vector((25 - 1) downto 0);
    in1 : in std_logic_vector((25 - 1) downto 0);
    y : out std_logic_vector((50 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_ed1960f5a8;


architecture behavior of concat_ed1960f5a8 is
  signal in0_1_23: unsigned((25 - 1) downto 0);
  signal in1_1_27: unsigned((25 - 1) downto 0);
  signal y_2_1_concat: unsigned((50 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_c3c0e847be is
  port (
    input_port : in std_logic_vector((25 - 1) downto 0);
    output_port : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_c3c0e847be;


architecture behavior of reinterpret_c3c0e847be is
  signal input_port_1_40: signed((25 - 1) downto 0);
  signal output_port_5_5_force: unsigned((25 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_907aecc619 is
  port (
    d : in std_logic_vector((145 - 1) downto 0);
    q : out std_logic_vector((145 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_907aecc619;


architecture behavior of delay_907aecc619 is
  signal d_1_22: std_logic_vector((145 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (11 - 1)) of std_logic_vector((145 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((145 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((145 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(10);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 10 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_aab7b18c27 is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_aab7b18c27;


architecture behavior of delay_aab7b18c27 is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (6 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0',
    '0',
    '0',
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(5);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 5 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_df65ba8bae is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_df65ba8bae;


architecture behavior of constant_df65ba8bae is
begin
  op <= "1111001101110100001011001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_190b65ebff is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_190b65ebff;


architecture behavior of constant_190b65ebff is
begin
  op <= "0111111101100010001101101";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_01718d4f17 is
  port (
    a : in std_logic_vector((4 - 1) downto 0);
    b : in std_logic_vector((4 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_01718d4f17;


architecture behavior of relational_01718d4f17 is
  signal a_1_31: unsigned((4 - 1) downto 0);
  signal b_1_34: unsigned((4 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  result_14_3_rel <= a_1_31 /= b_1_34;
  op_mem_32_22_front_din <= result_14_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_1ea5b7e23c is
  port (
    in0 : in std_logic_vector((80 - 1) downto 0);
    in1 : in std_logic_vector((80 - 1) downto 0);
    y : out std_logic_vector((160 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_1ea5b7e23c;


architecture behavior of concat_1ea5b7e23c is
  signal in0_1_23: unsigned((80 - 1) downto 0);
  signal in1_1_27: unsigned((80 - 1) downto 0);
  signal y_2_1_concat: unsigned((160 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_055ed7478a is
  port (
    d : in std_logic_vector((73 - 1) downto 0);
    q : out std_logic_vector((73 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_055ed7478a;


architecture behavior of delay_055ed7478a is
  signal d_1_22: std_logic_vector((73 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (11 - 1)) of std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((73 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(10);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 10 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_e4af129d49 is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_e4af129d49;


architecture behavior of constant_e4af129d49 is
begin
  op <= "1111100110111000001001101";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_6731bdab96 is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_6731bdab96;


architecture behavior of constant_6731bdab96 is
begin
  op <= "0111111111011000100001111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_b754317574 is
  port (
    input_port : in std_logic_vector((9 - 1) downto 0);
    output_port : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_b754317574;


architecture behavior of reinterpret_b754317574 is
  signal input_port_1_40: unsigned((9 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_f2f6490a28 is
  port (
    in0 : in std_logic_vector((9 - 1) downto 0);
    in1 : in std_logic_vector((9 - 1) downto 0);
    y : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_f2f6490a28;


architecture behavior of concat_f2f6490a28 is
  signal in0_1_23: unsigned((9 - 1) downto 0);
  signal in1_1_27: unsigned((9 - 1) downto 0);
  signal y_2_1_concat: unsigned((18 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_09771002d6 is
  port (
    d : in std_logic_vector((9 - 1) downto 0);
    q : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_09771002d6;


architecture behavior of delay_09771002d6 is
  signal d_1_22: std_logic_vector((9 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((9 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "000000000");
  signal op_mem_20_24_front_din: std_logic_vector((9 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((9 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xldpram_window_and_fft_test_v4 is
  generic (
    core_name0: string := "";
    c_width_a: integer := 13;
    c_address_width_a: integer := 4;
    c_width_b: integer := 13;
    c_address_width_b: integer := 4;
    c_has_sinita: integer := 0;
    c_has_sinitb: integer := 0;
    latency: integer := 1
  );
  port (
    dina: in std_logic_vector(c_width_a - 1 downto 0);
    addra: in std_logic_vector(c_address_width_a - 1 downto 0);
    wea: in std_logic_vector(0 downto 0);
    a_ce: in std_logic;
    a_clk: in std_logic;
    rsta: in std_logic_vector(0 downto 0) := (others => '0');
    ena: in std_logic_vector(0 downto 0) := (others => '1');
    douta: out std_logic_vector(c_width_a - 1 downto 0);
    dinb: in std_logic_vector(c_width_b - 1 downto 0);
    addrb: in std_logic_vector(c_address_width_b - 1 downto 0);
    web: in std_logic_vector(0 downto 0);
    b_ce: in std_logic;
    b_clk: in std_logic;
    rstb: in std_logic_vector(0 downto 0) := (others => '0');
    enb: in std_logic_vector(0 downto 0) := (others => '1');
    doutb: out std_logic_vector(c_width_b - 1 downto 0)
  );
end xldpram_window_and_fft_test_v4;
architecture behavior of xldpram_window_and_fft_test_v4 is
  component synth_reg
    generic (
      width: integer;
      latency: integer
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;

  signal core_addra: std_logic_vector(c_address_width_a - 1 downto 0);
  signal core_addrb: std_logic_vector(c_address_width_b - 1 downto 0);
  signal core_dina, core_douta, dly_douta:
    std_logic_vector(c_width_a - 1 downto 0);
  signal core_dinb, core_doutb, dly_doutb:
    std_logic_vector(c_width_b - 1 downto 0);
  signal core_wea, core_web: std_logic;
  signal core_a_ce, core_b_ce: std_logic;
  signal sinita, sinitb: std_logic;

  component bmg_72_3673c2b46bfb142f
    port (
        addra: in std_logic_vector(c_address_width_a - 1 downto 0);
      addrb: in std_logic_vector(c_address_width_b - 1 downto 0);
      dina: in std_logic_vector(c_width_a - 1 downto 0);
      dinb: in std_logic_vector(c_width_b - 1 downto 0);
      clka: in std_logic;
      clkb: in std_logic;
      wea: in std_logic_vector(0 downto 0);
      web: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      enb: in std_logic;
      douta: out std_logic_vector(c_width_a - 1 downto 0);
      doutb: out std_logic_vector(c_width_b - 1 downto 0)
     );
  end component;

  attribute syn_black_box of bmg_72_3673c2b46bfb142f:
    component is true;
  attribute fpga_dont_touch of bmg_72_3673c2b46bfb142f:
    component is "true";
  attribute box_type of bmg_72_3673c2b46bfb142f:
    component  is "black_box";
begin
  core_addra <= addra;
  core_dina <= dina;
  douta <= dly_douta;
  core_wea <= wea(0);
  core_a_ce <= a_ce and ena(0);
  sinita <= rsta(0) and a_ce;

  core_addrb <= addrb;
  core_dinb <= dinb;
  doutb <= dly_doutb;
  core_web <= web(0);
  core_b_ce <= b_ce and enb(0);
  sinitb <= rstb(0) and b_ce;
  comp0: if ((core_name0 = "bmg_72_3673c2b46bfb142f")) generate
    core_instance0: bmg_72_3673c2b46bfb142f
      port map (
          addra => core_addra,
        clka => a_clk,
        addrb => core_addrb,
        clkb => b_clk,
        dina => core_dina,
        wea(0) => core_wea,
        dinb => core_dinb,
        web(0) => core_web,
        ena => core_a_ce,
        enb => core_b_ce,
        douta => core_douta,
        doutb => core_doutb
      );
  end generate;
  latency_test: if (latency > 2) generate
    regA: synth_reg
      generic map (
        width => c_width_a,
        latency => latency - 2
      )
      port map (
        i => core_douta,
        ce => core_a_ce,
        clr => '0',
        clk => a_clk,
        o => dly_douta
      );
    regB: synth_reg
      generic map (
        width => c_width_b,
        latency => latency - 2
      )
      port map (
        i => core_doutb,
        ce => core_b_ce,
        clr => '0',
        clk => b_clk,
        o => dly_doutb
      );
  end generate;
  latency1: if (latency <= 2) generate
    dly_douta <= core_douta;
    dly_doutb <= core_doutb;
  end generate;
end  behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_a99984b20e is
  port (
    d : in std_logic_vector((9 - 1) downto 0);
    q : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_a99984b20e;


architecture behavior of delay_a99984b20e is
  signal d_1_22: std_logic_vector((9 - 1) downto 0);
begin
  d_1_22 <= d;
  q <= d_1_22;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity inverter_e5b38cca3b is
  port (
    ip : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end inverter_e5b38cca3b;


architecture behavior of inverter_e5b38cca3b is
  signal ip_1_26: boolean;
  type array_type_op_mem_22_20 is array (0 to (1 - 1)) of boolean;
  signal op_mem_22_20: array_type_op_mem_22_20 := (
    0 => false);
  signal op_mem_22_20_front_din: boolean;
  signal op_mem_22_20_back: boolean;
  signal op_mem_22_20_push_front_pop_back_en: std_logic;
  signal internal_ip_12_1_bitnot: boolean;
begin
  ip_1_26 <= ((ip) = "1");
  op_mem_22_20_back <= op_mem_22_20(0);
  proc_op_mem_22_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_22_20_push_front_pop_back_en = '1')) then
        op_mem_22_20(0) <= op_mem_22_20_front_din;
      end if;
    end if;
  end process proc_op_mem_22_20;
  internal_ip_12_1_bitnot <= ((not boolean_to_vector(ip_1_26)) = "1");
  op_mem_22_20_push_front_pop_back_en <= '0';
  op <= boolean_to_vector(internal_ip_12_1_bitnot);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_f1ac4bddff is
  port (
    op : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_f1ac4bddff;


architecture behavior of constant_f1ac4bddff is
begin
  op <= "0000000001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_498bc68c14 is
  port (
    op : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_498bc68c14;


architecture behavior of constant_498bc68c14 is
begin
  op <= "0000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_fbc2f0cce1 is
  port (
    op : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_fbc2f0cce1;


architecture behavior of constant_fbc2f0cce1 is
begin
  op <= "1000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_d3720c25c3 is
  port (
    load : in std_logic_vector((1 - 1) downto 0);
    din : in std_logic_vector((10 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_d3720c25c3;


architecture behavior of counter_d3720c25c3 is
  signal load_1_29: boolean;
  signal din_1_35: unsigned((10 - 1) downto 0);
  signal en_1_45: boolean;
  signal count_reg_20_23_next: unsigned((10 - 1) downto 0);
  signal count_reg_20_23: unsigned((10 - 1) downto 0) := "0000000000";
  signal count_reg_20_23_en: std_logic;
  signal cast_54_19: signed((12 - 1) downto 0);
  signal count_reg_54_7_addsub: signed((12 - 1) downto 0);
  signal count_reg_join_48_3: signed((12 - 1) downto 0);
  signal count_reg_join_44_1: signed((12 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal cast_count_reg_20_23_next: unsigned((10 - 1) downto 0);
begin
  load_1_29 <= ((load) = "1");
  din_1_35 <= std_logic_vector_to_unsigned(din);
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23_next;
      end if;
    end if;
  end process proc_count_reg_20_23;
  cast_54_19 <= u2s_cast(count_reg_20_23, 0, 12, 0);
  count_reg_54_7_addsub <= cast_54_19 - std_logic_vector_to_signed("000000000001");
  proc_if_48_3: process (count_reg_54_7_addsub, din_1_35, load_1_29)
  is
  begin
    if load_1_29 then
      count_reg_join_48_3 <= u2s_cast(din_1_35, 0, 12, 0);
    else 
      count_reg_join_48_3 <= count_reg_54_7_addsub;
    end if;
  end process proc_if_48_3;
  proc_if_44_1: process (count_reg_join_48_3, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    count_reg_join_44_1 <= count_reg_join_48_3;
  end process proc_if_44_1;
  cast_count_reg_20_23_next <= s2u_cast(count_reg_join_44_1, 0, 10, 0);
  count_reg_20_23_next <= cast_count_reg_20_23_next;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_0ffd72e037 is
  port (
    a : in std_logic_vector((10 - 1) downto 0);
    b : in std_logic_vector((10 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_0ffd72e037;


architecture behavior of relational_0ffd72e037 is
  signal a_1_31: unsigned((10 - 1) downto 0);
  signal b_1_34: unsigned((10 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_f6702ea2f7 is
  port (
    a : in std_logic_vector((10 - 1) downto 0);
    b : in std_logic_vector((10 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_f6702ea2f7;


architecture behavior of relational_f6702ea2f7 is
  signal a_1_31: unsigned((10 - 1) downto 0);
  signal b_1_34: unsigned((10 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_6104cbef7a is
  port (
    d : in std_logic_vector((9 - 1) downto 0);
    q : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_6104cbef7a;


architecture behavior of delay_6104cbef7a is
  signal d_1_22: std_logic_vector((9 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((9 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000",
    "000000000");
  signal op_mem_20_24_front_din: std_logic_vector((9 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((9 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_7439478232 is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_7439478232;


architecture behavior of delay_7439478232 is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (5 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(4);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 4 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_a14e3dd1bd is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_a14e3dd1bd;


architecture behavior of delay_a14e3dd1bd is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (5 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0',
    '0',
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(4);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 4 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_c839fa4342 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((9 - 1) downto 0);
    d1 : in std_logic_vector((9 - 1) downto 0);
    y : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_c839fa4342;


architecture behavior of mux_c839fa4342 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((9 - 1) downto 0);
  signal d1_1_27: std_logic_vector((9 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((9 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "000000000");
  signal pipe_16_22_front_din: std_logic_vector((9 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((9 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((9 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_9f61b180a8 is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_9f61b180a8;


architecture behavior of counter_9f61b180a8 is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((1 - 1) downto 0) := "0";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal count_reg_join_44_1: signed((3 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
  signal rst_limit_join_44_1: boolean;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "0";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 - std_logic_vector_to_unsigned("1");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_65704f220d is
  port (
    a : in std_logic_vector((36 - 1) downto 0);
    b : in std_logic_vector((36 - 1) downto 0);
    s : out std_logic_vector((26 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_65704f220d;


architecture behavior of addsub_65704f220d is
  signal a_17_32: signed((36 - 1) downto 0);
  signal b_17_35: signed((36 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((26 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000000000000000");
  signal op_mem_91_20_front_din: signed((26 - 1) downto 0);
  signal op_mem_91_20_back: signed((26 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((37 - 1) downto 0);
  signal cast_69_22: signed((37 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((37 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((26 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 24, 37, 24);
  cast_69_22 <= s2s_cast(b_17_35, 24, 37, 24);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_69_5_addsub, 24, 26, 24);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_9c042fac90 is
  port (
    op : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_9c042fac90;


architecture behavior of counter_9c042fac90 is
  signal count_reg_20_23: unsigned((10 - 1) downto 0) := "0000000000";
  signal count_reg_20_23_rst: std_logic;
  signal rel_34_8: boolean;
  signal rst_limit_join_34_5: boolean;
  signal bool_44_4: boolean;
  signal count_reg_join_44_1: unsigned((11 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
  signal rst_limit_join_44_1: boolean;
begin
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "0000000000";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("0000000001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  rel_34_8 <= count_reg_20_23 = std_logic_vector_to_unsigned("1111111101");
  proc_if_34_5: process (rel_34_8)
  is
  begin
    if rel_34_8 then
      rst_limit_join_34_5 <= true;
    else 
      rst_limit_join_34_5 <= false;
    end if;
  end process proc_if_34_5;
  bool_44_4 <= false or rst_limit_join_34_5;
  proc_if_44_1: process (bool_44_4, count_reg_20_23, rst_limit_join_34_5)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= rst_limit_join_34_5;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_118598964d is
  port (
    op : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_118598964d;


architecture behavior of constant_118598964d is
begin
  op <= "00000000001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_a3923dd146 is
  port (
    op : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_a3923dd146;


architecture behavior of constant_a3923dd146 is
begin
  op <= "00000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_0604807f72 is
  port (
    op : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_0604807f72;


architecture behavior of constant_0604807f72 is
begin
  op <= "10000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_b5e433c475 is
  port (
    load : in std_logic_vector((1 - 1) downto 0);
    din : in std_logic_vector((11 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_b5e433c475;


architecture behavior of counter_b5e433c475 is
  signal load_1_29: boolean;
  signal din_1_35: unsigned((11 - 1) downto 0);
  signal en_1_45: boolean;
  signal count_reg_20_23_next: unsigned((11 - 1) downto 0);
  signal count_reg_20_23: unsigned((11 - 1) downto 0) := "00000000000";
  signal count_reg_20_23_en: std_logic;
  signal cast_54_19: signed((13 - 1) downto 0);
  signal count_reg_54_7_addsub: signed((13 - 1) downto 0);
  signal count_reg_join_48_3: signed((13 - 1) downto 0);
  signal count_reg_join_44_1: signed((13 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal cast_count_reg_20_23_next: unsigned((11 - 1) downto 0);
begin
  load_1_29 <= ((load) = "1");
  din_1_35 <= std_logic_vector_to_unsigned(din);
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23_next;
      end if;
    end if;
  end process proc_count_reg_20_23;
  cast_54_19 <= u2s_cast(count_reg_20_23, 0, 13, 0);
  count_reg_54_7_addsub <= cast_54_19 - std_logic_vector_to_signed("0000000000001");
  proc_if_48_3: process (count_reg_54_7_addsub, din_1_35, load_1_29)
  is
  begin
    if load_1_29 then
      count_reg_join_48_3 <= u2s_cast(din_1_35, 0, 13, 0);
    else 
      count_reg_join_48_3 <= count_reg_54_7_addsub;
    end if;
  end process proc_if_48_3;
  proc_if_44_1: process (count_reg_join_48_3, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    count_reg_join_44_1 <= count_reg_join_48_3;
  end process proc_if_44_1;
  cast_count_reg_20_23_next <= s2u_cast(count_reg_join_44_1, 0, 11, 0);
  count_reg_20_23_next <= cast_count_reg_20_23_next;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_2147430058 is
  port (
    a : in std_logic_vector((11 - 1) downto 0);
    b : in std_logic_vector((11 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_2147430058;


architecture behavior of relational_2147430058 is
  signal a_1_31: unsigned((11 - 1) downto 0);
  signal b_1_34: unsigned((11 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_b4b277ae0f is
  port (
    a : in std_logic_vector((11 - 1) downto 0);
    b : in std_logic_vector((11 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_b4b277ae0f;


architecture behavior of relational_b4b277ae0f is
  signal a_1_31: unsigned((11 - 1) downto 0);
  signal b_1_34: unsigned((11 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_120751dc4b is
  port (
    input_port : in std_logic_vector((18 - 1) downto 0);
    output_port : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_120751dc4b;


architecture behavior of reinterpret_120751dc4b is
  signal input_port_1_40: signed((18 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port <= signed_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_f01f7ce486 is
  port (
    ip : in std_logic_vector((26 - 1) downto 0);
    op : out std_logic_vector((26 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_f01f7ce486;


architecture behavior of scale_f01f7ce486 is
  signal ip_17_23: signed((26 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_dfe2dded7f is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_dfe2dded7f;


architecture behavior of logical_dfe2dded7f is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal bit_2_26: std_logic;
  signal fully_2_1_bitnot: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  bit_2_26 <= d0_1_24 or d1_1_27;
  fully_2_1_bitnot <= not bit_2_26;
  y <= std_logic_to_vector(fully_2_1_bitnot);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_b9651d0357 is
  port (
    a : in std_logic_vector((36 - 1) downto 0);
    b : in std_logic_vector((36 - 1) downto 0);
    s : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_b9651d0357;


architecture behavior of addsub_b9651d0357 is
  signal a_17_32: signed((36 - 1) downto 0);
  signal b_17_35: signed((36 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (2 - 1)) of unsigned((36 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_91_20_front_din: unsigned((36 - 1) downto 0);
  signal op_mem_91_20_back: unsigned((36 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (2 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    "0",
    "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((37 - 1) downto 0);
  signal cast_69_22: signed((37 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((37 - 1) downto 0);
  signal cast_internal_s_83_3_convert: unsigned((36 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(1);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_91_20(i) <= op_mem_91_20(i-1);
        end loop;
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(1);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        for i_x_000000 in 1 downto 1 loop 
          cout_mem_92_22(i_x_000000) <= cout_mem_92_22(i_x_000000-1);
        end loop;
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 34, 37, 34);
  cast_69_22 <= s2s_cast(b_17_35, 34, 37, 34);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  cast_internal_s_83_3_convert <= s2u_cast(internal_s_69_5_addsub, 34, 36, 35);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= unsigned_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_9a68cae5d5 is
  port (
    op : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_9a68cae5d5;


architecture behavior of counter_9a68cae5d5 is
  signal count_reg_20_23: unsigned((10 - 1) downto 0) := "0000000000";
  signal count_reg_20_23_rst: std_logic;
  signal rel_34_8: boolean;
  signal rst_limit_join_34_5: boolean;
  signal bool_44_4: boolean;
  signal count_reg_join_44_1: unsigned((11 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
  signal rst_limit_join_44_1: boolean;
begin
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "0000000000";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("0000000001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  rel_34_8 <= count_reg_20_23 = std_logic_vector_to_unsigned("1111111011");
  proc_if_34_5: process (rel_34_8)
  is
  begin
    if rel_34_8 then
      rst_limit_join_34_5 <= true;
    else 
      rst_limit_join_34_5 <= false;
    end if;
  end process proc_if_34_5;
  bool_44_4 <= false or rst_limit_join_34_5;
  proc_if_44_1: process (bool_44_4, count_reg_20_23, rst_limit_join_34_5)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= rst_limit_join_34_5;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_c962367f4b is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_c962367f4b;


architecture behavior of counter_c962367f4b is
  signal rst_1_40: boolean;
  signal en_1_45: boolean;
  signal count_reg_20_23: unsigned((11 - 1) downto 0) := "00000000000";
  signal count_reg_20_23_rst: std_logic;
  signal count_reg_20_23_en: std_logic;
  signal bool_44_4: boolean;
  signal count_reg_join_44_1: unsigned((12 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal count_reg_join_44_1_rst: std_logic;
  signal rst_limit_join_44_1: boolean;
begin
  rst_1_40 <= ((rst) = "1");
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "00000000000";
      elsif ((ce = '1') and (count_reg_20_23_en = '1')) then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("00000000001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23, en_1_45)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    elsif en_1_45 then
      count_reg_join_44_1_rst <= '0';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    elsif en_1_45 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_e8b4940472 is
  port (
    a : in std_logic_vector((36 - 1) downto 0);
    b : in std_logic_vector((64 - 1) downto 0);
    s : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_e8b4940472;


architecture behavior of addsub_e8b4940472 is
  signal a_17_32: unsigned((36 - 1) downto 0);
  signal b_17_35: unsigned((64 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (2 - 1)) of unsigned((64 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    "0000000000000000000000000000000000000000000000000000000000000000",
    "0000000000000000000000000000000000000000000000000000000000000000");
  signal op_mem_91_20_front_din: unsigned((64 - 1) downto 0);
  signal op_mem_91_20_back: unsigned((64 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (2 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    "0",
    "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: unsigned((66 - 1) downto 0);
  signal cast_69_22: unsigned((66 - 1) downto 0);
  signal internal_s_69_5_addsub: unsigned((66 - 1) downto 0);
  signal cast_internal_s_83_3_convert: unsigned((64 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_unsigned(a);
  b_17_35 <= std_logic_vector_to_unsigned(b);
  op_mem_91_20_back <= op_mem_91_20(1);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_91_20(i) <= op_mem_91_20(i-1);
        end loop;
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(1);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        for i_x_000000 in 1 downto 1 loop 
          cout_mem_92_22(i_x_000000) <= cout_mem_92_22(i_x_000000-1);
        end loop;
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= u2u_cast(a_17_32, 35, 66, 35);
  cast_69_22 <= u2u_cast(b_17_35, 34, 66, 35);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  cast_internal_s_83_3_convert <= u2u_cast(internal_s_69_5_addsub, 35, 64, 34);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= unsigned_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_c4c603edf2 is
  port (
    op : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_c4c603edf2;


architecture behavior of constant_c4c603edf2 is
begin
  op <= "0000000000000000000000000000000000000000000000000000000000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_66e06093b2 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((64 - 1) downto 0);
    d1 : in std_logic_vector((64 - 1) downto 0);
    y : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_66e06093b2;


architecture behavior of mux_66e06093b2 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((64 - 1) downto 0);
  signal d1_1_27: std_logic_vector((64 - 1) downto 0);
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((64 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  y <= unregy_join_6_1;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_49cb1051e0 is
  port (
    d : in std_logic_vector((11 - 1) downto 0);
    q : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_49cb1051e0;


architecture behavior of delay_49cb1051e0 is
  signal d_1_22: std_logic_vector((11 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((11 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "00000000000");
  signal op_mem_20_24_front_din: std_logic_vector((11 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((11 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_b6092ad150 is
  port (
    d : in std_logic_vector((18 - 1) downto 0);
    q : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_b6092ad150;


architecture behavior of delay_b6092ad150 is
  signal d_1_22: std_logic_vector((18 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((18 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((18 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((18 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_ec5089319a is
  port (
    d : in std_logic_vector((16 - 1) downto 0);
    q : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_ec5089319a;


architecture behavior of delay_ec5089319a is
  signal d_1_22: std_logic_vector((16 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((16 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0000000000000000",
    "0000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((16 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((16 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.6 VHDL source file.
--
-- Copyright(C) 2013 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2013 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
-- synopsys translate_off
library unisim;
use unisim.vcomponents.all;
-- synopsys translate_on
entity xldsamp is
  generic (
    d_width: integer := 12;
    d_bin_pt: integer := 0;
    d_arith: integer := xlUnsigned;
    q_width: integer := 12;
    q_bin_pt: integer := 0;
    q_arith: integer := xlUnsigned;
    en_width: integer := 1;
    en_bin_pt: integer := 0;
    en_arith: integer := xlUnsigned;
    ds_ratio: integer := 2;
    phase: integer := 0;
    latency: integer := 1
  );
  port (
    d: in std_logic_vector(d_width - 1 downto 0);
    src_clk: in std_logic;
    src_ce: in std_logic;
    src_clr: in std_logic;
    dest_clk: in std_logic;
    dest_ce: in std_logic;
    dest_clr: in std_logic;
    en: in std_logic_vector(en_width - 1 downto 0);
    q: out std_logic_vector(q_width - 1 downto 0)
  );
end xldsamp;
architecture struct of xldsamp is
  component synth_reg
    generic (
      width: integer := 16;
      latency: integer := 5
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  component fdse
    port (
      q: out   std_ulogic;
      d: in    std_ulogic;
      c: in    std_ulogic;
      s: in    std_ulogic;
      ce: in    std_ulogic
    );
  end component;
  attribute syn_black_box of fdse: component is true;
  attribute fpga_dont_touch of fdse: component is "true";
  signal adjusted_dest_ce: std_logic;
  signal adjusted_dest_ce_w_en: std_logic;
  signal dest_ce_w_en: std_logic;
  signal smpld_d: std_logic_vector(d_width-1 downto 0);
begin
  adjusted_ce_needed: if ((latency = 0) or (phase /= (ds_ratio - 1))) generate
    dest_ce_reg: fdse
      port map (
        q => adjusted_dest_ce,
        d => dest_ce,
        c => src_clk,
        s => src_clr,
        ce => src_ce
      );
  end generate;
  latency_eq_0: if (latency = 0) generate
    shutter_d_reg: synth_reg
      generic map (
        width => d_width,
        latency => 1
      )
      port map (
        i => d,
        ce => adjusted_dest_ce,
        clr => src_clr,
        clk => src_clk,
        o => smpld_d
      );
    shutter_mux: process (adjusted_dest_ce, d, smpld_d)
    begin
      if adjusted_dest_ce = '0' then
        q <= smpld_d;
      else
        q <= d;
      end if;
    end process;
  end generate;
  latency_gt_0: if (latency > 0) generate
    dbl_reg_test: if (phase /= (ds_ratio-1)) generate
        smpl_d_reg: synth_reg
          generic map (
            width => d_width,
            latency => 1
          )
          port map (
            i => d,
            ce => adjusted_dest_ce_w_en,
            clr => src_clr,
            clk => src_clk,
            o => smpld_d
          );
    end generate;
    sngl_reg_test: if (phase = (ds_ratio -1)) generate
      smpld_d <= d;
    end generate;
    latency_pipe: synth_reg
      generic map (
        width => d_width,
        latency => latency
      )
      port map (
        i => smpld_d,
        ce => dest_ce_w_en,
        clr => src_clr,
        clk => dest_clk,
        o => q
      );
  end generate;
  dest_ce_w_en <= dest_ce and en(0);
  adjusted_dest_ce_w_en <= adjusted_dest_ce and en(0);
end architecture struct;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity xlfir_compiler_fe9d317252ca97985c8e1f77f6cc0a64 is 
  port(
    ce:in std_logic;
    ce_50:in std_logic;
    ce_logic_1:in std_logic;
    clk:in std_logic;
    clk_50:in std_logic;
    clk_logic_1:in std_logic;
    din:in std_logic_vector(15 downto 0);
    dout:out std_logic_vector(17 downto 0);
    rdy:out std_logic;
    rfd:out std_logic;
    src_ce:in std_logic;
    src_clk:in std_logic
  );
end xlfir_compiler_fe9d317252ca97985c8e1f77f6cc0a64;


architecture behavior of xlfir_compiler_fe9d317252ca97985c8e1f77f6cc0a64  is
  component fr_cmplr_v5_0_5d372747691e47c4
    port(
      ce:in std_logic;
      clk:in std_logic;
      din:in std_logic_vector(15 downto 0);
      dout:out std_logic_vector(17 downto 0);
      nd:in std_logic;
      rdy:out std_logic;
      rfd:out std_logic
    );
end component;
signal dout_ps_net: std_logic_vector(17 downto 0) := (others=>'0');
signal rdy_ps_net: std_logic := '0';
signal rdy_ps_net_captured: std_logic := '0';
signal rdy_ps_net_or_captured_net: std_logic := '0';
begin
  dout_ps_net_synchronizer : entity work.synth_reg_w_init
    generic map(
        width => 18,
        init_index => 0,
        init_value => "0",
        latency => 1
    )
    port map (
        i => dout_ps_net,
        ce => ce_50,
        clr => '0',
        clk => clk_50, 
        o => dout
    );
  rdy_ps_net_or_captured_net <= rdy_ps_net or rdy_ps_net_captured;
rdy_ps_net_synchronizer_1 : entity work.synth_reg_w_init
    generic map(
        width => 1,
        init_index => 0,
        init_value => "0",
        latency => 1
    )
    port map (
        i(0) => rdy_ps_net_or_captured_net,
        ce => ce_50,
        clr => '0',
        clk => clk_50, 
        o(0) => rdy
    );
rdy_ps_net_synchronizer_2 : entity work.synth_reg_w_init
    generic map(
        width => 1,
        init_index => 0,
        init_value => "0",
        latency => 1
    )
    port map (
        i(0) => '1',
        ce => rdy_ps_net,
        clr => '0',
        clk => clk_50, 
        o(0) => rdy_ps_net_captured
    );
  fr_cmplr_v5_0_5d372747691e47c4_instance : fr_cmplr_v5_0_5d372747691e47c4
    port map(
      ce=>ce,
      clk=>clk,
      din=>din,
      dout=>dout_ps_net,
      nd=>ce_logic_1,
      rdy=>rdy_ps_net,
      rfd=>rfd
    );
end  behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_a6d07705dd is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    d2 : in std_logic_vector((1 - 1) downto 0);
    d3 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_a6d07705dd;


architecture behavior of logical_a6d07705dd is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal d2_1_30: std_logic;
  signal d3_1_33: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  d2_1_30 <= d2(0);
  d3_1_33 <= d3(0);
  fully_2_1_bit <= d0_1_24 or d1_1_27 or d2_1_30 or d3_1_33;
  y <= std_logic_to_vector(fully_2_1_bit);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_0b0063065e is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((18 - 1) downto 0);
    d1 : in std_logic_vector((18 - 1) downto 0);
    y : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_0b0063065e;


architecture behavior of mux_0b0063065e is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((18 - 1) downto 0);
  signal d1_1_27: std_logic_vector((18 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((18 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  y <= unregy_join_6_1;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_e1b91ef670 is
  port (
    a : in std_logic_vector((16 - 1) downto 0);
    b : in std_logic_vector((32 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_e1b91ef670;


architecture behavior of relational_e1b91ef670 is
  signal a_1_31: signed((16 - 1) downto 0);
  signal b_1_34: unsigned((32 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal cast_12_12: signed((48 - 1) downto 0);
  signal cast_12_17: signed((48 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_signed(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  cast_12_12 <= s2s_cast(a_1_31, 15, 48, 15);
  cast_12_17 <= u2s_cast(b_1_34, 0, 48, 15);
  result_12_3_rel <= cast_12_12 = cast_12_17;
  op_mem_32_22_front_din <= result_12_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_1/Shared_BRAM/calc_add"

entity calc_add_entity_c24bfeccac is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(15 downto 0); 
    out_x0: out std_logic_vector(9 downto 0)
  );
end calc_add_entity_c24bfeccac;

architecture structural of calc_add_entity_c24bfeccac is
  signal add_sub_s_net: std_logic;
  signal ce_1_sg_x0: std_logic;
  signal clk_1_sg_x0: std_logic;
  signal concat_y_net: std_logic_vector(9 downto 0);
  signal const_op_net: std_logic;
  signal convert_addr_dout_net: std_logic_vector(9 downto 0);
  signal delay80_q_net_x0: std_logic_vector(15 downto 0);
  signal lsw_y_net: std_logic;
  signal manipulate_op_net: std_logic;
  signal msw_y_net: std_logic_vector(8 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);

begin
  ce_1_sg_x0 <= ce_1;
  clk_1_sg_x0 <= clk_1;
  delay80_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x0;

  add_sub: entity work.addsub_c13097e33e
    port map (
      a(0) => const_op_net,
      b(0) => lsw_y_net,
      ce => ce_1_sg_x0,
      clk => clk_1_sg_x0,
      clr => '0',
      s(0) => add_sub_s_net
    );

  concat: entity work.concat_1d98d96b58
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => msw_y_net,
      in1(0) => add_sub_s_net,
      y => concat_y_net
    );

  const: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => const_op_net
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 15,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x0,
      clk => clk_1_sg_x0,
      clr => '0',
      din => delay80_q_net_x0,
      en => "1",
      dout => convert_addr_dout_net
    );

  lsw: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 10,
      y_width => 1
    )
    port map (
      x => convert_addr_dout_net,
      y(0) => lsw_y_net
    );

  manipulate: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => manipulate_op_net
    );

  msw: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 9,
      x_width => 10,
      y_width => 9
    )
    port map (
      x => convert_addr_dout_net,
      y => msw_y_net
    );

  mux: entity work.mux_4fe5face7f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => convert_addr_dout_net,
      d1 => concat_y_net,
      sel(0) => manipulate_op_net,
      y => mux_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_1/Shared_BRAM/munge_in"

entity munge_in_entity_6927a14d9a is
  port (
    din: in std_logic_vector(15 downto 0); 
    dout: out std_logic_vector(15 downto 0)
  );
end munge_in_entity_6927a14d9a;

architecture structural of munge_in_entity_6927a14d9a is
  signal constant10_op_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(15 downto 0);

begin
  constant10_op_net_x0 <= din;
  dout <= reinterpret_out_output_port_net_x0;

  reinterpret_out: entity work.reinterpret_ddc3ebdd7c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => constant10_op_net_x0,
      output_port => reinterpret_out_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_1/Shared_BRAM/munge_out"

entity munge_out_entity_142a6ee39c is
  port (
    din: in std_logic_vector(31 downto 0); 
    dout: out std_logic_vector(31 downto 0)
  );
end munge_out_entity_142a6ee39c;

architecture structural of munge_out_entity_142a6ee39c is
  signal reinterpret_out_output_port_net_x0: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x0: std_logic_vector(31 downto 0);

begin
  window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x0 <= din;
  dout <= reinterpret_out_output_port_net_x0;

  reinterpret_out: entity work.reinterpret_dc139e7f7a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x0,
      output_port => reinterpret_out_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_1/Shared_BRAM"

entity shared_bram_entity_64045b8848 is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(15 downto 0); 
    we: in std_logic_vector(15 downto 0); 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end shared_bram_entity_64045b8848;

architecture structural of shared_bram_entity_64045b8848 is
  signal ce_1_sg_x1: std_logic;
  signal clk_1_sg_x1: std_logic;
  signal constant10_op_net_x1: std_logic_vector(15 downto 0);
  signal constant9_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal delay80_q_net_x1: std_logic_vector(15 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x1: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x1 <= addr;
  ce_1_sg_x1 <= ce_1;
  clk_1_sg_x1 <= clk_1;
  constant10_op_net_x1 <= data_in;
  constant9_op_net_x0 <= we;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x1 <= window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_c24bfeccac: entity work.calc_add_entity_c24bfeccac
    port map (
      ce_1 => ce_1_sg_x1,
      clk_1 => clk_1_sg_x1,
      in_x0 => delay80_q_net_x1,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1,
      clk => clk_1_sg_x1,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1,
      clk => clk_1_sg_x1,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1,
      clk => clk_1_sg_x1,
      clr => '0',
      din => constant9_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_6927a14d9a: entity work.munge_in_entity_6927a14d9a
    port map (
      din => constant10_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_142a6ee39c: entity work.munge_out_entity_142a6ee39c
    port map (
      din => window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_1/Shared_BRAM1"

entity shared_bram1_entity_437df20cb4 is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(15 downto 0); 
    we: in std_logic_vector(15 downto 0); 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end shared_bram1_entity_437df20cb4;

architecture structural of shared_bram1_entity_437df20cb4 is
  signal ce_1_sg_x3: std_logic;
  signal clk_1_sg_x3: std_logic;
  signal constant1_op_net_x1: std_logic_vector(15 downto 0);
  signal constant2_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal delay80_q_net_x3: std_logic_vector(15 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net_x1: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x3 <= addr;
  ce_1_sg_x3 <= ce_1;
  clk_1_sg_x3 <= clk_1;
  constant1_op_net_x1 <= data_in;
  constant2_op_net_x0 <= we;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net_x1 <= window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_7582733773: entity work.calc_add_entity_c24bfeccac
    port map (
      ce_1 => ce_1_sg_x3,
      clk_1 => clk_1_sg_x3,
      in_x0 => delay80_q_net_x3,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x3,
      clk => clk_1_sg_x3,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x3,
      clk => clk_1_sg_x3,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x3,
      clk => clk_1_sg_x3,
      clr => '0',
      din => constant2_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_ccc09b800d: entity work.munge_in_entity_6927a14d9a
    port map (
      din => constant1_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_790aac6bb2: entity work.munge_out_entity_142a6ee39c
    port map (
      din => window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_1"

entity lo_1_entity_f9b742d2f1 is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pol1: in std_logic_vector(7 downto 0); 
    pol2: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    pol1_im: out std_logic_vector(15 downto 0); 
    pol1_re: out std_logic_vector(15 downto 0); 
    pol2_im: out std_logic_vector(15 downto 0); 
    pol2_re: out std_logic_vector(15 downto 0); 
    shared_bram: out std_logic_vector(9 downto 0); 
    shared_bram1: out std_logic_vector(9 downto 0); 
    shared_bram1_x0: out std_logic_vector(31 downto 0); 
    shared_bram1_x1: out std_logic; 
    shared_bram1_x2: out std_logic_vector(31 downto 0); 
    shared_bram_x0: out std_logic_vector(31 downto 0); 
    shared_bram_x1: out std_logic; 
    shared_bram_x2: out std_logic_vector(31 downto 0)
  );
end lo_1_entity_f9b742d2f1;

architecture structural of lo_1_entity_f9b742d2f1 is
  signal ce_1_sg_x4: std_logic;
  signal clk_1_sg_x4: std_logic;
  signal constant10_op_net_x1: std_logic_vector(15 downto 0);
  signal constant1_op_net_x1: std_logic_vector(15 downto 0);
  signal constant2_op_net_x0: std_logic_vector(15 downto 0);
  signal constant9_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x2: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x3: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x3: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal convert_we_dout_net_x3: std_logic;
  signal delay32_q_net: std_logic_vector(7 downto 0);
  signal delay33_q_net: std_logic_vector(31 downto 0);
  signal delay34_q_net: std_logic_vector(7 downto 0);
  signal delay35_q_net: std_logic_vector(31 downto 0);
  signal delay36_q_net: std_logic_vector(7 downto 0);
  signal delay37_q_net: std_logic_vector(31 downto 0);
  signal delay38_q_net: std_logic_vector(7 downto 0);
  signal delay39_q_net: std_logic_vector(31 downto 0);
  signal delay80_q_net_x0: std_logic_vector(15 downto 0);
  signal delay80_q_net_x4: std_logic_vector(15 downto 0);
  signal delay81_q_net_x0: std_logic_vector(15 downto 0);
  signal delay82_q_net_x0: std_logic_vector(15 downto 0);
  signal delay83_q_net_x0: std_logic_vector(15 downto 0);
  signal mult16_p_net: std_logic_vector(15 downto 0);
  signal mult1_p_net: std_logic_vector(15 downto 0);
  signal mult2_p_net: std_logic_vector(15 downto 0);
  signal mult3_p_net: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x4: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x5: std_logic_vector(31 downto 0);
  signal reinterpret_output_port_net_x1: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x2: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x2: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x4 <= addr;
  ce_1_sg_x4 <= ce_1;
  clk_1_sg_x4 <= clk_1;
  reinterpret_output_port_net_x1 <= pol1;
  reinterpret_output_port_net_x2 <= pol2;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net_x2 <= window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x2 <= window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out;
  pol1_im <= delay80_q_net_x0;
  pol1_re <= delay82_q_net_x0;
  pol2_im <= delay81_q_net_x0;
  pol2_re <= delay83_q_net_x0;
  shared_bram <= convert_addr_dout_net_x2;
  shared_bram1 <= convert_addr_dout_net_x3;
  shared_bram1_x0 <= convert_din1_dout_net_x3;
  shared_bram1_x1 <= convert_we_dout_net_x3;
  shared_bram1_x2 <= reinterpret_out_output_port_net_x5;
  shared_bram_x0 <= convert_din1_dout_net_x2;
  shared_bram_x1 <= convert_we_dout_net_x2;
  shared_bram_x2 <= reinterpret_out_output_port_net_x4;

  constant1: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net_x1
    );

  constant10: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant10_op_net_x1
    );

  constant2: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net_x0
    );

  constant9: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant9_op_net_x0
    );

  delay32: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => reinterpret_output_port_net_x1,
      q => delay32_q_net
    );

  delay33: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => reinterpret_out_output_port_net_x4,
      q => delay33_q_net
    );

  delay34: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => reinterpret_output_port_net_x2,
      q => delay34_q_net
    );

  delay35: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => reinterpret_out_output_port_net_x4,
      q => delay35_q_net
    );

  delay36: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => reinterpret_output_port_net_x1,
      q => delay36_q_net
    );

  delay37: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => reinterpret_out_output_port_net_x5,
      q => delay37_q_net
    );

  delay38: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => reinterpret_output_port_net_x2,
      q => delay38_q_net
    );

  delay39: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => reinterpret_out_output_port_net_x5,
      q => delay39_q_net
    );

  delay80: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => mult16_p_net,
      q => delay80_q_net_x0
    );

  delay81: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => mult1_p_net,
      q => delay81_q_net_x0
    );

  delay82: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => mult2_p_net,
      q => delay82_q_net_x0
    );

  delay83: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      d => mult3_p_net,
      q => delay83_q_net_x0
    );

  mult1: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay34_q_net,
      b => delay35_q_net,
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      core_ce => ce_1_sg_x4,
      core_clk => clk_1_sg_x4,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult1_p_net
    );

  mult16: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay32_q_net,
      b => delay33_q_net,
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      core_ce => ce_1_sg_x4,
      core_clk => clk_1_sg_x4,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult16_p_net
    );

  mult2: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay36_q_net,
      b => delay37_q_net,
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      core_ce => ce_1_sg_x4,
      core_clk => clk_1_sg_x4,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult2_p_net
    );

  mult3: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay38_q_net,
      b => delay39_q_net,
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      core_ce => ce_1_sg_x4,
      core_clk => clk_1_sg_x4,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult3_p_net
    );

  shared_bram1_437df20cb4: entity work.shared_bram1_entity_437df20cb4
    port map (
      addr => delay80_q_net_x4,
      ce_1 => ce_1_sg_x4,
      clk_1 => clk_1_sg_x4,
      data_in => constant1_op_net_x1,
      we => constant2_op_net_x0,
      window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net_x2,
      convert_addr_x0 => convert_addr_dout_net_x3,
      convert_din1_x0 => convert_din1_dout_net_x3,
      convert_we_x0 => convert_we_dout_net_x3,
      data_out => reinterpret_out_output_port_net_x5
    );

  shared_bram_64045b8848: entity work.shared_bram_entity_64045b8848
    port map (
      addr => delay80_q_net_x4,
      ce_1 => ce_1_sg_x4,
      clk_1 => clk_1_sg_x4,
      data_in => constant10_op_net_x1,
      we => constant9_op_net_x0,
      window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x2,
      convert_addr_x0 => convert_addr_dout_net_x2,
      convert_din1_x0 => convert_din1_dout_net_x2,
      convert_we_x0 => convert_we_dout_net_x2,
      data_out => reinterpret_out_output_port_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_2/Shared_BRAM"

entity shared_bram_entity_06e2c7c22b is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(15 downto 0); 
    we: in std_logic_vector(15 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end shared_bram_entity_06e2c7c22b;

architecture structural of shared_bram_entity_06e2c7c22b is
  signal ce_1_sg_x6: std_logic;
  signal clk_1_sg_x6: std_logic;
  signal constant10_op_net_x1: std_logic_vector(15 downto 0);
  signal constant9_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal delay80_q_net_x6: std_logic_vector(15 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net_x1: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x6 <= addr;
  ce_1_sg_x6 <= ce_1;
  clk_1_sg_x6 <= clk_1;
  constant10_op_net_x1 <= data_in;
  constant9_op_net_x0 <= we;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net_x1 <= window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_a4587ced5d: entity work.calc_add_entity_c24bfeccac
    port map (
      ce_1 => ce_1_sg_x6,
      clk_1 => clk_1_sg_x6,
      in_x0 => delay80_q_net_x6,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x6,
      clk => clk_1_sg_x6,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x6,
      clk => clk_1_sg_x6,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x6,
      clk => clk_1_sg_x6,
      clr => '0',
      din => constant9_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_448371a1ff: entity work.munge_in_entity_6927a14d9a
    port map (
      din => constant10_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_9fa5b1ab55: entity work.munge_out_entity_142a6ee39c
    port map (
      din => window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_2/Shared_BRAM1"

entity shared_bram1_entity_f495206c05 is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(15 downto 0); 
    we: in std_logic_vector(15 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end shared_bram1_entity_f495206c05;

architecture structural of shared_bram1_entity_f495206c05 is
  signal ce_1_sg_x8: std_logic;
  signal clk_1_sg_x8: std_logic;
  signal constant1_op_net_x1: std_logic_vector(15 downto 0);
  signal constant2_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal delay80_q_net_x8: std_logic_vector(15 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net_x1: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x8 <= addr;
  ce_1_sg_x8 <= ce_1;
  clk_1_sg_x8 <= clk_1;
  constant1_op_net_x1 <= data_in;
  constant2_op_net_x0 <= we;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net_x1 <= window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_b3121f6815: entity work.calc_add_entity_c24bfeccac
    port map (
      ce_1 => ce_1_sg_x8,
      clk_1 => clk_1_sg_x8,
      in_x0 => delay80_q_net_x8,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x8,
      clk => clk_1_sg_x8,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x8,
      clk => clk_1_sg_x8,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x8,
      clk => clk_1_sg_x8,
      clr => '0',
      din => constant2_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_24e9488364: entity work.munge_in_entity_6927a14d9a
    port map (
      din => constant1_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_45a3f95e75: entity work.munge_out_entity_142a6ee39c
    port map (
      din => window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_2"

entity lo_2_entity_ca2ff53d39 is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pol1: in std_logic_vector(7 downto 0); 
    pol2: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    pol1_im: out std_logic_vector(15 downto 0); 
    pol1_re: out std_logic_vector(15 downto 0); 
    pol2_im: out std_logic_vector(15 downto 0); 
    pol2_re: out std_logic_vector(15 downto 0); 
    shared_bram: out std_logic_vector(9 downto 0); 
    shared_bram1: out std_logic_vector(9 downto 0); 
    shared_bram1_x0: out std_logic_vector(31 downto 0); 
    shared_bram1_x1: out std_logic; 
    shared_bram1_x2: out std_logic_vector(31 downto 0); 
    shared_bram_x0: out std_logic_vector(31 downto 0); 
    shared_bram_x1: out std_logic; 
    shared_bram_x2: out std_logic_vector(31 downto 0)
  );
end lo_2_entity_ca2ff53d39;

architecture structural of lo_2_entity_ca2ff53d39 is
  signal ce_1_sg_x9: std_logic;
  signal clk_1_sg_x9: std_logic;
  signal constant10_op_net_x1: std_logic_vector(15 downto 0);
  signal constant1_op_net_x1: std_logic_vector(15 downto 0);
  signal constant2_op_net_x0: std_logic_vector(15 downto 0);
  signal constant9_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x2: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x3: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x3: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal convert_we_dout_net_x3: std_logic;
  signal delay32_q_net: std_logic_vector(7 downto 0);
  signal delay33_q_net: std_logic_vector(31 downto 0);
  signal delay34_q_net: std_logic_vector(7 downto 0);
  signal delay35_q_net: std_logic_vector(31 downto 0);
  signal delay36_q_net: std_logic_vector(7 downto 0);
  signal delay37_q_net: std_logic_vector(31 downto 0);
  signal delay38_q_net: std_logic_vector(7 downto 0);
  signal delay39_q_net: std_logic_vector(31 downto 0);
  signal delay80_q_net_x0: std_logic_vector(15 downto 0);
  signal delay80_q_net_x9: std_logic_vector(15 downto 0);
  signal delay81_q_net_x0: std_logic_vector(15 downto 0);
  signal delay82_q_net_x0: std_logic_vector(15 downto 0);
  signal delay83_q_net_x0: std_logic_vector(15 downto 0);
  signal mult16_p_net: std_logic_vector(15 downto 0);
  signal mult1_p_net: std_logic_vector(15 downto 0);
  signal mult2_p_net: std_logic_vector(15 downto 0);
  signal mult3_p_net: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x4: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x5: std_logic_vector(31 downto 0);
  signal reinterpret_output_port_net_x1: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x2: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net_x2: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x9 <= addr;
  ce_1_sg_x9 <= ce_1;
  clk_1_sg_x9 <= clk_1;
  reinterpret_output_port_net_x1 <= pol1;
  reinterpret_output_port_net_x2 <= pol2;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net_x2 <= window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net_x2 <= window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out;
  pol1_im <= delay80_q_net_x0;
  pol1_re <= delay82_q_net_x0;
  pol2_im <= delay81_q_net_x0;
  pol2_re <= delay83_q_net_x0;
  shared_bram <= convert_addr_dout_net_x2;
  shared_bram1 <= convert_addr_dout_net_x3;
  shared_bram1_x0 <= convert_din1_dout_net_x3;
  shared_bram1_x1 <= convert_we_dout_net_x3;
  shared_bram1_x2 <= reinterpret_out_output_port_net_x5;
  shared_bram_x0 <= convert_din1_dout_net_x2;
  shared_bram_x1 <= convert_we_dout_net_x2;
  shared_bram_x2 <= reinterpret_out_output_port_net_x4;

  constant1: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net_x1
    );

  constant10: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant10_op_net_x1
    );

  constant2: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net_x0
    );

  constant9: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant9_op_net_x0
    );

  delay32: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => reinterpret_output_port_net_x1,
      q => delay32_q_net
    );

  delay33: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => reinterpret_out_output_port_net_x4,
      q => delay33_q_net
    );

  delay34: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => reinterpret_output_port_net_x2,
      q => delay34_q_net
    );

  delay35: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => reinterpret_out_output_port_net_x4,
      q => delay35_q_net
    );

  delay36: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => reinterpret_output_port_net_x1,
      q => delay36_q_net
    );

  delay37: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => reinterpret_out_output_port_net_x5,
      q => delay37_q_net
    );

  delay38: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => reinterpret_output_port_net_x2,
      q => delay38_q_net
    );

  delay39: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => reinterpret_out_output_port_net_x5,
      q => delay39_q_net
    );

  delay80: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => mult16_p_net,
      q => delay80_q_net_x0
    );

  delay81: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => mult1_p_net,
      q => delay81_q_net_x0
    );

  delay82: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => mult2_p_net,
      q => delay82_q_net_x0
    );

  delay83: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      d => mult3_p_net,
      q => delay83_q_net_x0
    );

  mult1: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay34_q_net,
      b => delay35_q_net,
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      core_ce => ce_1_sg_x9,
      core_clk => clk_1_sg_x9,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult1_p_net
    );

  mult16: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay32_q_net,
      b => delay33_q_net,
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      core_ce => ce_1_sg_x9,
      core_clk => clk_1_sg_x9,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult16_p_net
    );

  mult2: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay36_q_net,
      b => delay37_q_net,
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      core_ce => ce_1_sg_x9,
      core_clk => clk_1_sg_x9,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult2_p_net
    );

  mult3: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay38_q_net,
      b => delay39_q_net,
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      core_ce => ce_1_sg_x9,
      core_clk => clk_1_sg_x9,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult3_p_net
    );

  shared_bram1_f495206c05: entity work.shared_bram1_entity_f495206c05
    port map (
      addr => delay80_q_net_x9,
      ce_1 => ce_1_sg_x9,
      clk_1 => clk_1_sg_x9,
      data_in => constant1_op_net_x1,
      we => constant2_op_net_x0,
      window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net_x2,
      convert_addr_x0 => convert_addr_dout_net_x3,
      convert_din1_x0 => convert_din1_dout_net_x3,
      convert_we_x0 => convert_we_dout_net_x3,
      data_out => reinterpret_out_output_port_net_x5
    );

  shared_bram_06e2c7c22b: entity work.shared_bram_entity_06e2c7c22b
    port map (
      addr => delay80_q_net_x9,
      ce_1 => ce_1_sg_x9,
      clk_1 => clk_1_sg_x9,
      data_in => constant10_op_net_x1,
      we => constant9_op_net_x0,
      window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net_x2,
      convert_addr_x0 => convert_addr_dout_net_x2,
      convert_din1_x0 => convert_din1_dout_net_x2,
      convert_we_x0 => convert_we_dout_net_x2,
      data_out => reinterpret_out_output_port_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_3/Shared_BRAM"

entity shared_bram_entity_9f98093f3b is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(15 downto 0); 
    we: in std_logic_vector(15 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end shared_bram_entity_9f98093f3b;

architecture structural of shared_bram_entity_9f98093f3b is
  signal ce_1_sg_x11: std_logic;
  signal clk_1_sg_x11: std_logic;
  signal constant10_op_net_x1: std_logic_vector(15 downto 0);
  signal constant9_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal delay80_q_net_x11: std_logic_vector(15 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net_x1: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x11 <= addr;
  ce_1_sg_x11 <= ce_1;
  clk_1_sg_x11 <= clk_1;
  constant10_op_net_x1 <= data_in;
  constant9_op_net_x0 <= we;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net_x1 <= window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_0cbe534d0c: entity work.calc_add_entity_c24bfeccac
    port map (
      ce_1 => ce_1_sg_x11,
      clk_1 => clk_1_sg_x11,
      in_x0 => delay80_q_net_x11,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x11,
      clk => clk_1_sg_x11,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x11,
      clk => clk_1_sg_x11,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x11,
      clk => clk_1_sg_x11,
      clr => '0',
      din => constant9_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_923ac9a88a: entity work.munge_in_entity_6927a14d9a
    port map (
      din => constant10_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_27df8a9d47: entity work.munge_out_entity_142a6ee39c
    port map (
      din => window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_3/Shared_BRAM1"

entity shared_bram1_entity_2d0abb7ab3 is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(15 downto 0); 
    we: in std_logic_vector(15 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end shared_bram1_entity_2d0abb7ab3;

architecture structural of shared_bram1_entity_2d0abb7ab3 is
  signal ce_1_sg_x13: std_logic;
  signal clk_1_sg_x13: std_logic;
  signal constant1_op_net_x1: std_logic_vector(15 downto 0);
  signal constant2_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal delay80_q_net_x13: std_logic_vector(15 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net_x1: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x13 <= addr;
  ce_1_sg_x13 <= ce_1;
  clk_1_sg_x13 <= clk_1;
  constant1_op_net_x1 <= data_in;
  constant2_op_net_x0 <= we;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net_x1 <= window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_137af97870: entity work.calc_add_entity_c24bfeccac
    port map (
      ce_1 => ce_1_sg_x13,
      clk_1 => clk_1_sg_x13,
      in_x0 => delay80_q_net_x13,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x13,
      clk => clk_1_sg_x13,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x13,
      clk => clk_1_sg_x13,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x13,
      clk => clk_1_sg_x13,
      clr => '0',
      din => constant2_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_20e54eeeb8: entity work.munge_in_entity_6927a14d9a
    port map (
      din => constant1_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_d28fa40592: entity work.munge_out_entity_142a6ee39c
    port map (
      din => window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_3"

entity lo_3_entity_b9de28fa93 is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pol1: in std_logic_vector(7 downto 0); 
    pol2: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    pol1_im: out std_logic_vector(15 downto 0); 
    pol1_re: out std_logic_vector(15 downto 0); 
    pol2_im: out std_logic_vector(15 downto 0); 
    pol2_re: out std_logic_vector(15 downto 0); 
    shared_bram: out std_logic_vector(9 downto 0); 
    shared_bram1: out std_logic_vector(9 downto 0); 
    shared_bram1_x0: out std_logic_vector(31 downto 0); 
    shared_bram1_x1: out std_logic; 
    shared_bram1_x2: out std_logic_vector(31 downto 0); 
    shared_bram_x0: out std_logic_vector(31 downto 0); 
    shared_bram_x1: out std_logic; 
    shared_bram_x2: out std_logic_vector(31 downto 0)
  );
end lo_3_entity_b9de28fa93;

architecture structural of lo_3_entity_b9de28fa93 is
  signal ce_1_sg_x14: std_logic;
  signal clk_1_sg_x14: std_logic;
  signal constant10_op_net_x1: std_logic_vector(15 downto 0);
  signal constant1_op_net_x1: std_logic_vector(15 downto 0);
  signal constant2_op_net_x0: std_logic_vector(15 downto 0);
  signal constant9_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x2: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x3: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x3: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal convert_we_dout_net_x3: std_logic;
  signal delay32_q_net: std_logic_vector(7 downto 0);
  signal delay33_q_net: std_logic_vector(31 downto 0);
  signal delay34_q_net: std_logic_vector(7 downto 0);
  signal delay35_q_net: std_logic_vector(31 downto 0);
  signal delay36_q_net: std_logic_vector(7 downto 0);
  signal delay37_q_net: std_logic_vector(31 downto 0);
  signal delay38_q_net: std_logic_vector(7 downto 0);
  signal delay39_q_net: std_logic_vector(31 downto 0);
  signal delay80_q_net_x0: std_logic_vector(15 downto 0);
  signal delay80_q_net_x14: std_logic_vector(15 downto 0);
  signal delay81_q_net_x0: std_logic_vector(15 downto 0);
  signal delay82_q_net_x0: std_logic_vector(15 downto 0);
  signal delay83_q_net_x0: std_logic_vector(15 downto 0);
  signal mult16_p_net: std_logic_vector(15 downto 0);
  signal mult1_p_net: std_logic_vector(15 downto 0);
  signal mult2_p_net: std_logic_vector(15 downto 0);
  signal mult3_p_net: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x4: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x5: std_logic_vector(31 downto 0);
  signal reinterpret_output_port_net_x1: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x2: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net_x2: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x14 <= addr;
  ce_1_sg_x14 <= ce_1;
  clk_1_sg_x14 <= clk_1;
  reinterpret_output_port_net_x1 <= pol1;
  reinterpret_output_port_net_x2 <= pol2;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net_x2 <= window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net_x2 <= window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out;
  pol1_im <= delay80_q_net_x0;
  pol1_re <= delay82_q_net_x0;
  pol2_im <= delay81_q_net_x0;
  pol2_re <= delay83_q_net_x0;
  shared_bram <= convert_addr_dout_net_x2;
  shared_bram1 <= convert_addr_dout_net_x3;
  shared_bram1_x0 <= convert_din1_dout_net_x3;
  shared_bram1_x1 <= convert_we_dout_net_x3;
  shared_bram1_x2 <= reinterpret_out_output_port_net_x5;
  shared_bram_x0 <= convert_din1_dout_net_x2;
  shared_bram_x1 <= convert_we_dout_net_x2;
  shared_bram_x2 <= reinterpret_out_output_port_net_x4;

  constant1: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net_x1
    );

  constant10: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant10_op_net_x1
    );

  constant2: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net_x0
    );

  constant9: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant9_op_net_x0
    );

  delay32: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => reinterpret_output_port_net_x1,
      q => delay32_q_net
    );

  delay33: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => reinterpret_out_output_port_net_x4,
      q => delay33_q_net
    );

  delay34: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => reinterpret_output_port_net_x2,
      q => delay34_q_net
    );

  delay35: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => reinterpret_out_output_port_net_x4,
      q => delay35_q_net
    );

  delay36: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => reinterpret_output_port_net_x1,
      q => delay36_q_net
    );

  delay37: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => reinterpret_out_output_port_net_x5,
      q => delay37_q_net
    );

  delay38: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => reinterpret_output_port_net_x2,
      q => delay38_q_net
    );

  delay39: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => reinterpret_out_output_port_net_x5,
      q => delay39_q_net
    );

  delay80: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => mult16_p_net,
      q => delay80_q_net_x0
    );

  delay81: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => mult1_p_net,
      q => delay81_q_net_x0
    );

  delay82: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => mult2_p_net,
      q => delay82_q_net_x0
    );

  delay83: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      d => mult3_p_net,
      q => delay83_q_net_x0
    );

  mult1: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay34_q_net,
      b => delay35_q_net,
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      core_ce => ce_1_sg_x14,
      core_clk => clk_1_sg_x14,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult1_p_net
    );

  mult16: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay32_q_net,
      b => delay33_q_net,
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      core_ce => ce_1_sg_x14,
      core_clk => clk_1_sg_x14,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult16_p_net
    );

  mult2: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay36_q_net,
      b => delay37_q_net,
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      core_ce => ce_1_sg_x14,
      core_clk => clk_1_sg_x14,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult2_p_net
    );

  mult3: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay38_q_net,
      b => delay39_q_net,
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      clr => '0',
      core_ce => ce_1_sg_x14,
      core_clk => clk_1_sg_x14,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult3_p_net
    );

  shared_bram1_2d0abb7ab3: entity work.shared_bram1_entity_2d0abb7ab3
    port map (
      addr => delay80_q_net_x14,
      ce_1 => ce_1_sg_x14,
      clk_1 => clk_1_sg_x14,
      data_in => constant1_op_net_x1,
      we => constant2_op_net_x0,
      window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net_x2,
      convert_addr_x0 => convert_addr_dout_net_x3,
      convert_din1_x0 => convert_din1_dout_net_x3,
      convert_we_x0 => convert_we_dout_net_x3,
      data_out => reinterpret_out_output_port_net_x5
    );

  shared_bram_9f98093f3b: entity work.shared_bram_entity_9f98093f3b
    port map (
      addr => delay80_q_net_x14,
      ce_1 => ce_1_sg_x14,
      clk_1 => clk_1_sg_x14,
      data_in => constant10_op_net_x1,
      we => constant9_op_net_x0,
      window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net_x2,
      convert_addr_x0 => convert_addr_dout_net_x2,
      convert_din1_x0 => convert_din1_dout_net_x2,
      convert_we_x0 => convert_we_dout_net_x2,
      data_out => reinterpret_out_output_port_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_4/Shared_BRAM"

entity shared_bram_entity_6c4498bff7 is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(15 downto 0); 
    we: in std_logic_vector(15 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end shared_bram_entity_6c4498bff7;

architecture structural of shared_bram_entity_6c4498bff7 is
  signal ce_1_sg_x16: std_logic;
  signal clk_1_sg_x16: std_logic;
  signal constant10_op_net_x1: std_logic_vector(15 downto 0);
  signal constant9_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal delay80_q_net_x16: std_logic_vector(15 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net_x1: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x16 <= addr;
  ce_1_sg_x16 <= ce_1;
  clk_1_sg_x16 <= clk_1;
  constant10_op_net_x1 <= data_in;
  constant9_op_net_x0 <= we;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net_x1 <= window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_04957c4e4c: entity work.calc_add_entity_c24bfeccac
    port map (
      ce_1 => ce_1_sg_x16,
      clk_1 => clk_1_sg_x16,
      in_x0 => delay80_q_net_x16,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x16,
      clk => clk_1_sg_x16,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x16,
      clk => clk_1_sg_x16,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x16,
      clk => clk_1_sg_x16,
      clr => '0',
      din => constant9_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_66add0514a: entity work.munge_in_entity_6927a14d9a
    port map (
      din => constant10_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_04462cb0de: entity work.munge_out_entity_142a6ee39c
    port map (
      din => window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_4/Shared_BRAM1"

entity shared_bram1_entity_dc1b83792c is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(15 downto 0); 
    we: in std_logic_vector(15 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end shared_bram1_entity_dc1b83792c;

architecture structural of shared_bram1_entity_dc1b83792c is
  signal ce_1_sg_x18: std_logic;
  signal clk_1_sg_x18: std_logic;
  signal constant1_op_net_x1: std_logic_vector(15 downto 0);
  signal constant2_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal delay80_q_net_x18: std_logic_vector(15 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net_x1: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x18 <= addr;
  ce_1_sg_x18 <= ce_1;
  clk_1_sg_x18 <= clk_1;
  constant1_op_net_x1 <= data_in;
  constant2_op_net_x0 <= we;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net_x1 <= window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_c8bd25e389: entity work.calc_add_entity_c24bfeccac
    port map (
      ce_1 => ce_1_sg_x18,
      clk_1 => clk_1_sg_x18,
      in_x0 => delay80_q_net_x18,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x18,
      clk => clk_1_sg_x18,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x18,
      clk => clk_1_sg_x18,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x18,
      clk => clk_1_sg_x18,
      clr => '0',
      din => constant2_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_8d155ad3ef: entity work.munge_in_entity_6927a14d9a
    port map (
      din => constant1_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_920606e170: entity work.munge_out_entity_142a6ee39c
    port map (
      din => window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem/lo_4"

entity lo_4_entity_ba8debee02 is
  port (
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pol1: in std_logic_vector(7 downto 0); 
    pol2: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    pol1_im: out std_logic_vector(15 downto 0); 
    pol1_re: out std_logic_vector(15 downto 0); 
    pol2_im: out std_logic_vector(15 downto 0); 
    pol2_re: out std_logic_vector(15 downto 0); 
    shared_bram: out std_logic_vector(9 downto 0); 
    shared_bram1: out std_logic_vector(9 downto 0); 
    shared_bram1_x0: out std_logic_vector(31 downto 0); 
    shared_bram1_x1: out std_logic; 
    shared_bram1_x2: out std_logic_vector(31 downto 0); 
    shared_bram_x0: out std_logic_vector(31 downto 0); 
    shared_bram_x1: out std_logic; 
    shared_bram_x2: out std_logic_vector(31 downto 0)
  );
end lo_4_entity_ba8debee02;

architecture structural of lo_4_entity_ba8debee02 is
  signal ce_1_sg_x19: std_logic;
  signal clk_1_sg_x19: std_logic;
  signal constant10_op_net_x1: std_logic_vector(15 downto 0);
  signal constant1_op_net_x1: std_logic_vector(15 downto 0);
  signal constant2_op_net_x0: std_logic_vector(15 downto 0);
  signal constant9_op_net_x0: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x2: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x3: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x3: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal convert_we_dout_net_x3: std_logic;
  signal delay32_q_net: std_logic_vector(7 downto 0);
  signal delay33_q_net: std_logic_vector(31 downto 0);
  signal delay34_q_net: std_logic_vector(7 downto 0);
  signal delay35_q_net: std_logic_vector(31 downto 0);
  signal delay36_q_net: std_logic_vector(7 downto 0);
  signal delay37_q_net: std_logic_vector(31 downto 0);
  signal delay38_q_net: std_logic_vector(7 downto 0);
  signal delay39_q_net: std_logic_vector(31 downto 0);
  signal delay80_q_net_x0: std_logic_vector(15 downto 0);
  signal delay80_q_net_x19: std_logic_vector(15 downto 0);
  signal delay81_q_net_x0: std_logic_vector(15 downto 0);
  signal delay82_q_net_x0: std_logic_vector(15 downto 0);
  signal delay83_q_net_x0: std_logic_vector(15 downto 0);
  signal mult16_p_net: std_logic_vector(15 downto 0);
  signal mult1_p_net: std_logic_vector(15 downto 0);
  signal mult2_p_net: std_logic_vector(15 downto 0);
  signal mult3_p_net: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x4: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x5: std_logic_vector(31 downto 0);
  signal reinterpret_output_port_net_x1: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x2: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net_x2: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net_x2: std_logic_vector(31 downto 0);

begin
  delay80_q_net_x19 <= addr;
  ce_1_sg_x19 <= ce_1;
  clk_1_sg_x19 <= clk_1;
  reinterpret_output_port_net_x1 <= pol1;
  reinterpret_output_port_net_x2 <= pol2;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net_x2 <= window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net_x2 <= window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out;
  pol1_im <= delay80_q_net_x0;
  pol1_re <= delay82_q_net_x0;
  pol2_im <= delay81_q_net_x0;
  pol2_re <= delay83_q_net_x0;
  shared_bram <= convert_addr_dout_net_x2;
  shared_bram1 <= convert_addr_dout_net_x3;
  shared_bram1_x0 <= convert_din1_dout_net_x3;
  shared_bram1_x1 <= convert_we_dout_net_x3;
  shared_bram1_x2 <= reinterpret_out_output_port_net_x5;
  shared_bram_x0 <= convert_din1_dout_net_x2;
  shared_bram_x1 <= convert_we_dout_net_x2;
  shared_bram_x2 <= reinterpret_out_output_port_net_x4;

  constant1: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net_x1
    );

  constant10: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant10_op_net_x1
    );

  constant2: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net_x0
    );

  constant9: entity work.constant_9f5572ba51
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant9_op_net_x0
    );

  delay32: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => reinterpret_output_port_net_x1,
      q => delay32_q_net
    );

  delay33: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => reinterpret_out_output_port_net_x4,
      q => delay33_q_net
    );

  delay34: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => reinterpret_output_port_net_x2,
      q => delay34_q_net
    );

  delay35: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => reinterpret_out_output_port_net_x4,
      q => delay35_q_net
    );

  delay36: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => reinterpret_output_port_net_x1,
      q => delay36_q_net
    );

  delay37: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => reinterpret_out_output_port_net_x5,
      q => delay37_q_net
    );

  delay38: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => reinterpret_output_port_net_x2,
      q => delay38_q_net
    );

  delay39: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => reinterpret_out_output_port_net_x5,
      q => delay39_q_net
    );

  delay80: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => mult16_p_net,
      q => delay80_q_net_x0
    );

  delay81: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => mult1_p_net,
      q => delay81_q_net_x0
    );

  delay82: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => mult2_p_net,
      q => delay82_q_net_x0
    );

  delay83: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      d => mult3_p_net,
      q => delay83_q_net_x0
    );

  mult1: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay34_q_net,
      b => delay35_q_net,
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      core_ce => ce_1_sg_x19,
      core_clk => clk_1_sg_x19,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult1_p_net
    );

  mult16: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay32_q_net,
      b => delay33_q_net,
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      core_ce => ce_1_sg_x19,
      core_clk => clk_1_sg_x19,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult16_p_net
    );

  mult2: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay36_q_net,
      b => delay37_q_net,
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      core_ce => ce_1_sg_x19,
      core_clk => clk_1_sg_x19,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult2_p_net
    );

  mult3: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 32,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 32,
      c_baat => 8,
      c_output_width => 40,
      c_type => 0,
      core_name0 => "mult_11_2_7f50ff10654d69e4",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 16,
      quantization => 1
    )
    port map (
      a => delay38_q_net,
      b => delay39_q_net,
      ce => ce_1_sg_x19,
      clk => clk_1_sg_x19,
      clr => '0',
      core_ce => ce_1_sg_x19,
      core_clk => clk_1_sg_x19,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult3_p_net
    );

  shared_bram1_dc1b83792c: entity work.shared_bram1_entity_dc1b83792c
    port map (
      addr => delay80_q_net_x19,
      ce_1 => ce_1_sg_x19,
      clk_1 => clk_1_sg_x19,
      data_in => constant1_op_net_x1,
      we => constant2_op_net_x0,
      window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net_x2,
      convert_addr_x0 => convert_addr_dout_net_x3,
      convert_din1_x0 => convert_din1_dout_net_x3,
      convert_we_x0 => convert_we_dout_net_x3,
      data_out => reinterpret_out_output_port_net_x5
    );

  shared_bram_6c4498bff7: entity work.shared_bram_entity_6c4498bff7
    port map (
      addr => delay80_q_net_x19,
      ce_1 => ce_1_sg_x19,
      clk_1 => clk_1_sg_x19,
      data_in => constant10_op_net_x1,
      we => constant9_op_net_x0,
      window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net_x2,
      convert_addr_x0 => convert_addr_dout_net_x2,
      convert_din1_x0 => convert_din1_dout_net_x2,
      convert_we_x0 => convert_we_dout_net_x2,
      data_out => reinterpret_out_output_port_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/Subsystem"

entity subsystem_entity_1d58a904b1 is
  port (
    adc_data1_2: in std_logic_vector(7 downto 0); 
    adc_data_0_0: in std_logic_vector(7 downto 0); 
    adc_data_0_1: in std_logic_vector(7 downto 0); 
    adc_data_0_2: in std_logic_vector(7 downto 0); 
    adc_data_0_3: in std_logic_vector(7 downto 0); 
    adc_data_1_0: in std_logic_vector(7 downto 0); 
    adc_data_1_1: in std_logic_vector(7 downto 0); 
    adc_data_1_3: in std_logic_vector(7 downto 0); 
    addr: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    lo_1: out std_logic_vector(9 downto 0); 
    lo_1_x0: out std_logic_vector(31 downto 0); 
    lo_1_x1: out std_logic; 
    lo_1_x2: out std_logic_vector(31 downto 0); 
    lo_1_x3: out std_logic_vector(9 downto 0); 
    lo_1_x4: out std_logic_vector(31 downto 0); 
    lo_1_x5: out std_logic; 
    lo_1_x6: out std_logic_vector(31 downto 0); 
    lo_2: out std_logic_vector(9 downto 0); 
    lo_2_x0: out std_logic_vector(31 downto 0); 
    lo_2_x1: out std_logic; 
    lo_2_x2: out std_logic_vector(31 downto 0); 
    lo_2_x3: out std_logic_vector(9 downto 0); 
    lo_2_x4: out std_logic_vector(31 downto 0); 
    lo_2_x5: out std_logic; 
    lo_2_x6: out std_logic_vector(31 downto 0); 
    lo_3: out std_logic_vector(9 downto 0); 
    lo_3_x0: out std_logic_vector(31 downto 0); 
    lo_3_x1: out std_logic; 
    lo_3_x2: out std_logic_vector(31 downto 0); 
    lo_3_x3: out std_logic_vector(9 downto 0); 
    lo_3_x4: out std_logic_vector(31 downto 0); 
    lo_3_x5: out std_logic; 
    lo_3_x6: out std_logic_vector(31 downto 0); 
    lo_4: out std_logic_vector(9 downto 0); 
    lo_4_x0: out std_logic_vector(31 downto 0); 
    lo_4_x1: out std_logic; 
    lo_4_x2: out std_logic_vector(31 downto 0); 
    lo_4_x3: out std_logic_vector(9 downto 0); 
    lo_4_x4: out std_logic_vector(31 downto 0); 
    lo_4_x5: out std_logic; 
    lo_4_x6: out std_logic_vector(31 downto 0); 
    pol1_imag_1: out std_logic_vector(15 downto 0); 
    pol1_imag_2: out std_logic_vector(15 downto 0); 
    pol1_imag_3: out std_logic_vector(15 downto 0); 
    pol1_imag_4: out std_logic_vector(15 downto 0); 
    pol1_real_1: out std_logic_vector(15 downto 0); 
    pol1_real_2: out std_logic_vector(15 downto 0); 
    pol1_real_3: out std_logic_vector(15 downto 0); 
    pol1_real_4: out std_logic_vector(15 downto 0); 
    pol2_imag_2: out std_logic_vector(15 downto 0); 
    pol2_imag_2_x0: out std_logic_vector(15 downto 0); 
    pol2_imag_3: out std_logic_vector(15 downto 0); 
    pol2_imag_4: out std_logic_vector(15 downto 0); 
    pol2_real_1: out std_logic_vector(15 downto 0); 
    pol2_real_2: out std_logic_vector(15 downto 0); 
    pol2_real_3: out std_logic_vector(15 downto 0); 
    pol2_real_4: out std_logic_vector(15 downto 0)
  );
end subsystem_entity_1d58a904b1;

architecture structural of subsystem_entity_1d58a904b1 is
  signal ce_1_sg_x20: std_logic;
  signal clk_1_sg_x20: std_logic;
  signal convert_addr_dout_net_x10: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x11: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x12: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x13: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x14: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x15: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x16: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x17: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x10: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x11: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x12: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x13: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x14: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x15: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x16: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x17: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x10: std_logic;
  signal convert_we_dout_net_x11: std_logic;
  signal convert_we_dout_net_x12: std_logic;
  signal convert_we_dout_net_x13: std_logic;
  signal convert_we_dout_net_x14: std_logic;
  signal convert_we_dout_net_x15: std_logic;
  signal convert_we_dout_net_x16: std_logic;
  signal convert_we_dout_net_x17: std_logic;
  signal delay80_q_net_x20: std_logic_vector(15 downto 0);
  signal delay80_q_net_x4: std_logic_vector(15 downto 0);
  signal delay80_q_net_x5: std_logic_vector(15 downto 0);
  signal delay80_q_net_x6: std_logic_vector(15 downto 0);
  signal delay80_q_net_x7: std_logic_vector(15 downto 0);
  signal delay81_q_net_x4: std_logic_vector(15 downto 0);
  signal delay81_q_net_x5: std_logic_vector(15 downto 0);
  signal delay81_q_net_x6: std_logic_vector(15 downto 0);
  signal delay81_q_net_x7: std_logic_vector(15 downto 0);
  signal delay82_q_net_x4: std_logic_vector(15 downto 0);
  signal delay82_q_net_x5: std_logic_vector(15 downto 0);
  signal delay82_q_net_x6: std_logic_vector(15 downto 0);
  signal delay82_q_net_x7: std_logic_vector(15 downto 0);
  signal delay83_q_net_x4: std_logic_vector(15 downto 0);
  signal delay83_q_net_x5: std_logic_vector(15 downto 0);
  signal delay83_q_net_x6: std_logic_vector(15 downto 0);
  signal delay83_q_net_x7: std_logic_vector(15 downto 0);
  signal reinterpret_out_output_port_net_x12: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x13: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x14: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x15: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x16: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x17: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x18: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x19: std_logic_vector(31 downto 0);
  signal reinterpret_output_port_net_x10: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x11: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x12: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x13: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x14: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x15: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x16: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x9: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net_x3: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x3: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net_x3: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net_x3: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net_x3: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net_x3: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net_x3: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net_x3: std_logic_vector(31 downto 0);

begin
  reinterpret_output_port_net_x15 <= adc_data1_2;
  reinterpret_output_port_net_x9 <= adc_data_0_0;
  reinterpret_output_port_net_x13 <= adc_data_0_1;
  reinterpret_output_port_net_x11 <= adc_data_0_2;
  reinterpret_output_port_net_x12 <= adc_data_0_3;
  reinterpret_output_port_net_x10 <= adc_data_1_0;
  reinterpret_output_port_net_x14 <= adc_data_1_1;
  reinterpret_output_port_net_x16 <= adc_data_1_3;
  delay80_q_net_x20 <= addr;
  ce_1_sg_x20 <= ce_1;
  clk_1_sg_x20 <= clk_1;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net_x3 <= window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x3 <= window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net_x3 <= window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net_x3 <= window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net_x3 <= window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net_x3 <= window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net_x3 <= window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net_x3 <= window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out;
  lo_1 <= convert_addr_dout_net_x10;
  lo_1_x0 <= convert_din1_dout_net_x10;
  lo_1_x1 <= convert_we_dout_net_x10;
  lo_1_x2 <= reinterpret_out_output_port_net_x12;
  lo_1_x3 <= convert_addr_dout_net_x11;
  lo_1_x4 <= convert_din1_dout_net_x11;
  lo_1_x5 <= convert_we_dout_net_x11;
  lo_1_x6 <= reinterpret_out_output_port_net_x13;
  lo_2 <= convert_addr_dout_net_x12;
  lo_2_x0 <= convert_din1_dout_net_x12;
  lo_2_x1 <= convert_we_dout_net_x12;
  lo_2_x2 <= reinterpret_out_output_port_net_x14;
  lo_2_x3 <= convert_addr_dout_net_x13;
  lo_2_x4 <= convert_din1_dout_net_x13;
  lo_2_x5 <= convert_we_dout_net_x13;
  lo_2_x6 <= reinterpret_out_output_port_net_x15;
  lo_3 <= convert_addr_dout_net_x14;
  lo_3_x0 <= convert_din1_dout_net_x14;
  lo_3_x1 <= convert_we_dout_net_x14;
  lo_3_x2 <= reinterpret_out_output_port_net_x16;
  lo_3_x3 <= convert_addr_dout_net_x15;
  lo_3_x4 <= convert_din1_dout_net_x15;
  lo_3_x5 <= convert_we_dout_net_x15;
  lo_3_x6 <= reinterpret_out_output_port_net_x17;
  lo_4 <= convert_addr_dout_net_x16;
  lo_4_x0 <= convert_din1_dout_net_x16;
  lo_4_x1 <= convert_we_dout_net_x16;
  lo_4_x2 <= reinterpret_out_output_port_net_x18;
  lo_4_x3 <= convert_addr_dout_net_x17;
  lo_4_x4 <= convert_din1_dout_net_x17;
  lo_4_x5 <= convert_we_dout_net_x17;
  lo_4_x6 <= reinterpret_out_output_port_net_x19;
  pol1_imag_1 <= delay80_q_net_x4;
  pol1_imag_2 <= delay80_q_net_x5;
  pol1_imag_3 <= delay80_q_net_x6;
  pol1_imag_4 <= delay80_q_net_x7;
  pol1_real_1 <= delay82_q_net_x4;
  pol1_real_2 <= delay82_q_net_x5;
  pol1_real_3 <= delay82_q_net_x6;
  pol1_real_4 <= delay82_q_net_x7;
  pol2_imag_2 <= delay81_q_net_x4;
  pol2_imag_2_x0 <= delay81_q_net_x5;
  pol2_imag_3 <= delay81_q_net_x6;
  pol2_imag_4 <= delay81_q_net_x7;
  pol2_real_1 <= delay83_q_net_x4;
  pol2_real_2 <= delay83_q_net_x5;
  pol2_real_3 <= delay83_q_net_x6;
  pol2_real_4 <= delay83_q_net_x7;

  lo_1_f9b742d2f1: entity work.lo_1_entity_f9b742d2f1
    port map (
      addr => delay80_q_net_x20,
      ce_1 => ce_1_sg_x20,
      clk_1 => clk_1_sg_x20,
      pol1 => reinterpret_output_port_net_x9,
      pol2 => reinterpret_output_port_net_x13,
      window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net_x3,
      window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net_x3,
      pol1_im => delay80_q_net_x4,
      pol1_re => delay82_q_net_x4,
      pol2_im => delay81_q_net_x4,
      pol2_re => delay83_q_net_x4,
      shared_bram => convert_addr_dout_net_x10,
      shared_bram1 => convert_addr_dout_net_x11,
      shared_bram1_x0 => convert_din1_dout_net_x11,
      shared_bram1_x1 => convert_we_dout_net_x11,
      shared_bram1_x2 => reinterpret_out_output_port_net_x13,
      shared_bram_x0 => convert_din1_dout_net_x10,
      shared_bram_x1 => convert_we_dout_net_x10,
      shared_bram_x2 => reinterpret_out_output_port_net_x12
    );

  lo_2_ca2ff53d39: entity work.lo_2_entity_ca2ff53d39
    port map (
      addr => delay80_q_net_x20,
      ce_1 => ce_1_sg_x20,
      clk_1 => clk_1_sg_x20,
      pol1 => reinterpret_output_port_net_x10,
      pol2 => reinterpret_output_port_net_x14,
      window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net_x3,
      window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net_x3,
      pol1_im => delay80_q_net_x5,
      pol1_re => delay82_q_net_x5,
      pol2_im => delay81_q_net_x5,
      pol2_re => delay83_q_net_x5,
      shared_bram => convert_addr_dout_net_x12,
      shared_bram1 => convert_addr_dout_net_x13,
      shared_bram1_x0 => convert_din1_dout_net_x13,
      shared_bram1_x1 => convert_we_dout_net_x13,
      shared_bram1_x2 => reinterpret_out_output_port_net_x15,
      shared_bram_x0 => convert_din1_dout_net_x12,
      shared_bram_x1 => convert_we_dout_net_x12,
      shared_bram_x2 => reinterpret_out_output_port_net_x14
    );

  lo_3_b9de28fa93: entity work.lo_3_entity_b9de28fa93
    port map (
      addr => delay80_q_net_x20,
      ce_1 => ce_1_sg_x20,
      clk_1 => clk_1_sg_x20,
      pol1 => reinterpret_output_port_net_x11,
      pol2 => reinterpret_output_port_net_x15,
      window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net_x3,
      window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net_x3,
      pol1_im => delay80_q_net_x6,
      pol1_re => delay82_q_net_x6,
      pol2_im => delay81_q_net_x6,
      pol2_re => delay83_q_net_x6,
      shared_bram => convert_addr_dout_net_x14,
      shared_bram1 => convert_addr_dout_net_x15,
      shared_bram1_x0 => convert_din1_dout_net_x15,
      shared_bram1_x1 => convert_we_dout_net_x15,
      shared_bram1_x2 => reinterpret_out_output_port_net_x17,
      shared_bram_x0 => convert_din1_dout_net_x14,
      shared_bram_x1 => convert_we_dout_net_x14,
      shared_bram_x2 => reinterpret_out_output_port_net_x16
    );

  lo_4_ba8debee02: entity work.lo_4_entity_ba8debee02
    port map (
      addr => delay80_q_net_x20,
      ce_1 => ce_1_sg_x20,
      clk_1 => clk_1_sg_x20,
      pol1 => reinterpret_output_port_net_x12,
      pol2 => reinterpret_output_port_net_x16,
      window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net_x3,
      window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net_x3,
      pol1_im => delay80_q_net_x7,
      pol1_re => delay82_q_net_x7,
      pol2_im => delay81_q_net_x7,
      pol2_re => delay83_q_net_x7,
      shared_bram => convert_addr_dout_net_x16,
      shared_bram1 => convert_addr_dout_net_x17,
      shared_bram1_x0 => convert_din1_dout_net_x17,
      shared_bram1_x1 => convert_we_dout_net_x17,
      shared_bram1_x2 => reinterpret_out_output_port_net_x19,
      shared_bram_x0 => convert_din1_dout_net_x16,
      shared_bram_x1 => convert_we_dout_net_x16,
      shared_bram_x2 => reinterpret_out_output_port_net_x18
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/adc/conv"

entity conv_entity_0fd6941345 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(7 downto 0); 
    out1: out std_logic_vector(7 downto 0)
  );
end conv_entity_0fd6941345;

architecture structural of conv_entity_0fd6941345 is
  signal ce_1_sg_x21: std_logic;
  signal clk_1_sg_x21: std_logic;
  signal concat_y_net: std_logic_vector(7 downto 0);
  signal inverter_op_net: std_logic;
  signal reinterpret_output_port_net_x10: std_logic_vector(7 downto 0);
  signal slice1_y_net: std_logic_vector(6 downto 0);
  signal slice_y_net: std_logic;
  signal window_and_fft_test_v4_adc_user_datai0_net_x0: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x21 <= ce_1;
  clk_1_sg_x21 <= clk_1;
  window_and_fft_test_v4_adc_user_datai0_net_x0 <= in1;
  out1 <= reinterpret_output_port_net_x10;

  concat: entity work.concat_83e473517e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => inverter_op_net,
      in1 => slice1_y_net,
      y => concat_y_net
    );

  inverter: entity work.inverter_e2b989a05e
    port map (
      ce => ce_1_sg_x21,
      clk => clk_1_sg_x21,
      clr => '0',
      ip(0) => slice_y_net,
      op(0) => inverter_op_net
    );

  reinterpret: entity work.reinterpret_4389dc89bf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat_y_net,
      output_port => reinterpret_output_port_net_x10
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 7,
      new_msb => 7,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => window_and_fft_test_v4_adc_user_datai0_net_x0,
      y(0) => slice_y_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 6,
      x_width => 8,
      y_width => 7
    )
    port map (
      x => window_and_fft_test_v4_adc_user_datai0_net_x0,
      y => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/adc"

entity adc_entity_e5ed0846c4 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    window_and_fft_test_v4_adc_user_datai0: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_datai1: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_datai2: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_datai3: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_dataq0: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_dataq1: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_dataq2: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_dataq3: in std_logic_vector(7 downto 0); 
    i0: out std_logic_vector(7 downto 0); 
    i1: out std_logic_vector(7 downto 0); 
    i2: out std_logic_vector(7 downto 0); 
    i3: out std_logic_vector(7 downto 0); 
    q0: out std_logic_vector(7 downto 0); 
    q1: out std_logic_vector(7 downto 0); 
    q2: out std_logic_vector(7 downto 0); 
    q3: out std_logic_vector(7 downto 0)
  );
end adc_entity_e5ed0846c4;

architecture structural of adc_entity_e5ed0846c4 is
  signal ce_1_sg_x29: std_logic;
  signal clk_1_sg_x29: std_logic;
  signal reinterpret_output_port_net_x18: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x19: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x20: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x21: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x22: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x23: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x24: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x25: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_datai0_net_x1: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_datai1_net_x1: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_datai2_net_x1: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_datai3_net_x1: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_dataq0_net_x1: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_dataq1_net_x1: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_dataq2_net_x1: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_dataq3_net_x1: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x29 <= ce_1;
  clk_1_sg_x29 <= clk_1;
  window_and_fft_test_v4_adc_user_datai0_net_x1 <= window_and_fft_test_v4_adc_user_datai0;
  window_and_fft_test_v4_adc_user_datai1_net_x1 <= window_and_fft_test_v4_adc_user_datai1;
  window_and_fft_test_v4_adc_user_datai2_net_x1 <= window_and_fft_test_v4_adc_user_datai2;
  window_and_fft_test_v4_adc_user_datai3_net_x1 <= window_and_fft_test_v4_adc_user_datai3;
  window_and_fft_test_v4_adc_user_dataq0_net_x1 <= window_and_fft_test_v4_adc_user_dataq0;
  window_and_fft_test_v4_adc_user_dataq1_net_x1 <= window_and_fft_test_v4_adc_user_dataq1;
  window_and_fft_test_v4_adc_user_dataq2_net_x1 <= window_and_fft_test_v4_adc_user_dataq2;
  window_and_fft_test_v4_adc_user_dataq3_net_x1 <= window_and_fft_test_v4_adc_user_dataq3;
  i0 <= reinterpret_output_port_net_x18;
  i1 <= reinterpret_output_port_net_x19;
  i2 <= reinterpret_output_port_net_x20;
  i3 <= reinterpret_output_port_net_x21;
  q0 <= reinterpret_output_port_net_x22;
  q1 <= reinterpret_output_port_net_x23;
  q2 <= reinterpret_output_port_net_x24;
  q3 <= reinterpret_output_port_net_x25;

  conv1_9f11599bbc: entity work.conv_entity_0fd6941345
    port map (
      ce_1 => ce_1_sg_x29,
      clk_1 => clk_1_sg_x29,
      in1 => window_and_fft_test_v4_adc_user_datai1_net_x1,
      out1 => reinterpret_output_port_net_x19
    );

  conv2_8438320691: entity work.conv_entity_0fd6941345
    port map (
      ce_1 => ce_1_sg_x29,
      clk_1 => clk_1_sg_x29,
      in1 => window_and_fft_test_v4_adc_user_datai2_net_x1,
      out1 => reinterpret_output_port_net_x20
    );

  conv3_6e9c1f82be: entity work.conv_entity_0fd6941345
    port map (
      ce_1 => ce_1_sg_x29,
      clk_1 => clk_1_sg_x29,
      in1 => window_and_fft_test_v4_adc_user_datai3_net_x1,
      out1 => reinterpret_output_port_net_x21
    );

  conv4_cb5c56d7f2: entity work.conv_entity_0fd6941345
    port map (
      ce_1 => ce_1_sg_x29,
      clk_1 => clk_1_sg_x29,
      in1 => window_and_fft_test_v4_adc_user_dataq0_net_x1,
      out1 => reinterpret_output_port_net_x22
    );

  conv5_18551823ae: entity work.conv_entity_0fd6941345
    port map (
      ce_1 => ce_1_sg_x29,
      clk_1 => clk_1_sg_x29,
      in1 => window_and_fft_test_v4_adc_user_dataq1_net_x1,
      out1 => reinterpret_output_port_net_x23
    );

  conv6_529776fead: entity work.conv_entity_0fd6941345
    port map (
      ce_1 => ce_1_sg_x29,
      clk_1 => clk_1_sg_x29,
      in1 => window_and_fft_test_v4_adc_user_dataq2_net_x1,
      out1 => reinterpret_output_port_net_x24
    );

  conv7_0a81597d07: entity work.conv_entity_0fd6941345
    port map (
      ce_1 => ce_1_sg_x29,
      clk_1 => clk_1_sg_x29,
      in1 => window_and_fft_test_v4_adc_user_dataq3_net_x1,
      out1 => reinterpret_output_port_net_x25
    );

  conv_0fd6941345: entity work.conv_entity_0fd6941345
    port map (
      ce_1 => ce_1_sg_x29,
      clk_1 => clk_1_sg_x29,
      in1 => window_and_fft_test_v4_adc_user_datai0_net_x1,
      out1 => reinterpret_output_port_net_x18
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/bypass_pfb"

entity bypass_pfb_entity_fb69df1916 is
  port (
    window_and_fft_test_v4_bypass_pfb_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(10 downto 0)
  );
end bypass_pfb_entity_fb69df1916;

architecture structural of bypass_pfb_entity_fb69df1916 is
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(10 downto 0);
  signal slice_reg_y_net: std_logic_vector(10 downto 0);
  signal window_and_fft_test_v4_bypass_pfb_user_data_out_net_x0: std_logic_vector(31 downto 0);

begin
  window_and_fft_test_v4_bypass_pfb_user_data_out_net_x0 <= window_and_fft_test_v4_bypass_pfb_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => window_and_fft_test_v4_bypass_pfb_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_6b1adb5d55
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 10,
      x_width => 32,
      y_width => 11
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/c_to_ri"

entity c_to_ri_entity_98aa64f433 is
  port (
    c: in std_logic_vector(31 downto 0); 
    im: out std_logic_vector(15 downto 0); 
    re: out std_logic_vector(15 downto 0)
  );
end c_to_ri_entity_98aa64f433;

architecture structural of c_to_ri_entity_98aa64f433 is
  signal concat_y_net_x0: std_logic_vector(31 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(15 downto 0);
  signal slice_im_y_net: std_logic_vector(15 downto 0);
  signal slice_re_y_net: std_logic_vector(15 downto 0);

begin
  concat_y_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 15,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => concat_y_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 16,
      new_msb => 31,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => concat_y_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/coarse_fft_shift_mask1"

entity coarse_fft_shift_mask1_entity_5051420c9e is
  port (
    window_and_fft_test_v4_coarse_fft_shift_mask1_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(10 downto 0)
  );
end coarse_fft_shift_mask1_entity_5051420c9e;

architecture structural of coarse_fft_shift_mask1_entity_5051420c9e is
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(10 downto 0);
  signal slice_reg_y_net: std_logic_vector(10 downto 0);
  signal window_and_fft_test_v4_coarse_fft_shift_mask1_user_data_out_net_x0: std_logic_vector(31 downto 0);

begin
  window_and_fft_test_v4_coarse_fft_shift_mask1_user_data_out_net_x0 <= window_and_fft_test_v4_coarse_fft_shift_mask1_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => window_and_fft_test_v4_coarse_fft_shift_mask1_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_6b1adb5d55
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 10,
      x_width => 32,
      y_width => 11
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/convert_of10"

entity convert_of10_entity_dfa7148607 is
  port (
    ce_2500: in std_logic; 
    clk_2500: in std_logic; 
    din: in std_logic_vector(17 downto 0); 
    dout: out std_logic_vector(17 downto 0)
  );
end convert_of10_entity_dfa7148607;

architecture structural of convert_of10_entity_dfa7148607 is
  signal ce_2500_sg_x0: std_logic;
  signal clk_2500_sg_x0: std_logic;
  signal convert_dout_net_x0: std_logic_vector(17 downto 0);
  signal down_sample2_q_net_x0: std_logic_vector(17 downto 0);

begin
  ce_2500_sg_x0 <= ce_2500;
  clk_2500_sg_x0 <= clk_2500;
  down_sample2_q_net_x0 <= din;
  dout <= convert_dout_net_x0;

  convert: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 17,
      dout_width => 18,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_2500_sg_x0,
      clk => clk_2500_sg_x0,
      clr => '0',
      din => down_sample2_q_net_x0,
      en => "1",
      dout => convert_dout_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/fir_dbl_col1/adder_tree1"

entity adder_tree1_entity_1d0033c0f4 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din1: in std_logic_vector(41 downto 0); 
    din2: in std_logic_vector(41 downto 0); 
    din3: in std_logic_vector(41 downto 0); 
    din4: in std_logic_vector(41 downto 0); 
    dout: out std_logic_vector(43 downto 0)
  );
end adder_tree1_entity_1d0033c0f4;

architecture structural of adder_tree1_entity_1d0033c0f4 is
  signal addr1_s_net: std_logic_vector(42 downto 0);
  signal addr2_s_net: std_logic_vector(42 downto 0);
  signal addr3_s_net_x0: std_logic_vector(43 downto 0);
  signal ce_1_sg_x30: std_logic;
  signal clk_1_sg_x30: std_logic;
  signal mult0_p_net_x3: std_logic_vector(41 downto 0);
  signal mult0_p_net_x4: std_logic_vector(41 downto 0);
  signal mult0_p_net_x5: std_logic_vector(41 downto 0);
  signal mult0_p_net_x6: std_logic_vector(41 downto 0);

begin
  ce_1_sg_x30 <= ce_1;
  clk_1_sg_x30 <= clk_1;
  mult0_p_net_x3 <= din1;
  mult0_p_net_x4 <= din2;
  mult0_p_net_x5 <= din3;
  mult0_p_net_x6 <= din4;
  dout <= addr3_s_net_x0;

  addr1: entity work.addsub_38dd6afab7
    port map (
      a => mult0_p_net_x3,
      b => mult0_p_net_x4,
      ce => ce_1_sg_x30,
      clk => clk_1_sg_x30,
      clr => '0',
      s => addr1_s_net
    );

  addr2: entity work.addsub_38dd6afab7
    port map (
      a => mult0_p_net_x5,
      b => mult0_p_net_x6,
      ce => ce_1_sg_x30,
      clk => clk_1_sg_x30,
      clr => '0',
      s => addr2_s_net
    );

  addr3: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 39,
      a_width => 43,
      b_arith => xlSigned,
      b_bin_pt => 39,
      b_width => 43,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 44,
      core_name0 => "addsb_11_0_eef67c1cc12cdbba",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 44,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 39,
      s_width => 44
    )
    port map (
      a => addr1_s_net,
      b => addr2_s_net,
      ce => ce_1_sg_x30,
      clk => clk_1_sg_x30,
      clr => '0',
      en => "1",
      s => addr3_s_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/fir_dbl_col1/fir_dbl_tap1"

entity fir_dbl_tap1_entity_3f6ed236eb is
  port (
    a: in std_logic_vector(15 downto 0); 
    b: in std_logic_vector(15 downto 0); 
    c: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(15 downto 0); 
    a_out: out std_logic_vector(15 downto 0); 
    b_out: out std_logic_vector(15 downto 0); 
    imag: out std_logic_vector(41 downto 0); 
    real_x0: out std_logic_vector(41 downto 0)
  );
end fir_dbl_tap1_entity_3f6ed236eb;

architecture structural of fir_dbl_tap1_entity_3f6ed236eb is
  signal addsub0_s_net: std_logic_vector(16 downto 0);
  signal addsub1_s_net: std_logic_vector(16 downto 0);
  signal ce_1_sg_x32: std_logic;
  signal clk_1_sg_x32: std_logic;
  signal coefficient_op_net: std_logic_vector(24 downto 0);
  signal delay80_q_net_x5: std_logic_vector(15 downto 0);
  signal delay82_q_net_x5: std_logic_vector(15 downto 0);
  signal mult0_p_net_x4: std_logic_vector(41 downto 0);
  signal mult1_p_net_x4: std_logic_vector(41 downto 0);
  signal register0_q_net_x0: std_logic_vector(15 downto 0);
  signal register1_q_net_x0: std_logic_vector(15 downto 0);
  signal register2_q_net_x0: std_logic_vector(15 downto 0);
  signal register3_q_net_x0: std_logic_vector(15 downto 0);

begin
  delay82_q_net_x5 <= a;
  delay80_q_net_x5 <= b;
  register2_q_net_x0 <= c;
  ce_1_sg_x32 <= ce_1;
  clk_1_sg_x32 <= clk_1;
  register3_q_net_x0 <= d;
  a_out <= register0_q_net_x0;
  b_out <= register1_q_net_x0;
  imag <= mult1_p_net_x4;
  real_x0 <= mult0_p_net_x4;

  addsub0: entity work.addsub_24e94e69df
    port map (
      a => delay82_q_net_x5,
      b => register2_q_net_x0,
      ce => ce_1_sg_x32,
      clk => clk_1_sg_x32,
      clr => '0',
      s => addsub0_s_net
    );

  addsub1: entity work.addsub_24e94e69df
    port map (
      a => delay80_q_net_x5,
      b => register3_q_net_x0,
      ce => ce_1_sg_x32,
      clk => clk_1_sg_x32,
      clr => '0',
      s => addsub1_s_net
    );

  coefficient: entity work.constant_7b9ebdaf6c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => coefficient_op_net
    );

  mult0: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub0_s_net,
      ce => ce_1_sg_x32,
      clk => clk_1_sg_x32,
      clr => '0',
      p => mult0_p_net_x4
    );

  mult1: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub1_s_net,
      ce => ce_1_sg_x32,
      clk => clk_1_sg_x32,
      clr => '0',
      p => mult1_p_net_x4
    );

  register0: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x32,
      clk => clk_1_sg_x32,
      d => delay82_q_net_x5,
      en => "1",
      rst => "0",
      q => register0_q_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x32,
      clk => clk_1_sg_x32,
      d => delay80_q_net_x5,
      en => "1",
      rst => "0",
      q => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/fir_dbl_col1/fir_dbl_tap2"

entity fir_dbl_tap2_entity_4888fc9b88 is
  port (
    a: in std_logic_vector(15 downto 0); 
    b: in std_logic_vector(15 downto 0); 
    c: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(15 downto 0); 
    a_out: out std_logic_vector(15 downto 0); 
    b_out: out std_logic_vector(15 downto 0); 
    imag: out std_logic_vector(41 downto 0); 
    real_x0: out std_logic_vector(41 downto 0)
  );
end fir_dbl_tap2_entity_4888fc9b88;

architecture structural of fir_dbl_tap2_entity_4888fc9b88 is
  signal addsub0_s_net: std_logic_vector(16 downto 0);
  signal addsub1_s_net: std_logic_vector(16 downto 0);
  signal ce_1_sg_x33: std_logic;
  signal clk_1_sg_x33: std_logic;
  signal coefficient_op_net: std_logic_vector(24 downto 0);
  signal delay80_q_net_x6: std_logic_vector(15 downto 0);
  signal delay82_q_net_x6: std_logic_vector(15 downto 0);
  signal mult0_p_net_x5: std_logic_vector(41 downto 0);
  signal mult1_p_net_x5: std_logic_vector(41 downto 0);
  signal register0_q_net_x0: std_logic_vector(15 downto 0);
  signal register1_q_net_x0: std_logic_vector(15 downto 0);
  signal register2_q_net_x0: std_logic_vector(15 downto 0);
  signal register3_q_net_x0: std_logic_vector(15 downto 0);

begin
  delay82_q_net_x6 <= a;
  delay80_q_net_x6 <= b;
  register2_q_net_x0 <= c;
  ce_1_sg_x33 <= ce_1;
  clk_1_sg_x33 <= clk_1;
  register3_q_net_x0 <= d;
  a_out <= register0_q_net_x0;
  b_out <= register1_q_net_x0;
  imag <= mult1_p_net_x5;
  real_x0 <= mult0_p_net_x5;

  addsub0: entity work.addsub_24e94e69df
    port map (
      a => delay82_q_net_x6,
      b => register2_q_net_x0,
      ce => ce_1_sg_x33,
      clk => clk_1_sg_x33,
      clr => '0',
      s => addsub0_s_net
    );

  addsub1: entity work.addsub_24e94e69df
    port map (
      a => delay80_q_net_x6,
      b => register3_q_net_x0,
      ce => ce_1_sg_x33,
      clk => clk_1_sg_x33,
      clr => '0',
      s => addsub1_s_net
    );

  coefficient: entity work.constant_22835c9c71
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => coefficient_op_net
    );

  mult0: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub0_s_net,
      ce => ce_1_sg_x33,
      clk => clk_1_sg_x33,
      clr => '0',
      p => mult0_p_net_x5
    );

  mult1: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub1_s_net,
      ce => ce_1_sg_x33,
      clk => clk_1_sg_x33,
      clr => '0',
      p => mult1_p_net_x5
    );

  register0: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x33,
      clk => clk_1_sg_x33,
      d => delay82_q_net_x6,
      en => "1",
      rst => "0",
      q => register0_q_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x33,
      clk => clk_1_sg_x33,
      d => delay80_q_net_x6,
      en => "1",
      rst => "0",
      q => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/fir_dbl_col1/fir_dbl_tap3"

entity fir_dbl_tap3_entity_520a1ed3ca is
  port (
    a: in std_logic_vector(15 downto 0); 
    b: in std_logic_vector(15 downto 0); 
    c: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(15 downto 0); 
    a_out: out std_logic_vector(15 downto 0); 
    b_out: out std_logic_vector(15 downto 0); 
    imag: out std_logic_vector(41 downto 0); 
    real_x0: out std_logic_vector(41 downto 0)
  );
end fir_dbl_tap3_entity_520a1ed3ca;

architecture structural of fir_dbl_tap3_entity_520a1ed3ca is
  signal addsub0_s_net: std_logic_vector(16 downto 0);
  signal addsub1_s_net: std_logic_vector(16 downto 0);
  signal ce_1_sg_x34: std_logic;
  signal clk_1_sg_x34: std_logic;
  signal coefficient_op_net: std_logic_vector(24 downto 0);
  signal delay80_q_net_x7: std_logic_vector(15 downto 0);
  signal delay82_q_net_x7: std_logic_vector(15 downto 0);
  signal mult0_p_net_x6: std_logic_vector(41 downto 0);
  signal mult1_p_net_x6: std_logic_vector(41 downto 0);
  signal register0_q_net_x0: std_logic_vector(15 downto 0);
  signal register1_q_net_x0: std_logic_vector(15 downto 0);
  signal register2_q_net_x0: std_logic_vector(15 downto 0);
  signal register3_q_net_x0: std_logic_vector(15 downto 0);

begin
  delay82_q_net_x7 <= a;
  delay80_q_net_x7 <= b;
  register2_q_net_x0 <= c;
  ce_1_sg_x34 <= ce_1;
  clk_1_sg_x34 <= clk_1;
  register3_q_net_x0 <= d;
  a_out <= register0_q_net_x0;
  b_out <= register1_q_net_x0;
  imag <= mult1_p_net_x6;
  real_x0 <= mult0_p_net_x6;

  addsub0: entity work.addsub_24e94e69df
    port map (
      a => delay82_q_net_x7,
      b => register2_q_net_x0,
      ce => ce_1_sg_x34,
      clk => clk_1_sg_x34,
      clr => '0',
      s => addsub0_s_net
    );

  addsub1: entity work.addsub_24e94e69df
    port map (
      a => delay80_q_net_x7,
      b => register3_q_net_x0,
      ce => ce_1_sg_x34,
      clk => clk_1_sg_x34,
      clr => '0',
      s => addsub1_s_net
    );

  coefficient: entity work.constant_1ae64facd4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => coefficient_op_net
    );

  mult0: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub0_s_net,
      ce => ce_1_sg_x34,
      clk => clk_1_sg_x34,
      clr => '0',
      p => mult0_p_net_x6
    );

  mult1: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub1_s_net,
      ce => ce_1_sg_x34,
      clk => clk_1_sg_x34,
      clr => '0',
      p => mult1_p_net_x6
    );

  register0: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x34,
      clk => clk_1_sg_x34,
      d => delay82_q_net_x7,
      en => "1",
      rst => "0",
      q => register0_q_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x34,
      clk => clk_1_sg_x34,
      d => delay80_q_net_x7,
      en => "1",
      rst => "0",
      q => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/fir_dbl_col1/fir_dbl_tap4"

entity fir_dbl_tap4_entity_21a3cb2afe is
  port (
    a: in std_logic_vector(15 downto 0); 
    b: in std_logic_vector(15 downto 0); 
    c: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(15 downto 0); 
    a_out: out std_logic_vector(15 downto 0); 
    b_out: out std_logic_vector(15 downto 0); 
    imag: out std_logic_vector(41 downto 0); 
    real_x0: out std_logic_vector(41 downto 0)
  );
end fir_dbl_tap4_entity_21a3cb2afe;

architecture structural of fir_dbl_tap4_entity_21a3cb2afe is
  signal addsub0_s_net: std_logic_vector(16 downto 0);
  signal addsub1_s_net: std_logic_vector(16 downto 0);
  signal ce_1_sg_x35: std_logic;
  signal clk_1_sg_x35: std_logic;
  signal coefficient_op_net: std_logic_vector(24 downto 0);
  signal delay80_q_net_x8: std_logic_vector(15 downto 0);
  signal delay82_q_net_x8: std_logic_vector(15 downto 0);
  signal mult0_p_net_x7: std_logic_vector(41 downto 0);
  signal mult1_p_net_x7: std_logic_vector(41 downto 0);
  signal register0_q_net_x0: std_logic_vector(15 downto 0);
  signal register1_q_net_x0: std_logic_vector(15 downto 0);
  signal register2_q_net_x0: std_logic_vector(15 downto 0);
  signal register3_q_net_x0: std_logic_vector(15 downto 0);

begin
  delay82_q_net_x8 <= a;
  delay80_q_net_x8 <= b;
  register2_q_net_x0 <= c;
  ce_1_sg_x35 <= ce_1;
  clk_1_sg_x35 <= clk_1;
  register3_q_net_x0 <= d;
  a_out <= register0_q_net_x0;
  b_out <= register1_q_net_x0;
  imag <= mult1_p_net_x7;
  real_x0 <= mult0_p_net_x7;

  addsub0: entity work.addsub_24e94e69df
    port map (
      a => delay82_q_net_x8,
      b => register2_q_net_x0,
      ce => ce_1_sg_x35,
      clk => clk_1_sg_x35,
      clr => '0',
      s => addsub0_s_net
    );

  addsub1: entity work.addsub_24e94e69df
    port map (
      a => delay80_q_net_x8,
      b => register3_q_net_x0,
      ce => ce_1_sg_x35,
      clk => clk_1_sg_x35,
      clr => '0',
      s => addsub1_s_net
    );

  coefficient: entity work.constant_c917c58776
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => coefficient_op_net
    );

  mult0: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub0_s_net,
      ce => ce_1_sg_x35,
      clk => clk_1_sg_x35,
      clr => '0',
      p => mult0_p_net_x7
    );

  mult1: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub1_s_net,
      ce => ce_1_sg_x35,
      clk => clk_1_sg_x35,
      clr => '0',
      p => mult1_p_net_x7
    );

  register0: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x35,
      clk => clk_1_sg_x35,
      d => delay82_q_net_x8,
      en => "1",
      rst => "0",
      q => register0_q_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x35,
      clk => clk_1_sg_x35,
      d => delay80_q_net_x8,
      en => "1",
      rst => "0",
      q => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/fir_dbl_col1"

entity fir_dbl_col1_entity_e0284fea29 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    imag1: in std_logic_vector(15 downto 0); 
    imag2: in std_logic_vector(15 downto 0); 
    imag3: in std_logic_vector(15 downto 0); 
    imag4: in std_logic_vector(15 downto 0); 
    imag_back1: in std_logic_vector(15 downto 0); 
    imag_back2: in std_logic_vector(15 downto 0); 
    imag_back3: in std_logic_vector(15 downto 0); 
    imag_back4: in std_logic_vector(15 downto 0); 
    real1: in std_logic_vector(15 downto 0); 
    real2: in std_logic_vector(15 downto 0); 
    real3: in std_logic_vector(15 downto 0); 
    real4: in std_logic_vector(15 downto 0); 
    real_back1: in std_logic_vector(15 downto 0); 
    real_back2: in std_logic_vector(15 downto 0); 
    real_back3: in std_logic_vector(15 downto 0); 
    real_back4: in std_logic_vector(15 downto 0); 
    imag_out1: out std_logic_vector(15 downto 0); 
    imag_out2: out std_logic_vector(15 downto 0); 
    imag_out3: out std_logic_vector(15 downto 0); 
    imag_out4: out std_logic_vector(15 downto 0); 
    imag_sum: out std_logic_vector(43 downto 0); 
    real_out1: out std_logic_vector(15 downto 0); 
    real_out2: out std_logic_vector(15 downto 0); 
    real_out3: out std_logic_vector(15 downto 0); 
    real_out4: out std_logic_vector(15 downto 0); 
    real_sum: out std_logic_vector(43 downto 0)
  );
end fir_dbl_col1_entity_e0284fea29;

architecture structural of fir_dbl_col1_entity_e0284fea29 is
  signal addr3_s_net_x2: std_logic_vector(43 downto 0);
  signal addr3_s_net_x3: std_logic_vector(43 downto 0);
  signal ce_1_sg_x36: std_logic;
  signal clk_1_sg_x36: std_logic;
  signal delay80_q_net_x10: std_logic_vector(15 downto 0);
  signal delay80_q_net_x11: std_logic_vector(15 downto 0);
  signal delay80_q_net_x12: std_logic_vector(15 downto 0);
  signal delay80_q_net_x9: std_logic_vector(15 downto 0);
  signal delay82_q_net_x10: std_logic_vector(15 downto 0);
  signal delay82_q_net_x11: std_logic_vector(15 downto 0);
  signal delay82_q_net_x12: std_logic_vector(15 downto 0);
  signal delay82_q_net_x9: std_logic_vector(15 downto 0);
  signal mult0_p_net_x4: std_logic_vector(41 downto 0);
  signal mult0_p_net_x5: std_logic_vector(41 downto 0);
  signal mult0_p_net_x6: std_logic_vector(41 downto 0);
  signal mult0_p_net_x7: std_logic_vector(41 downto 0);
  signal mult1_p_net_x4: std_logic_vector(41 downto 0);
  signal mult1_p_net_x5: std_logic_vector(41 downto 0);
  signal mult1_p_net_x6: std_logic_vector(41 downto 0);
  signal mult1_p_net_x7: std_logic_vector(41 downto 0);
  signal register0_q_net_x4: std_logic_vector(15 downto 0);
  signal register0_q_net_x5: std_logic_vector(15 downto 0);
  signal register0_q_net_x6: std_logic_vector(15 downto 0);
  signal register0_q_net_x7: std_logic_vector(15 downto 0);
  signal register1_q_net_x4: std_logic_vector(15 downto 0);
  signal register1_q_net_x5: std_logic_vector(15 downto 0);
  signal register1_q_net_x6: std_logic_vector(15 downto 0);
  signal register1_q_net_x7: std_logic_vector(15 downto 0);
  signal register2_q_net_x4: std_logic_vector(15 downto 0);
  signal register2_q_net_x5: std_logic_vector(15 downto 0);
  signal register2_q_net_x6: std_logic_vector(15 downto 0);
  signal register2_q_net_x7: std_logic_vector(15 downto 0);
  signal register3_q_net_x4: std_logic_vector(15 downto 0);
  signal register3_q_net_x5: std_logic_vector(15 downto 0);
  signal register3_q_net_x6: std_logic_vector(15 downto 0);
  signal register3_q_net_x7: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x36 <= ce_1;
  clk_1_sg_x36 <= clk_1;
  delay80_q_net_x9 <= imag1;
  delay80_q_net_x10 <= imag2;
  delay80_q_net_x11 <= imag3;
  delay80_q_net_x12 <= imag4;
  register3_q_net_x7 <= imag_back1;
  register3_q_net_x6 <= imag_back2;
  register3_q_net_x5 <= imag_back3;
  register3_q_net_x4 <= imag_back4;
  delay82_q_net_x9 <= real1;
  delay82_q_net_x10 <= real2;
  delay82_q_net_x11 <= real3;
  delay82_q_net_x12 <= real4;
  register2_q_net_x7 <= real_back1;
  register2_q_net_x6 <= real_back2;
  register2_q_net_x5 <= real_back3;
  register2_q_net_x4 <= real_back4;
  imag_out1 <= register1_q_net_x4;
  imag_out2 <= register1_q_net_x5;
  imag_out3 <= register1_q_net_x6;
  imag_out4 <= register1_q_net_x7;
  imag_sum <= addr3_s_net_x3;
  real_out1 <= register0_q_net_x4;
  real_out2 <= register0_q_net_x5;
  real_out3 <= register0_q_net_x6;
  real_out4 <= register0_q_net_x7;
  real_sum <= addr3_s_net_x2;

  adder_tree1_1d0033c0f4: entity work.adder_tree1_entity_1d0033c0f4
    port map (
      ce_1 => ce_1_sg_x36,
      clk_1 => clk_1_sg_x36,
      din1 => mult0_p_net_x4,
      din2 => mult0_p_net_x5,
      din3 => mult0_p_net_x6,
      din4 => mult0_p_net_x7,
      dout => addr3_s_net_x2
    );

  adder_tree2_8ba6f8d67d: entity work.adder_tree1_entity_1d0033c0f4
    port map (
      ce_1 => ce_1_sg_x36,
      clk_1 => clk_1_sg_x36,
      din1 => mult1_p_net_x4,
      din2 => mult1_p_net_x5,
      din3 => mult1_p_net_x6,
      din4 => mult1_p_net_x7,
      dout => addr3_s_net_x3
    );

  fir_dbl_tap1_3f6ed236eb: entity work.fir_dbl_tap1_entity_3f6ed236eb
    port map (
      a => delay82_q_net_x9,
      b => delay80_q_net_x9,
      c => register2_q_net_x4,
      ce_1 => ce_1_sg_x36,
      clk_1 => clk_1_sg_x36,
      d => register3_q_net_x4,
      a_out => register0_q_net_x4,
      b_out => register1_q_net_x4,
      imag => mult1_p_net_x4,
      real_x0 => mult0_p_net_x4
    );

  fir_dbl_tap2_4888fc9b88: entity work.fir_dbl_tap2_entity_4888fc9b88
    port map (
      a => delay82_q_net_x10,
      b => delay80_q_net_x10,
      c => register2_q_net_x5,
      ce_1 => ce_1_sg_x36,
      clk_1 => clk_1_sg_x36,
      d => register3_q_net_x5,
      a_out => register0_q_net_x5,
      b_out => register1_q_net_x5,
      imag => mult1_p_net_x5,
      real_x0 => mult0_p_net_x5
    );

  fir_dbl_tap3_520a1ed3ca: entity work.fir_dbl_tap3_entity_520a1ed3ca
    port map (
      a => delay82_q_net_x11,
      b => delay80_q_net_x11,
      c => register2_q_net_x6,
      ce_1 => ce_1_sg_x36,
      clk_1 => clk_1_sg_x36,
      d => register3_q_net_x6,
      a_out => register0_q_net_x6,
      b_out => register1_q_net_x6,
      imag => mult1_p_net_x6,
      real_x0 => mult0_p_net_x6
    );

  fir_dbl_tap4_21a3cb2afe: entity work.fir_dbl_tap4_entity_21a3cb2afe
    port map (
      a => delay82_q_net_x12,
      b => delay80_q_net_x12,
      c => register2_q_net_x7,
      ce_1 => ce_1_sg_x36,
      clk_1 => clk_1_sg_x36,
      d => register3_q_net_x7,
      a_out => register0_q_net_x7,
      b_out => register1_q_net_x7,
      imag => mult1_p_net_x7,
      real_x0 => mult0_p_net_x7
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/fir_dbl_col2/fir_dbl_tap1"

entity fir_dbl_tap1_entity_9eec91448f is
  port (
    a: in std_logic_vector(15 downto 0); 
    b: in std_logic_vector(15 downto 0); 
    c: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(15 downto 0); 
    a_out: out std_logic_vector(15 downto 0); 
    b_out: out std_logic_vector(15 downto 0); 
    c_out: out std_logic_vector(15 downto 0); 
    d_out: out std_logic_vector(15 downto 0); 
    imag: out std_logic_vector(41 downto 0); 
    real_x0: out std_logic_vector(41 downto 0)
  );
end fir_dbl_tap1_entity_9eec91448f;

architecture structural of fir_dbl_tap1_entity_9eec91448f is
  signal addsub0_s_net: std_logic_vector(16 downto 0);
  signal addsub1_s_net: std_logic_vector(16 downto 0);
  signal ce_1_sg_x39: std_logic;
  signal clk_1_sg_x39: std_logic;
  signal coefficient_op_net: std_logic_vector(24 downto 0);
  signal mult0_p_net_x4: std_logic_vector(41 downto 0);
  signal mult1_p_net_x4: std_logic_vector(41 downto 0);
  signal register0_q_net_x1: std_logic_vector(15 downto 0);
  signal register0_q_net_x2: std_logic_vector(15 downto 0);
  signal register0_q_net_x5: std_logic_vector(15 downto 0);
  signal register1_q_net_x1: std_logic_vector(15 downto 0);
  signal register1_q_net_x2: std_logic_vector(15 downto 0);
  signal register1_q_net_x5: std_logic_vector(15 downto 0);
  signal register2_q_net_x5: std_logic_vector(15 downto 0);
  signal register3_q_net_x5: std_logic_vector(15 downto 0);

begin
  register0_q_net_x5 <= a;
  register1_q_net_x5 <= b;
  register0_q_net_x1 <= c;
  ce_1_sg_x39 <= ce_1;
  clk_1_sg_x39 <= clk_1;
  register1_q_net_x1 <= d;
  a_out <= register0_q_net_x2;
  b_out <= register1_q_net_x2;
  c_out <= register2_q_net_x5;
  d_out <= register3_q_net_x5;
  imag <= mult1_p_net_x4;
  real_x0 <= mult0_p_net_x4;

  addsub0: entity work.addsub_24e94e69df
    port map (
      a => register0_q_net_x5,
      b => register0_q_net_x1,
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      clr => '0',
      s => addsub0_s_net
    );

  addsub1: entity work.addsub_24e94e69df
    port map (
      a => register1_q_net_x5,
      b => register1_q_net_x1,
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      clr => '0',
      s => addsub1_s_net
    );

  coefficient: entity work.constant_33fc251917
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => coefficient_op_net
    );

  mult0: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub0_s_net,
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      clr => '0',
      p => mult0_p_net_x4
    );

  mult1: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub1_s_net,
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      clr => '0',
      p => mult1_p_net_x4
    );

  register0: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      d => register0_q_net_x5,
      en => "1",
      rst => "0",
      q => register0_q_net_x2
    );

  register1: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      d => register1_q_net_x5,
      en => "1",
      rst => "0",
      q => register1_q_net_x2
    );

  register2: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      d => register0_q_net_x1,
      en => "1",
      rst => "0",
      q => register2_q_net_x5
    );

  register3: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      d => register1_q_net_x1,
      en => "1",
      rst => "0",
      q => register3_q_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/fir_dbl_col2/fir_dbl_tap2"

entity fir_dbl_tap2_entity_b74dba73a5 is
  port (
    a: in std_logic_vector(15 downto 0); 
    b: in std_logic_vector(15 downto 0); 
    c: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(15 downto 0); 
    a_out: out std_logic_vector(15 downto 0); 
    b_out: out std_logic_vector(15 downto 0); 
    c_out: out std_logic_vector(15 downto 0); 
    d_out: out std_logic_vector(15 downto 0); 
    imag: out std_logic_vector(41 downto 0); 
    real_x0: out std_logic_vector(41 downto 0)
  );
end fir_dbl_tap2_entity_b74dba73a5;

architecture structural of fir_dbl_tap2_entity_b74dba73a5 is
  signal addsub0_s_net: std_logic_vector(16 downto 0);
  signal addsub1_s_net: std_logic_vector(16 downto 0);
  signal ce_1_sg_x40: std_logic;
  signal clk_1_sg_x40: std_logic;
  signal coefficient_op_net: std_logic_vector(24 downto 0);
  signal mult0_p_net_x5: std_logic_vector(41 downto 0);
  signal mult1_p_net_x5: std_logic_vector(41 downto 0);
  signal register0_q_net_x1: std_logic_vector(15 downto 0);
  signal register0_q_net_x2: std_logic_vector(15 downto 0);
  signal register0_q_net_x6: std_logic_vector(15 downto 0);
  signal register1_q_net_x1: std_logic_vector(15 downto 0);
  signal register1_q_net_x2: std_logic_vector(15 downto 0);
  signal register1_q_net_x6: std_logic_vector(15 downto 0);
  signal register2_q_net_x6: std_logic_vector(15 downto 0);
  signal register3_q_net_x6: std_logic_vector(15 downto 0);

begin
  register0_q_net_x6 <= a;
  register1_q_net_x6 <= b;
  register0_q_net_x1 <= c;
  ce_1_sg_x40 <= ce_1;
  clk_1_sg_x40 <= clk_1;
  register1_q_net_x1 <= d;
  a_out <= register0_q_net_x2;
  b_out <= register1_q_net_x2;
  c_out <= register2_q_net_x6;
  d_out <= register3_q_net_x6;
  imag <= mult1_p_net_x5;
  real_x0 <= mult0_p_net_x5;

  addsub0: entity work.addsub_24e94e69df
    port map (
      a => register0_q_net_x6,
      b => register0_q_net_x1,
      ce => ce_1_sg_x40,
      clk => clk_1_sg_x40,
      clr => '0',
      s => addsub0_s_net
    );

  addsub1: entity work.addsub_24e94e69df
    port map (
      a => register1_q_net_x6,
      b => register1_q_net_x1,
      ce => ce_1_sg_x40,
      clk => clk_1_sg_x40,
      clr => '0',
      s => addsub1_s_net
    );

  coefficient: entity work.constant_fd4ba908f2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => coefficient_op_net
    );

  mult0: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub0_s_net,
      ce => ce_1_sg_x40,
      clk => clk_1_sg_x40,
      clr => '0',
      p => mult0_p_net_x5
    );

  mult1: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub1_s_net,
      ce => ce_1_sg_x40,
      clk => clk_1_sg_x40,
      clr => '0',
      p => mult1_p_net_x5
    );

  register0: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x40,
      clk => clk_1_sg_x40,
      d => register0_q_net_x6,
      en => "1",
      rst => "0",
      q => register0_q_net_x2
    );

  register1: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x40,
      clk => clk_1_sg_x40,
      d => register1_q_net_x6,
      en => "1",
      rst => "0",
      q => register1_q_net_x2
    );

  register2: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x40,
      clk => clk_1_sg_x40,
      d => register0_q_net_x1,
      en => "1",
      rst => "0",
      q => register2_q_net_x6
    );

  register3: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x40,
      clk => clk_1_sg_x40,
      d => register1_q_net_x1,
      en => "1",
      rst => "0",
      q => register3_q_net_x6
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/fir_dbl_col2/fir_dbl_tap3"

entity fir_dbl_tap3_entity_f61fc3b7b1 is
  port (
    a: in std_logic_vector(15 downto 0); 
    b: in std_logic_vector(15 downto 0); 
    c: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(15 downto 0); 
    a_out: out std_logic_vector(15 downto 0); 
    b_out: out std_logic_vector(15 downto 0); 
    c_out: out std_logic_vector(15 downto 0); 
    d_out: out std_logic_vector(15 downto 0); 
    imag: out std_logic_vector(41 downto 0); 
    real_x0: out std_logic_vector(41 downto 0)
  );
end fir_dbl_tap3_entity_f61fc3b7b1;

architecture structural of fir_dbl_tap3_entity_f61fc3b7b1 is
  signal addsub0_s_net: std_logic_vector(16 downto 0);
  signal addsub1_s_net: std_logic_vector(16 downto 0);
  signal ce_1_sg_x41: std_logic;
  signal clk_1_sg_x41: std_logic;
  signal coefficient_op_net: std_logic_vector(24 downto 0);
  signal mult0_p_net_x6: std_logic_vector(41 downto 0);
  signal mult1_p_net_x6: std_logic_vector(41 downto 0);
  signal register0_q_net_x3: std_logic_vector(15 downto 0);
  signal register0_q_net_x4: std_logic_vector(15 downto 0);
  signal register0_q_net_x7: std_logic_vector(15 downto 0);
  signal register1_q_net_x3: std_logic_vector(15 downto 0);
  signal register1_q_net_x4: std_logic_vector(15 downto 0);
  signal register1_q_net_x7: std_logic_vector(15 downto 0);
  signal register2_q_net_x7: std_logic_vector(15 downto 0);
  signal register3_q_net_x7: std_logic_vector(15 downto 0);

begin
  register0_q_net_x7 <= a;
  register1_q_net_x7 <= b;
  register0_q_net_x3 <= c;
  ce_1_sg_x41 <= ce_1;
  clk_1_sg_x41 <= clk_1;
  register1_q_net_x3 <= d;
  a_out <= register0_q_net_x4;
  b_out <= register1_q_net_x4;
  c_out <= register2_q_net_x7;
  d_out <= register3_q_net_x7;
  imag <= mult1_p_net_x6;
  real_x0 <= mult0_p_net_x6;

  addsub0: entity work.addsub_24e94e69df
    port map (
      a => register0_q_net_x7,
      b => register0_q_net_x3,
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      clr => '0',
      s => addsub0_s_net
    );

  addsub1: entity work.addsub_24e94e69df
    port map (
      a => register1_q_net_x7,
      b => register1_q_net_x3,
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      clr => '0',
      s => addsub1_s_net
    );

  coefficient: entity work.constant_d404083146
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => coefficient_op_net
    );

  mult0: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub0_s_net,
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      clr => '0',
      p => mult0_p_net_x6
    );

  mult1: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub1_s_net,
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      clr => '0',
      p => mult1_p_net_x6
    );

  register0: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      d => register0_q_net_x7,
      en => "1",
      rst => "0",
      q => register0_q_net_x4
    );

  register1: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      d => register1_q_net_x7,
      en => "1",
      rst => "0",
      q => register1_q_net_x4
    );

  register2: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      d => register0_q_net_x3,
      en => "1",
      rst => "0",
      q => register2_q_net_x7
    );

  register3: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      d => register1_q_net_x3,
      en => "1",
      rst => "0",
      q => register3_q_net_x7
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/fir_dbl_col2/fir_dbl_tap4"

entity fir_dbl_tap4_entity_9b06e238f7 is
  port (
    a: in std_logic_vector(15 downto 0); 
    b: in std_logic_vector(15 downto 0); 
    c: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(15 downto 0); 
    a_out: out std_logic_vector(15 downto 0); 
    b_out: out std_logic_vector(15 downto 0); 
    c_out: out std_logic_vector(15 downto 0); 
    d_out: out std_logic_vector(15 downto 0); 
    imag: out std_logic_vector(41 downto 0); 
    real_x0: out std_logic_vector(41 downto 0)
  );
end fir_dbl_tap4_entity_9b06e238f7;

architecture structural of fir_dbl_tap4_entity_9b06e238f7 is
  signal addsub0_s_net: std_logic_vector(16 downto 0);
  signal addsub1_s_net: std_logic_vector(16 downto 0);
  signal ce_1_sg_x42: std_logic;
  signal clk_1_sg_x42: std_logic;
  signal coefficient_op_net: std_logic_vector(24 downto 0);
  signal mult0_p_net_x7: std_logic_vector(41 downto 0);
  signal mult1_p_net_x7: std_logic_vector(41 downto 0);
  signal register0_q_net_x3: std_logic_vector(15 downto 0);
  signal register0_q_net_x8: std_logic_vector(15 downto 0);
  signal register0_q_net_x9: std_logic_vector(15 downto 0);
  signal register1_q_net_x3: std_logic_vector(15 downto 0);
  signal register1_q_net_x8: std_logic_vector(15 downto 0);
  signal register1_q_net_x9: std_logic_vector(15 downto 0);
  signal register2_q_net_x8: std_logic_vector(15 downto 0);
  signal register3_q_net_x8: std_logic_vector(15 downto 0);

begin
  register0_q_net_x8 <= a;
  register1_q_net_x8 <= b;
  register0_q_net_x3 <= c;
  ce_1_sg_x42 <= ce_1;
  clk_1_sg_x42 <= clk_1;
  register1_q_net_x3 <= d;
  a_out <= register0_q_net_x9;
  b_out <= register1_q_net_x9;
  c_out <= register2_q_net_x8;
  d_out <= register3_q_net_x8;
  imag <= mult1_p_net_x7;
  real_x0 <= mult0_p_net_x7;

  addsub0: entity work.addsub_24e94e69df
    port map (
      a => register0_q_net_x8,
      b => register0_q_net_x3,
      ce => ce_1_sg_x42,
      clk => clk_1_sg_x42,
      clr => '0',
      s => addsub0_s_net
    );

  addsub1: entity work.addsub_24e94e69df
    port map (
      a => register1_q_net_x8,
      b => register1_q_net_x3,
      ce => ce_1_sg_x42,
      clk => clk_1_sg_x42,
      clr => '0',
      s => addsub1_s_net
    );

  coefficient: entity work.constant_d4afade44e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => coefficient_op_net
    );

  mult0: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub0_s_net,
      ce => ce_1_sg_x42,
      clk => clk_1_sg_x42,
      clr => '0',
      p => mult0_p_net_x7
    );

  mult1: entity work.mult_931970af87
    port map (
      a => coefficient_op_net,
      b => addsub1_s_net,
      ce => ce_1_sg_x42,
      clk => clk_1_sg_x42,
      clr => '0',
      p => mult1_p_net_x7
    );

  register0: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x42,
      clk => clk_1_sg_x42,
      d => register0_q_net_x8,
      en => "1",
      rst => "0",
      q => register0_q_net_x9
    );

  register1: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x42,
      clk => clk_1_sg_x42,
      d => register1_q_net_x8,
      en => "1",
      rst => "0",
      q => register1_q_net_x9
    );

  register2: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x42,
      clk => clk_1_sg_x42,
      d => register0_q_net_x3,
      en => "1",
      rst => "0",
      q => register2_q_net_x8
    );

  register3: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x42,
      clk => clk_1_sg_x42,
      d => register1_q_net_x3,
      en => "1",
      rst => "0",
      q => register3_q_net_x8
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/fir_dbl_col2"

entity fir_dbl_col2_entity_81b6f0e5e5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    imag1: in std_logic_vector(15 downto 0); 
    imag2: in std_logic_vector(15 downto 0); 
    imag3: in std_logic_vector(15 downto 0); 
    imag4: in std_logic_vector(15 downto 0); 
    real1: in std_logic_vector(15 downto 0); 
    real2: in std_logic_vector(15 downto 0); 
    real3: in std_logic_vector(15 downto 0); 
    real4: in std_logic_vector(15 downto 0); 
    imag_back_out1: out std_logic_vector(15 downto 0); 
    imag_back_out2: out std_logic_vector(15 downto 0); 
    imag_back_out3: out std_logic_vector(15 downto 0); 
    imag_back_out4: out std_logic_vector(15 downto 0); 
    imag_sum: out std_logic_vector(43 downto 0); 
    real_back_out1: out std_logic_vector(15 downto 0); 
    real_back_out2: out std_logic_vector(15 downto 0); 
    real_back_out3: out std_logic_vector(15 downto 0); 
    real_back_out4: out std_logic_vector(15 downto 0); 
    real_sum: out std_logic_vector(43 downto 0)
  );
end fir_dbl_col2_entity_81b6f0e5e5;

architecture structural of fir_dbl_col2_entity_81b6f0e5e5 is
  signal addr3_s_net_x2: std_logic_vector(43 downto 0);
  signal addr3_s_net_x3: std_logic_vector(43 downto 0);
  signal ce_1_sg_x43: std_logic;
  signal clk_1_sg_x43: std_logic;
  signal mult0_p_net_x4: std_logic_vector(41 downto 0);
  signal mult0_p_net_x5: std_logic_vector(41 downto 0);
  signal mult0_p_net_x6: std_logic_vector(41 downto 0);
  signal mult0_p_net_x7: std_logic_vector(41 downto 0);
  signal mult1_p_net_x4: std_logic_vector(41 downto 0);
  signal mult1_p_net_x5: std_logic_vector(41 downto 0);
  signal mult1_p_net_x6: std_logic_vector(41 downto 0);
  signal mult1_p_net_x7: std_logic_vector(41 downto 0);
  signal register0_q_net_x10: std_logic_vector(15 downto 0);
  signal register0_q_net_x11: std_logic_vector(15 downto 0);
  signal register0_q_net_x12: std_logic_vector(15 downto 0);
  signal register0_q_net_x13: std_logic_vector(15 downto 0);
  signal register0_q_net_x14: std_logic_vector(15 downto 0);
  signal register0_q_net_x3: std_logic_vector(15 downto 0);
  signal register0_q_net_x4: std_logic_vector(15 downto 0);
  signal register0_q_net_x9: std_logic_vector(15 downto 0);
  signal register1_q_net_x10: std_logic_vector(15 downto 0);
  signal register1_q_net_x11: std_logic_vector(15 downto 0);
  signal register1_q_net_x12: std_logic_vector(15 downto 0);
  signal register1_q_net_x13: std_logic_vector(15 downto 0);
  signal register1_q_net_x14: std_logic_vector(15 downto 0);
  signal register1_q_net_x3: std_logic_vector(15 downto 0);
  signal register1_q_net_x4: std_logic_vector(15 downto 0);
  signal register1_q_net_x9: std_logic_vector(15 downto 0);
  signal register2_q_net_x10: std_logic_vector(15 downto 0);
  signal register2_q_net_x11: std_logic_vector(15 downto 0);
  signal register2_q_net_x12: std_logic_vector(15 downto 0);
  signal register2_q_net_x9: std_logic_vector(15 downto 0);
  signal register3_q_net_x10: std_logic_vector(15 downto 0);
  signal register3_q_net_x11: std_logic_vector(15 downto 0);
  signal register3_q_net_x12: std_logic_vector(15 downto 0);
  signal register3_q_net_x9: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x43 <= ce_1;
  clk_1_sg_x43 <= clk_1;
  register1_q_net_x11 <= imag1;
  register1_q_net_x12 <= imag2;
  register1_q_net_x13 <= imag3;
  register1_q_net_x14 <= imag4;
  register0_q_net_x11 <= real1;
  register0_q_net_x12 <= real2;
  register0_q_net_x13 <= real3;
  register0_q_net_x14 <= real4;
  imag_back_out1 <= register3_q_net_x12;
  imag_back_out2 <= register3_q_net_x11;
  imag_back_out3 <= register3_q_net_x10;
  imag_back_out4 <= register3_q_net_x9;
  imag_sum <= addr3_s_net_x3;
  real_back_out1 <= register2_q_net_x12;
  real_back_out2 <= register2_q_net_x11;
  real_back_out3 <= register2_q_net_x10;
  real_back_out4 <= register2_q_net_x9;
  real_sum <= addr3_s_net_x2;

  adder_tree1_a1e60a41ee: entity work.adder_tree1_entity_1d0033c0f4
    port map (
      ce_1 => ce_1_sg_x43,
      clk_1 => clk_1_sg_x43,
      din1 => mult0_p_net_x4,
      din2 => mult0_p_net_x5,
      din3 => mult0_p_net_x6,
      din4 => mult0_p_net_x7,
      dout => addr3_s_net_x2
    );

  adder_tree2_bd806c28fb: entity work.adder_tree1_entity_1d0033c0f4
    port map (
      ce_1 => ce_1_sg_x43,
      clk_1 => clk_1_sg_x43,
      din1 => mult1_p_net_x4,
      din2 => mult1_p_net_x5,
      din3 => mult1_p_net_x6,
      din4 => mult1_p_net_x7,
      dout => addr3_s_net_x3
    );

  fir_dbl_tap1_9eec91448f: entity work.fir_dbl_tap1_entity_9eec91448f
    port map (
      a => register0_q_net_x11,
      b => register1_q_net_x11,
      c => register0_q_net_x10,
      ce_1 => ce_1_sg_x43,
      clk_1 => clk_1_sg_x43,
      d => register1_q_net_x10,
      a_out => register0_q_net_x3,
      b_out => register1_q_net_x3,
      c_out => register2_q_net_x9,
      d_out => register3_q_net_x9,
      imag => mult1_p_net_x4,
      real_x0 => mult0_p_net_x4
    );

  fir_dbl_tap2_b74dba73a5: entity work.fir_dbl_tap2_entity_b74dba73a5
    port map (
      a => register0_q_net_x12,
      b => register1_q_net_x12,
      c => register0_q_net_x4,
      ce_1 => ce_1_sg_x43,
      clk_1 => clk_1_sg_x43,
      d => register1_q_net_x4,
      a_out => register0_q_net_x9,
      b_out => register1_q_net_x9,
      c_out => register2_q_net_x10,
      d_out => register3_q_net_x10,
      imag => mult1_p_net_x5,
      real_x0 => mult0_p_net_x5
    );

  fir_dbl_tap3_f61fc3b7b1: entity work.fir_dbl_tap3_entity_f61fc3b7b1
    port map (
      a => register0_q_net_x13,
      b => register1_q_net_x13,
      c => register0_q_net_x9,
      ce_1 => ce_1_sg_x43,
      clk_1 => clk_1_sg_x43,
      d => register1_q_net_x9,
      a_out => register0_q_net_x4,
      b_out => register1_q_net_x4,
      c_out => register2_q_net_x11,
      d_out => register3_q_net_x11,
      imag => mult1_p_net_x6,
      real_x0 => mult0_p_net_x6
    );

  fir_dbl_tap4_9b06e238f7: entity work.fir_dbl_tap4_entity_9b06e238f7
    port map (
      a => register0_q_net_x14,
      b => register1_q_net_x14,
      c => register0_q_net_x3,
      ce_1 => ce_1_sg_x43,
      clk_1 => clk_1_sg_x43,
      d => register1_q_net_x3,
      a_out => register0_q_net_x10,
      b_out => register1_q_net_x10,
      c_out => register2_q_net_x12,
      d_out => register3_q_net_x12,
      imag => mult1_p_net_x7,
      real_x0 => mult0_p_net_x7
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/imag_sum"

entity imag_sum_entity_b89109dd63 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din1: in std_logic_vector(43 downto 0); 
    din2: in std_logic_vector(43 downto 0); 
    dout: out std_logic_vector(44 downto 0)
  );
end imag_sum_entity_b89109dd63;

architecture structural of imag_sum_entity_b89109dd63 is
  signal addr1_s_net_x0: std_logic_vector(44 downto 0);
  signal addr3_s_net_x5: std_logic_vector(43 downto 0);
  signal addr3_s_net_x6: std_logic_vector(43 downto 0);
  signal ce_1_sg_x44: std_logic;
  signal clk_1_sg_x44: std_logic;

begin
  ce_1_sg_x44 <= ce_1;
  clk_1_sg_x44 <= clk_1;
  addr3_s_net_x5 <= din1;
  addr3_s_net_x6 <= din2;
  dout <= addr1_s_net_x0;

  addr1: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 39,
      a_width => 44,
      b_arith => xlSigned,
      b_bin_pt => 39,
      b_width => 44,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 45,
      core_name0 => "addsb_11_0_41035397f321bdbe",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 45,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 39,
      s_width => 45
    )
    port map (
      a => addr3_s_net_x5,
      b => addr3_s_net_x6,
      ce => ce_1_sg_x44,
      clk => clk_1_sg_x44,
      clr => '0',
      en => "1",
      s => addr1_s_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/real_sum"

entity real_sum_entity_5943ce2178 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din1: in std_logic_vector(43 downto 0); 
    din2: in std_logic_vector(43 downto 0); 
    sync: in std_logic; 
    dout: out std_logic_vector(44 downto 0); 
    sync_out: out std_logic
  );
end real_sum_entity_5943ce2178;

architecture structural of real_sum_entity_5943ce2178 is
  signal addr1_s_net_x0: std_logic_vector(44 downto 0);
  signal addr3_s_net_x4: std_logic_vector(43 downto 0);
  signal addr3_s_net_x5: std_logic_vector(43 downto 0);
  signal ce_1_sg_x45: std_logic;
  signal clk_1_sg_x45: std_logic;
  signal delay_q_net_x0: std_logic;
  signal sync_delay_q_net_x0: std_logic;

begin
  ce_1_sg_x45 <= ce_1;
  clk_1_sg_x45 <= clk_1;
  addr3_s_net_x4 <= din1;
  addr3_s_net_x5 <= din2;
  delay_q_net_x0 <= sync;
  dout <= addr1_s_net_x0;
  sync_out <= sync_delay_q_net_x0;

  addr1: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 39,
      a_width => 44,
      b_arith => xlSigned,
      b_bin_pt => 39,
      b_width => 44,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 45,
      core_name0 => "addsb_11_0_41035397f321bdbe",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 45,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 39,
      s_width => 45
    )
    port map (
      a => addr3_s_net_x4,
      b => addr3_s_net_x5,
      ce => ce_1_sg_x45,
      clk => clk_1_sg_x45,
      clr => '0',
      en => "1",
      s => addr1_s_net_x0
    );

  sync_delay: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x45,
      clk => clk_1_sg_x45,
      clr => '0',
      d(0) => delay_q_net_x0,
      q(0) => sync_delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir/ri_to_c"

entity ri_to_c_entity_7f4e335b98 is
  port (
    im: in std_logic_vector(15 downto 0); 
    re: in std_logic_vector(15 downto 0); 
    c: out std_logic_vector(31 downto 0)
  );
end ri_to_c_entity_7f4e335b98;

architecture structural of ri_to_c_entity_7f4e335b98 is
  signal concat_y_net_x1: std_logic_vector(31 downto 0);
  signal convert1_dout_net_x0: std_logic_vector(15 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(15 downto 0);
  signal force_im_output_port_net: std_logic_vector(15 downto 0);
  signal force_re_output_port_net: std_logic_vector(15 downto 0);

begin
  convert2_dout_net_x0 <= im;
  convert1_dout_net_x0 <= re;
  c <= concat_y_net_x1;

  concat: entity work.concat_a369e00c6b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x1
    );

  force_im: entity work.reinterpret_7025463ea8
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert2_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_7025463ea8
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert1_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/dec_fir"

entity dec_fir_entity_ce31f24969 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    imag1: in std_logic_vector(15 downto 0); 
    imag2: in std_logic_vector(15 downto 0); 
    imag3: in std_logic_vector(15 downto 0); 
    imag4: in std_logic_vector(15 downto 0); 
    real1: in std_logic_vector(15 downto 0); 
    real2: in std_logic_vector(15 downto 0); 
    real3: in std_logic_vector(15 downto 0); 
    real4: in std_logic_vector(15 downto 0); 
    sync_in: in std_logic; 
    dout: out std_logic_vector(31 downto 0); 
    sync_out: out std_logic
  );
end dec_fir_entity_ce31f24969;

architecture structural of dec_fir_entity_ce31f24969 is
  signal addr1_s_net_x0: std_logic_vector(44 downto 0);
  signal addr1_s_net_x1: std_logic_vector(44 downto 0);
  signal addr3_s_net_x4: std_logic_vector(43 downto 0);
  signal addr3_s_net_x5: std_logic_vector(43 downto 0);
  signal addr3_s_net_x6: std_logic_vector(43 downto 0);
  signal addr3_s_net_x7: std_logic_vector(43 downto 0);
  signal ce_1_sg_x46: std_logic;
  signal clk_1_sg_x46: std_logic;
  signal concat_y_net_x2: std_logic_vector(31 downto 0);
  signal convert1_dout_net_x0: std_logic_vector(15 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(15 downto 0);
  signal delay80_q_net_x13: std_logic_vector(15 downto 0);
  signal delay80_q_net_x14: std_logic_vector(15 downto 0);
  signal delay80_q_net_x15: std_logic_vector(15 downto 0);
  signal delay80_q_net_x16: std_logic_vector(15 downto 0);
  signal delay82_q_net_x13: std_logic_vector(15 downto 0);
  signal delay82_q_net_x14: std_logic_vector(15 downto 0);
  signal delay82_q_net_x15: std_logic_vector(15 downto 0);
  signal delay82_q_net_x16: std_logic_vector(15 downto 0);
  signal delay_q_net_x0: std_logic;
  signal edge_op_y_net_x0: std_logic;
  signal register0_q_net_x11: std_logic_vector(15 downto 0);
  signal register0_q_net_x12: std_logic_vector(15 downto 0);
  signal register0_q_net_x13: std_logic_vector(15 downto 0);
  signal register0_q_net_x14: std_logic_vector(15 downto 0);
  signal register1_q_net_x11: std_logic_vector(15 downto 0);
  signal register1_q_net_x12: std_logic_vector(15 downto 0);
  signal register1_q_net_x13: std_logic_vector(15 downto 0);
  signal register1_q_net_x14: std_logic_vector(15 downto 0);
  signal register2_q_net_x10: std_logic_vector(15 downto 0);
  signal register2_q_net_x11: std_logic_vector(15 downto 0);
  signal register2_q_net_x12: std_logic_vector(15 downto 0);
  signal register2_q_net_x9: std_logic_vector(15 downto 0);
  signal register3_q_net_x10: std_logic_vector(15 downto 0);
  signal register3_q_net_x11: std_logic_vector(15 downto 0);
  signal register3_q_net_x12: std_logic_vector(15 downto 0);
  signal register3_q_net_x9: std_logic_vector(15 downto 0);
  signal shift1_op_net: std_logic_vector(44 downto 0);
  signal shift2_op_net: std_logic_vector(44 downto 0);
  signal sync_delay_q_net_x1: std_logic;

begin
  ce_1_sg_x46 <= ce_1;
  clk_1_sg_x46 <= clk_1;
  delay80_q_net_x13 <= imag1;
  delay80_q_net_x14 <= imag2;
  delay80_q_net_x15 <= imag3;
  delay80_q_net_x16 <= imag4;
  delay82_q_net_x13 <= real1;
  delay82_q_net_x14 <= real2;
  delay82_q_net_x15 <= real3;
  delay82_q_net_x16 <= real4;
  edge_op_y_net_x0 <= sync_in;
  dout <= concat_y_net_x2;
  sync_out <= sync_delay_q_net_x1;

  convert1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 39,
      din_width => 45,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 16,
      latency => 2,
      overflow => xlWrap,
      quantization => xlRound
    )
    port map (
      ce => ce_1_sg_x46,
      clk => clk_1_sg_x46,
      clr => '0',
      din => shift1_op_net,
      en => "1",
      dout => convert1_dout_net_x0
    );

  convert2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 39,
      din_width => 45,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 16,
      latency => 2,
      overflow => xlWrap,
      quantization => xlRound
    )
    port map (
      ce => ce_1_sg_x46,
      clk => clk_1_sg_x46,
      clr => '0',
      din => shift2_op_net,
      en => "1",
      dout => convert2_dout_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 7,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x46,
      clk => clk_1_sg_x46,
      d(0) => edge_op_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay_q_net_x0
    );

  fir_dbl_col1_e0284fea29: entity work.fir_dbl_col1_entity_e0284fea29
    port map (
      ce_1 => ce_1_sg_x46,
      clk_1 => clk_1_sg_x46,
      imag1 => delay80_q_net_x13,
      imag2 => delay80_q_net_x14,
      imag3 => delay80_q_net_x15,
      imag4 => delay80_q_net_x16,
      imag_back1 => register3_q_net_x12,
      imag_back2 => register3_q_net_x11,
      imag_back3 => register3_q_net_x10,
      imag_back4 => register3_q_net_x9,
      real1 => delay82_q_net_x13,
      real2 => delay82_q_net_x14,
      real3 => delay82_q_net_x15,
      real4 => delay82_q_net_x16,
      real_back1 => register2_q_net_x12,
      real_back2 => register2_q_net_x11,
      real_back3 => register2_q_net_x10,
      real_back4 => register2_q_net_x9,
      imag_out1 => register1_q_net_x11,
      imag_out2 => register1_q_net_x12,
      imag_out3 => register1_q_net_x13,
      imag_out4 => register1_q_net_x14,
      imag_sum => addr3_s_net_x5,
      real_out1 => register0_q_net_x11,
      real_out2 => register0_q_net_x12,
      real_out3 => register0_q_net_x13,
      real_out4 => register0_q_net_x14,
      real_sum => addr3_s_net_x4
    );

  fir_dbl_col2_81b6f0e5e5: entity work.fir_dbl_col2_entity_81b6f0e5e5
    port map (
      ce_1 => ce_1_sg_x46,
      clk_1 => clk_1_sg_x46,
      imag1 => register1_q_net_x11,
      imag2 => register1_q_net_x12,
      imag3 => register1_q_net_x13,
      imag4 => register1_q_net_x14,
      real1 => register0_q_net_x11,
      real2 => register0_q_net_x12,
      real3 => register0_q_net_x13,
      real4 => register0_q_net_x14,
      imag_back_out1 => register3_q_net_x12,
      imag_back_out2 => register3_q_net_x11,
      imag_back_out3 => register3_q_net_x10,
      imag_back_out4 => register3_q_net_x9,
      imag_sum => addr3_s_net_x7,
      real_back_out1 => register2_q_net_x12,
      real_back_out2 => register2_q_net_x11,
      real_back_out3 => register2_q_net_x10,
      real_back_out4 => register2_q_net_x9,
      real_sum => addr3_s_net_x6
    );

  imag_sum_b89109dd63: entity work.imag_sum_entity_b89109dd63
    port map (
      ce_1 => ce_1_sg_x46,
      clk_1 => clk_1_sg_x46,
      din1 => addr3_s_net_x5,
      din2 => addr3_s_net_x7,
      dout => addr1_s_net_x0
    );

  real_sum_5943ce2178: entity work.real_sum_entity_5943ce2178
    port map (
      ce_1 => ce_1_sg_x46,
      clk_1 => clk_1_sg_x46,
      din1 => addr3_s_net_x4,
      din2 => addr3_s_net_x6,
      sync => delay_q_net_x0,
      dout => addr1_s_net_x1,
      sync_out => sync_delay_q_net_x1
    );

  ri_to_c_7f4e335b98: entity work.ri_to_c_entity_7f4e335b98
    port map (
      im => convert2_dout_net_x0,
      re => convert1_dout_net_x0,
      c => concat_y_net_x2
    );

  shift1: entity work.shift_92df6a3714
    port map (
      ce => ce_1_sg_x46,
      clk => clk_1_sg_x46,
      clr => '0',
      ip => addr1_s_net_x1,
      op => shift1_op_net
    );

  shift2: entity work.shift_92df6a3714
    port map (
      ce => ce_1_sg_x46,
      clk => clk_1_sg_x46,
      clr => '0',
      ip => addr1_s_net_x0,
      op => shift2_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/even_window1/calc_add"

entity calc_add_entity_8208690392 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(9 downto 0); 
    out_x0: out std_logic_vector(9 downto 0)
  );
end calc_add_entity_8208690392;

architecture structural of calc_add_entity_8208690392 is
  signal add_sub_s_net: std_logic;
  signal ce_1_sg_x64: std_logic;
  signal clk_1_sg_x64: std_logic;
  signal concat_y_net: std_logic_vector(9 downto 0);
  signal const_op_net: std_logic;
  signal convert_addr_dout_net: std_logic_vector(9 downto 0);
  signal lsw_y_net: std_logic;
  signal manipulate_op_net: std_logic;
  signal msw_y_net: std_logic_vector(8 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal register0_q_net_x0: std_logic_vector(9 downto 0);

begin
  ce_1_sg_x64 <= ce_1;
  clk_1_sg_x64 <= clk_1;
  register0_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x0;

  add_sub: entity work.addsub_c13097e33e
    port map (
      a(0) => const_op_net,
      b(0) => lsw_y_net,
      ce => ce_1_sg_x64,
      clk => clk_1_sg_x64,
      clr => '0',
      s(0) => add_sub_s_net
    );

  concat: entity work.concat_1d98d96b58
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => msw_y_net,
      in1(0) => add_sub_s_net,
      y => concat_y_net
    );

  const: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => const_op_net
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x64,
      clk => clk_1_sg_x64,
      clr => '0',
      din => register0_q_net_x0,
      en => "1",
      dout => convert_addr_dout_net
    );

  lsw: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 10,
      y_width => 1
    )
    port map (
      x => convert_addr_dout_net,
      y(0) => lsw_y_net
    );

  manipulate: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => manipulate_op_net
    );

  msw: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 9,
      x_width => 10,
      y_width => 9
    )
    port map (
      x => convert_addr_dout_net,
      y => msw_y_net
    );

  mux: entity work.mux_4fe5face7f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => convert_addr_dout_net,
      d1 => concat_y_net,
      sel(0) => manipulate_op_net,
      y => mux_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/even_window1/munge_in/join"

entity join_entity_fe455e2c8a is
  port (
    in1: in std_logic_vector(31 downto 0); 
    in2: in std_logic_vector(31 downto 0); 
    bus_out: out std_logic_vector(63 downto 0)
  );
end join_entity_fe455e2c8a;

architecture structural of join_entity_fe455e2c8a is
  signal concatenate_y_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(31 downto 0);

begin
  reinterpret1_output_port_net_x1 <= in1;
  reinterpret2_output_port_net_x1 <= in2;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_62c4475a80
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret1_output_port_net_x1,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret2_output_port_net_x1,
      output_port => reinterpret2_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/even_window1/munge_in/split"

entity split_entity_0fe924fead is
  port (
    bus_in: in std_logic_vector(63 downto 0); 
    lsb_out1: out std_logic_vector(31 downto 0); 
    msb_out2: out std_logic_vector(31 downto 0)
  );
end split_entity_0fe924fead;

architecture structural of split_entity_0fe924fead is
  signal reinterpret1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reinterpret_output_port_net_x0: std_logic_vector(63 downto 0);
  signal slice1_y_net: std_logic_vector(31 downto 0);
  signal slice2_y_net: std_logic_vector(31 downto 0);

begin
  reinterpret_output_port_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x2;
  msb_out2 <= reinterpret2_output_port_net_x2;

  reinterpret1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x2
    );

  reinterpret2: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 64,
      y_width => 32
    )
    port map (
      x => reinterpret_output_port_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 32,
      new_msb => 63,
      x_width => 64,
      y_width => 32
    )
    port map (
      x => reinterpret_output_port_net_x0,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/even_window1/munge_in"

entity munge_in_entity_c955364027 is
  port (
    din: in std_logic_vector(63 downto 0); 
    dout: out std_logic_vector(63 downto 0)
  );
end munge_in_entity_c955364027;

architecture structural of munge_in_entity_c955364027 is
  signal concatenate_y_net_x0: std_logic_vector(63 downto 0);
  signal register0_q_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret_output_port_net_x0: std_logic_vector(63 downto 0);

begin
  register0_q_net_x0 <= din;
  dout <= reinterpret_out_output_port_net_x0;

  join_fe455e2c8a: entity work.join_entity_fe455e2c8a
    port map (
      in1 => reinterpret1_output_port_net_x2,
      in2 => reinterpret2_output_port_net_x2,
      bus_out => concatenate_y_net_x0
    );

  reinterpret: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register0_q_net_x0,
      output_port => reinterpret_output_port_net_x0
    );

  reinterpret_out: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concatenate_y_net_x0,
      output_port => reinterpret_out_output_port_net_x0
    );

  split_0fe924fead: entity work.split_entity_0fe924fead
    port map (
      bus_in => reinterpret_output_port_net_x0,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out2 => reinterpret2_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/even_window1"

entity even_window1_entity_a08cd2ecfc is
  port (
    addr: in std_logic_vector(9 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(63 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(63 downto 0); 
    convert_we_x0: out std_logic
  );
end even_window1_entity_a08cd2ecfc;

architecture structural of even_window1_entity_a08cd2ecfc is
  signal ce_1_sg_x65: std_logic;
  signal clk_1_sg_x65: std_logic;
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal register0_q_net_x2: std_logic;
  signal register0_q_net_x3: std_logic_vector(9 downto 0);
  signal register0_q_net_x4: std_logic_vector(63 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(63 downto 0);

begin
  register0_q_net_x3 <= addr;
  ce_1_sg_x65 <= ce_1;
  clk_1_sg_x65 <= clk_1;
  register0_q_net_x4 <= data_in;
  register0_q_net_x2 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;

  calc_add_8208690392: entity work.calc_add_entity_8208690392
    port map (
      ce_1 => ce_1_sg_x65,
      clk_1 => clk_1_sg_x65,
      in_x0 => register0_q_net_x3,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x65,
      clk => clk_1_sg_x65,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 64,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 64,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x65,
      clk => clk_1_sg_x65,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x65,
      clk => clk_1_sg_x65,
      clr => '0',
      din(0) => register0_q_net_x2,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_c955364027: entity work.munge_in_entity_c955364027
    port map (
      din => register0_q_net_x4,
      dout => reinterpret_out_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/delay0"

entity delay0_entity_ea819b516e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end delay0_entity_ea819b516e;

architecture structural of delay0_entity_ea819b516e is
  signal ce_1_sg_x66: std_logic;
  signal clk_1_sg_x66: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x66 <= ce_1;
  clk_1_sg_x66 <= clk_1;
  reinterpret_out_output_port_net_x0 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.counter_7ac3eb264e
    port map (
      ce => ce_1_sg_x66,
      clk => clk_1_sg_x66,
      clr => '0',
      op => counter_op_net
    );

  ram: entity work.xlspram_window_and_fft_test_v4
    generic map (
      c_address_width => 8,
      c_width => 36,
      core_name0 => "bmg_72_9a187dd9cd5a0cfe",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x66,
      clk => clk_1_sg_x66,
      data_in => reinterpret_out_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/add_even_real/a_debus"

entity a_debus_entity_96461a65c3 is
  port (
    bus_in: in std_logic_vector(17 downto 0); 
    msb_lsb_out1: out std_logic_vector(17 downto 0)
  );
end a_debus_entity_96461a65c3;

architecture structural of a_debus_entity_96461a65c3 is
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal slice1_y_net: std_logic_vector(17 downto 0);

begin
  reinterpret2_output_port_net_x0 <= bus_in;
  msb_lsb_out1 <= reinterpret1_output_port_net_x0;

  reinterpret1: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 18,
      y_width => 18
    )
    port map (
      x => reinterpret2_output_port_net_x0,
      y => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/add_even_real/op_bussify"

entity op_bussify_entity_efdb959d9b is
  port (
    in1: in std_logic_vector(18 downto 0); 
    bus_out: out std_logic_vector(18 downto 0)
  );
end op_bussify_entity_efdb959d9b;

architecture structural of op_bussify_entity_efdb959d9b is
  signal addsub1_s_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(18 downto 0);

begin
  addsub1_s_net_x0 <= in1;
  bus_out <= reinterpret1_output_port_net_x0;

  reinterpret1: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub1_s_net_x0,
      output_port => reinterpret1_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/add_even_real"

entity add_even_real_entity_185e1241dc is
  port (
    a: in std_logic_vector(17 downto 0); 
    b: in std_logic_vector(17 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    dout: out std_logic_vector(18 downto 0)
  );
end add_even_real_entity_185e1241dc;

architecture structural of add_even_real_entity_185e1241dc is
  signal addsub1_s_net_x0: std_logic_vector(18 downto 0);
  signal ce_1_sg_x68: std_logic;
  signal clk_1_sg_x68: std_logic;
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(17 downto 0);

begin
  reinterpret2_output_port_net_x2 <= a;
  reinterpret2_output_port_net_x3 <= b;
  ce_1_sg_x68 <= ce_1;
  clk_1_sg_x68 <= clk_1;
  dout <= reinterpret1_output_port_net_x3;

  a_debus_96461a65c3: entity work.a_debus_entity_96461a65c3
    port map (
      bus_in => reinterpret2_output_port_net_x2,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  addsub1: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 18,
      b_arith => xlSigned,
      b_bin_pt => 17,
      b_width => 18,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 19,
      core_name0 => "addsb_11_0_8610f827d96057ce",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 19,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 19
    )
    port map (
      a => reinterpret1_output_port_net_x0,
      b => reinterpret1_output_port_net_x1,
      ce => ce_1_sg_x68,
      clk => clk_1_sg_x68,
      clr => '0',
      en => "1",
      s => addsub1_s_net_x0
    );

  b_debus_e78f9a5ecc: entity work.a_debus_entity_96461a65c3
    port map (
      bus_in => reinterpret2_output_port_net_x3,
      msb_lsb_out1 => reinterpret1_output_port_net_x1
    );

  op_bussify_efdb959d9b: entity work.op_bussify_entity_efdb959d9b
    port map (
      in1 => addsub1_s_net_x0,
      bus_out => reinterpret1_output_port_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/bus_convert/bussify"

entity bussify_entity_4a7767fc64 is
  port (
    in1: in std_logic_vector(17 downto 0); 
    in2: in std_logic_vector(17 downto 0); 
    in3: in std_logic_vector(17 downto 0); 
    in4: in std_logic_vector(17 downto 0); 
    bus_out: out std_logic_vector(71 downto 0)
  );
end bussify_entity_4a7767fc64;

architecture structural of bussify_entity_4a7767fc64 is
  signal adder_s_net_x3: std_logic_vector(17 downto 0);
  signal adder_s_net_x4: std_logic_vector(17 downto 0);
  signal adder_s_net_x5: std_logic_vector(17 downto 0);
  signal adder_s_net_x6: std_logic_vector(17 downto 0);
  signal concatenate_y_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(17 downto 0);

begin
  adder_s_net_x3 <= in1;
  adder_s_net_x4 <= in2;
  adder_s_net_x5 <= in3;
  adder_s_net_x6 <= in4;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_a246e373e7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x3,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x4,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x5,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x6,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/bus_convert/conv1"

entity conv1_entity_1e66d38f0f is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(18 downto 0); 
    out_x0: out std_logic_vector(17 downto 0)
  );
end conv1_entity_1e66d38f0f;

architecture structural of conv1_entity_1e66d38f0f is
  signal adder_s_net_x4: std_logic_vector(17 downto 0);
  signal almost_half_op_net: std_logic_vector(18 downto 0);
  signal bit_y_net: std_logic;
  signal ce_1_sg_x70: std_logic;
  signal clk_1_sg_x70: std_logic;
  signal concat_y_net: std_logic_vector(19 downto 0);
  signal constant_op_net: std_logic;
  signal force1_output_port_net: std_logic_vector(19 downto 0);
  signal force2_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(18 downto 0);
  signal tweak_op_y_net: std_logic;

begin
  ce_1_sg_x70 <= ce_1;
  clk_1_sg_x70 <= clk_1;
  reinterpret4_output_port_net_x0 <= in_x0;
  out_x0 <= adder_s_net_x4;

  adder: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 19,
      a_width => 20,
      b_arith => xlUnsigned,
      b_bin_pt => 19,
      b_width => 19,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 21,
      core_name0 => "addsb_11_0_1c3c830b668bf9ed",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 21,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 18
    )
    port map (
      a => force1_output_port_net,
      b => force2_output_port_net,
      ce => ce_1_sg_x70,
      clk => clk_1_sg_x70,
      clr => '0',
      en => "1",
      s => adder_s_net_x4
    );

  almost_half: entity work.constant_4709ea49b5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => almost_half_op_net
    );

  bit: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 19,
      y_width => 1
    )
    port map (
      x => reinterpret4_output_port_net_x0,
      y(0) => bit_y_net
    );

  concat: entity work.concat_504cae28bd
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret_output_port_net,
      in1(0) => tweak_op_y_net,
      y => concat_y_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  force1: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat_y_net,
      output_port => force1_output_port_net
    );

  force2: entity work.reinterpret_d2180c9169
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => almost_half_op_net,
      output_port => force2_output_port_net
    );

  reinterpret: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret4_output_port_net_x0,
      output_port => reinterpret_output_port_net
    );

  tweak_op: entity work.logical_938d99ac11
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => bit_y_net,
      d1(0) => constant_op_net,
      y(0) => tweak_op_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/bus_convert/debus"

entity debus_entity_fcefc4e7b0 is
  port (
    bus_in: in std_logic_vector(75 downto 0); 
    lsb_out1: out std_logic_vector(18 downto 0); 
    msb_out4: out std_logic_vector(18 downto 0); 
    out2: out std_logic_vector(18 downto 0); 
    out3: out std_logic_vector(18 downto 0)
  );
end debus_entity_fcefc4e7b0;

architecture structural of debus_entity_fcefc4e7b0 is
  signal concatenate_y_net_x0: std_logic_vector(75 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(18 downto 0);
  signal slice1_y_net: std_logic_vector(18 downto 0);
  signal slice2_y_net: std_logic_vector(18 downto 0);
  signal slice3_y_net: std_logic_vector(18 downto 0);
  signal slice4_y_net: std_logic_vector(18 downto 0);

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x1;
  msb_out4 <= reinterpret4_output_port_net_x1;
  out2 <= reinterpret2_output_port_net_x1;
  out3 <= reinterpret3_output_port_net_x1;

  reinterpret1: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x1
    );

  reinterpret2: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x1
    );

  reinterpret3: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x1
    );

  reinterpret4: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 18,
      x_width => 76,
      y_width => 19
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 19,
      new_msb => 37,
      x_width => 76,
      y_width => 19
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 38,
      new_msb => 56,
      x_width => 76,
      y_width => 19
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 57,
      new_msb => 75,
      x_width => 76,
      y_width => 19
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/bus_convert"

entity bus_convert_entity_d3a79798fc is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(75 downto 0); 
    dout: out std_logic_vector(71 downto 0)
  );
end bus_convert_entity_d3a79798fc;

architecture structural of bus_convert_entity_d3a79798fc is
  signal adder_s_net_x4: std_logic_vector(17 downto 0);
  signal adder_s_net_x5: std_logic_vector(17 downto 0);
  signal adder_s_net_x6: std_logic_vector(17 downto 0);
  signal adder_s_net_x7: std_logic_vector(17 downto 0);
  signal ce_1_sg_x74: std_logic;
  signal clk_1_sg_x74: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(18 downto 0);

begin
  ce_1_sg_x74 <= ce_1;
  clk_1_sg_x74 <= clk_1;
  concatenate_y_net_x2 <= din;
  dout <= concatenate_y_net_x3;

  bussify_4a7767fc64: entity work.bussify_entity_4a7767fc64
    port map (
      in1 => adder_s_net_x4,
      in2 => adder_s_net_x5,
      in3 => adder_s_net_x6,
      in4 => adder_s_net_x7,
      bus_out => concatenate_y_net_x3
    );

  conv1_1e66d38f0f: entity work.conv1_entity_1e66d38f0f
    port map (
      ce_1 => ce_1_sg_x74,
      clk_1 => clk_1_sg_x74,
      in_x0 => reinterpret4_output_port_net_x1,
      out_x0 => adder_s_net_x4
    );

  conv2_096345efe1: entity work.conv1_entity_1e66d38f0f
    port map (
      ce_1 => ce_1_sg_x74,
      clk_1 => clk_1_sg_x74,
      in_x0 => reinterpret3_output_port_net_x1,
      out_x0 => adder_s_net_x5
    );

  conv3_c6d18f5f89: entity work.conv1_entity_1e66d38f0f
    port map (
      ce_1 => ce_1_sg_x74,
      clk_1 => clk_1_sg_x74,
      in_x0 => reinterpret2_output_port_net_x1,
      out_x0 => adder_s_net_x6
    );

  conv4_e2a3b09e99: entity work.conv1_entity_1e66d38f0f
    port map (
      ce_1 => ce_1_sg_x74,
      clk_1 => clk_1_sg_x74,
      in_x0 => reinterpret1_output_port_net_x1,
      out_x0 => adder_s_net_x7
    );

  debus_fcefc4e7b0: entity work.debus_entity_fcefc4e7b0
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/bus_expand"

entity bus_expand_entity_f5d9fa1b52 is
  port (
    bus_in: in std_logic_vector(71 downto 0); 
    lsb_out1: out std_logic_vector(17 downto 0); 
    msb_out4: out std_logic_vector(17 downto 0); 
    out2: out std_logic_vector(17 downto 0); 
    out3: out std_logic_vector(17 downto 0)
  );
end bus_expand_entity_f5d9fa1b52;

architecture structural of bus_expand_entity_f5d9fa1b52 is
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(17 downto 0);
  signal slice1_y_net: std_logic_vector(17 downto 0);
  signal slice2_y_net: std_logic_vector(17 downto 0);
  signal slice3_y_net: std_logic_vector(17 downto 0);
  signal slice4_y_net: std_logic_vector(17 downto 0);

begin
  concatenate_y_net_x4 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_9306b5127f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_9306b5127f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_9306b5127f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_9306b5127f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => concatenate_y_net_x4,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 35,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => concatenate_y_net_x4,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 36,
      new_msb => 53,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => concatenate_y_net_x4,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 54,
      new_msb => 71,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => concatenate_y_net_x4,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/bus_expand_a"

entity bus_expand_a_entity_708163d551 is
  port (
    bus_in: in std_logic_vector(35 downto 0); 
    lsb_out1: out std_logic_vector(17 downto 0); 
    msb_out2: out std_logic_vector(17 downto 0)
  );
end bus_expand_a_entity_708163d551;

architecture structural of bus_expand_a_entity_708163d551 is
  signal reinterpret1_output_port_net_x6: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(17 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(35 downto 0);
  signal slice1_y_net: std_logic_vector(17 downto 0);
  signal slice2_y_net: std_logic_vector(17 downto 0);

begin
  reinterpret_out_output_port_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x6;
  msb_out2 <= reinterpret2_output_port_net_x3;

  reinterpret1: entity work.reinterpret_9306b5127f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x6
    );

  reinterpret2: entity work.reinterpret_9306b5127f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x3
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => reinterpret_out_output_port_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 35,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => reinterpret_out_output_port_net_x0,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/bus_scale/bussify"

entity bussify_entity_7b30240977 is
  port (
    in1: in std_logic_vector(18 downto 0); 
    in2: in std_logic_vector(18 downto 0); 
    in3: in std_logic_vector(18 downto 0); 
    in4: in std_logic_vector(18 downto 0); 
    bus_out: out std_logic_vector(75 downto 0)
  );
end bussify_entity_7b30240977;

architecture structural of bussify_entity_7b30240977 is
  signal concatenate_y_net_x3: std_logic_vector(75 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(18 downto 0);
  signal scale1_op_net_x0: std_logic_vector(18 downto 0);
  signal scale2_op_net_x0: std_logic_vector(18 downto 0);
  signal scale3_op_net_x0: std_logic_vector(18 downto 0);
  signal scale4_op_net_x0: std_logic_vector(18 downto 0);

begin
  scale1_op_net_x0 <= in1;
  scale2_op_net_x0 <= in2;
  scale3_op_net_x0 <= in3;
  scale4_op_net_x0 <= in4;
  bus_out <= concatenate_y_net_x3;

  concatenate: entity work.concat_2aea51ccde
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x3
    );

  reinterpret1: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale1_op_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale2_op_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale3_op_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale4_op_net_x0,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/bus_scale/debus"

entity debus_entity_4d0b597c59 is
  port (
    bus_in: in std_logic_vector(75 downto 0); 
    lsb_out1: out std_logic_vector(18 downto 0); 
    msb_out4: out std_logic_vector(18 downto 0); 
    out2: out std_logic_vector(18 downto 0); 
    out3: out std_logic_vector(18 downto 0)
  );
end debus_entity_4d0b597c59;

architecture structural of debus_entity_4d0b597c59 is
  signal concat_y_net_x0: std_logic_vector(75 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(18 downto 0);
  signal slice1_y_net: std_logic_vector(18 downto 0);
  signal slice2_y_net: std_logic_vector(18 downto 0);
  signal slice3_y_net: std_logic_vector(18 downto 0);
  signal slice4_y_net: std_logic_vector(18 downto 0);

begin
  concat_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 18,
      x_width => 76,
      y_width => 19
    )
    port map (
      x => concat_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 19,
      new_msb => 37,
      x_width => 76,
      y_width => 19
    )
    port map (
      x => concat_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 38,
      new_msb => 56,
      x_width => 76,
      y_width => 19
    )
    port map (
      x => concat_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 57,
      new_msb => 75,
      x_width => 76,
      y_width => 19
    )
    port map (
      x => concat_y_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/bus_scale"

entity bus_scale_entity_a0e6fff9af is
  port (
    din: in std_logic_vector(75 downto 0); 
    dout: out std_logic_vector(75 downto 0)
  );
end bus_scale_entity_a0e6fff9af;

architecture structural of bus_scale_entity_a0e6fff9af is
  signal concat_y_net_x1: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(75 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(18 downto 0);
  signal scale1_op_net_x0: std_logic_vector(18 downto 0);
  signal scale2_op_net_x0: std_logic_vector(18 downto 0);
  signal scale3_op_net_x0: std_logic_vector(18 downto 0);
  signal scale4_op_net_x0: std_logic_vector(18 downto 0);

begin
  concat_y_net_x1 <= din;
  dout <= concatenate_y_net_x4;

  bussify_7b30240977: entity work.bussify_entity_7b30240977
    port map (
      in1 => scale1_op_net_x0,
      in2 => scale2_op_net_x0,
      in3 => scale3_op_net_x0,
      in4 => scale4_op_net_x0,
      bus_out => concatenate_y_net_x4
    );

  debus_4d0b597c59: entity work.debus_entity_4d0b597c59
    port map (
      bus_in => concat_y_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out4 => reinterpret4_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0
    );

  scale1: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret4_output_port_net_x0,
      op => scale1_op_net_x0
    );

  scale2: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret3_output_port_net_x0,
      op => scale2_op_net_x0
    );

  scale3: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret2_output_port_net_x0,
      op => scale3_op_net_x0
    );

  scale4: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret1_output_port_net_x0,
      op => scale4_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/munge_a/join"

entity join_entity_60290f1f6b is
  port (
    in1: in std_logic_vector(17 downto 0); 
    in2: in std_logic_vector(17 downto 0); 
    bus_out: out std_logic_vector(35 downto 0)
  );
end join_entity_60290f1f6b;

architecture structural of join_entity_60290f1f6b is
  signal concatenate_y_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(17 downto 0);

begin
  reinterpret2_output_port_net_x1 <= in1;
  reinterpret1_output_port_net_x1 <= in2;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_b198bd62b0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_9306b5127f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret2_output_port_net_x1,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_9306b5127f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret1_output_port_net_x1,
      output_port => reinterpret2_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/munge_a"

entity munge_a_entity_327df61d65 is
  port (
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end munge_a_entity_327df61d65;

architecture structural of munge_a_entity_327df61d65 is
  signal concatenate_y_net_x0: std_logic_vector(35 downto 0);
  signal mux0_y_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret_out_output_port_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret_output_port_net_x0: std_logic_vector(35 downto 0);

begin
  mux0_y_net_x0 <= din;
  dout <= reinterpret_out_output_port_net_x1;

  join_60290f1f6b: entity work.join_entity_60290f1f6b
    port map (
      in1 => reinterpret2_output_port_net_x2,
      in2 => reinterpret1_output_port_net_x2,
      bus_out => concatenate_y_net_x0
    );

  reinterpret: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux0_y_net_x0,
      output_port => reinterpret_output_port_net_x0
    );

  reinterpret_out: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concatenate_y_net_x0,
      output_port => reinterpret_out_output_port_net_x1
    );

  split_f6a0f18a14: entity work.bus_expand_a_entity_708163d551
    port map (
      bus_in => reinterpret_output_port_net_x0,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out2 => reinterpret2_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/ri_to_c"

entity ri_to_c_entity_40d922a6e4 is
  port (
    im: in std_logic_vector(17 downto 0); 
    re: in std_logic_vector(17 downto 0); 
    c: out std_logic_vector(35 downto 0)
  );
end ri_to_c_entity_40d922a6e4;

architecture structural of ri_to_c_entity_40d922a6e4 is
  signal concat_y_net_x1: std_logic_vector(35 downto 0);
  signal force_im_output_port_net: std_logic_vector(17 downto 0);
  signal force_re_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(17 downto 0);

begin
  reinterpret2_output_port_net_x1 <= im;
  reinterpret4_output_port_net_x1 <= re;
  c <= concat_y_net_x1;

  concat: entity work.concat_b198bd62b0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x1
    );

  force_im: entity work.reinterpret_9306b5127f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret2_output_port_net_x1,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_9306b5127f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret4_output_port_net_x1,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0/sub_even_imag"

entity sub_even_imag_entity_a2d3094896 is
  port (
    a: in std_logic_vector(17 downto 0); 
    b: in std_logic_vector(17 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    dout: out std_logic_vector(18 downto 0)
  );
end sub_even_imag_entity_a2d3094896;

architecture structural of sub_even_imag_entity_a2d3094896 is
  signal addsub1_s_net_x0: std_logic_vector(18 downto 0);
  signal ce_1_sg_x75: std_logic;
  signal clk_1_sg_x75: std_logic;
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x12: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x13: std_logic_vector(18 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(17 downto 0);

begin
  reinterpret1_output_port_net_x11 <= a;
  reinterpret1_output_port_net_x12 <= b;
  ce_1_sg_x75 <= ce_1;
  clk_1_sg_x75 <= clk_1;
  dout <= reinterpret1_output_port_net_x13;

  a_debus_fc53c33706: entity work.a_debus_entity_96461a65c3
    port map (
      bus_in => reinterpret1_output_port_net_x11,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  addsub1: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 18,
      b_arith => xlSigned,
      b_bin_pt => 17,
      b_width => 18,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 19,
      core_name0 => "addsb_11_0_88a3fd223f485e8a",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 19,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 19
    )
    port map (
      a => reinterpret1_output_port_net_x0,
      b => reinterpret1_output_port_net_x9,
      ce => ce_1_sg_x75,
      clk => clk_1_sg_x75,
      clr => '0',
      en => "1",
      s => addsub1_s_net_x0
    );

  b_debus_eba9bd073f: entity work.a_debus_entity_96461a65c3
    port map (
      bus_in => reinterpret1_output_port_net_x12,
      msb_lsb_out1 => reinterpret1_output_port_net_x9
    );

  op_bussify_bbb5c44fa6: entity work.op_bussify_entity_efdb959d9b
    port map (
      in1 => addsub1_s_net_x0,
      bus_out => reinterpret1_output_port_net_x13
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/hilbert0"

entity hilbert0_entity_704d36ba55 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    even: out std_logic_vector(35 downto 0); 
    odd: out std_logic_vector(35 downto 0)
  );
end hilbert0_entity_704d36ba55;

architecture structural of hilbert0_entity_704d36ba55 is
  signal ce_1_sg_x77: std_logic;
  signal clk_1_sg_x77: std_logic;
  signal concat_y_net_x1: std_logic_vector(75 downto 0);
  signal concat_y_net_x2: std_logic_vector(35 downto 0);
  signal concat_y_net_x3: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(75 downto 0);
  signal mux0_y_net_x1: std_logic_vector(35 downto 0);
  signal mux1_y_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x12: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x13: std_logic_vector(18 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(18 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(18 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x6: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x7: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret_out_output_port_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x6: std_logic_vector(35 downto 0);

begin
  mux0_y_net_x1 <= a;
  mux1_y_net_x1 <= b;
  ce_1_sg_x77 <= ce_1;
  clk_1_sg_x77 <= clk_1;
  even <= reinterpret_out_output_port_net_x5;
  odd <= reinterpret_out_output_port_net_x6;

  add_even_real_185e1241dc: entity work.add_even_real_entity_185e1241dc
    port map (
      a => reinterpret2_output_port_net_x6,
      b => reinterpret2_output_port_net_x7,
      ce_1 => ce_1_sg_x77,
      clk_1 => clk_1_sg_x77,
      dout => reinterpret1_output_port_net_x3
    );

  add_odd_real_a1a8c9ff6b: entity work.add_even_real_entity_185e1241dc
    port map (
      a => reinterpret1_output_port_net_x11,
      b => reinterpret1_output_port_net_x12,
      ce_1 => ce_1_sg_x77,
      clk_1 => clk_1_sg_x77,
      dout => reinterpret1_output_port_net_x7
    );

  bus_convert_d3a79798fc: entity work.bus_convert_entity_d3a79798fc
    port map (
      ce_1 => ce_1_sg_x77,
      clk_1 => clk_1_sg_x77,
      din => concatenate_y_net_x5,
      dout => concatenate_y_net_x4
    );

  bus_expand_a_708163d551: entity work.bus_expand_a_entity_708163d551
    port map (
      bus_in => reinterpret_out_output_port_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x11,
      msb_out2 => reinterpret2_output_port_net_x6
    );

  bus_expand_b_7428c2ce83: entity work.bus_expand_a_entity_708163d551
    port map (
      bus_in => reinterpret_out_output_port_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x12,
      msb_out2 => reinterpret2_output_port_net_x7
    );

  bus_expand_f5d9fa1b52: entity work.bus_expand_entity_f5d9fa1b52
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

  bus_scale_a0e6fff9af: entity work.bus_scale_entity_a0e6fff9af
    port map (
      din => concat_y_net_x1,
      dout => concatenate_y_net_x5
    );

  concat: entity work.concat_2aea51ccde
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net_x3,
      in1 => reinterpret1_output_port_net_x4,
      in2 => reinterpret1_output_port_net_x13,
      in3 => reinterpret1_output_port_net_x7,
      y => concat_y_net_x1
    );

  munge_a_327df61d65: entity work.munge_a_entity_327df61d65
    port map (
      din => mux0_y_net_x1,
      dout => reinterpret_out_output_port_net_x1
    );

  munge_b_a313f7cc5b: entity work.munge_a_entity_327df61d65
    port map (
      din => mux1_y_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

  munge_even_850a4859b1: entity work.munge_a_entity_327df61d65
    port map (
      din => concat_y_net_x2,
      dout => reinterpret_out_output_port_net_x5
    );

  munge_odd_88e99d9e2e: entity work.munge_a_entity_327df61d65
    port map (
      din => concat_y_net_x3,
      dout => reinterpret_out_output_port_net_x6
    );

  ri_to_c1_4b6fd024c4: entity work.ri_to_c_entity_40d922a6e4
    port map (
      im => reinterpret3_output_port_net_x1,
      re => reinterpret1_output_port_net_x1,
      c => concat_y_net_x3
    );

  ri_to_c_40d922a6e4: entity work.ri_to_c_entity_40d922a6e4
    port map (
      im => reinterpret2_output_port_net_x1,
      re => reinterpret4_output_port_net_x1,
      c => concat_y_net_x2
    );

  sub_even_imag_a2d3094896: entity work.sub_even_imag_entity_a2d3094896
    port map (
      a => reinterpret1_output_port_net_x11,
      b => reinterpret1_output_port_net_x12,
      ce_1 => ce_1_sg_x77,
      clk_1 => clk_1_sg_x77,
      dout => reinterpret1_output_port_net_x13
    );

  sub_odd_imag_5c783839d9: entity work.sub_even_imag_entity_a2d3094896
    port map (
      a => reinterpret2_output_port_net_x7,
      b => reinterpret2_output_port_net_x6,
      ce_1 => ce_1_sg_x77,
      clk_1 => clk_1_sg_x77,
      dout => reinterpret1_output_port_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/mirror_spectrum/complex_conj0/imag_negate/bussify"

entity bussify_entity_03337980a5 is
  port (
    in1: in std_logic_vector(17 downto 0); 
    bus_out: out std_logic_vector(17 downto 0)
  );
end bussify_entity_03337980a5;

architecture structural of bussify_entity_03337980a5 is
  signal neg1_op_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(17 downto 0);

begin
  neg1_op_net_x0 <= in1;
  bus_out <= reinterpret1_output_port_net_x2;

  reinterpret1: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => neg1_op_net_x0,
      output_port => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/mirror_spectrum/complex_conj0/imag_negate"

entity imag_negate_entity_61ee852ab7 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(17 downto 0); 
    dout: out std_logic_vector(17 downto 0)
  );
end imag_negate_entity_61ee852ab7;

architecture structural of imag_negate_entity_61ee852ab7 is
  signal ce_1_sg_x88: std_logic;
  signal clk_1_sg_x88: std_logic;
  signal neg1_op_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x88 <= ce_1;
  clk_1_sg_x88 <= clk_1;
  reinterpret1_output_port_net_x4 <= din;
  dout <= reinterpret1_output_port_net_x5;

  bussify_03337980a5: entity work.bussify_entity_03337980a5
    port map (
      in1 => neg1_op_net_x0,
      bus_out => reinterpret1_output_port_net_x5
    );

  debus_71a1c606f5: entity work.a_debus_entity_96461a65c3
    port map (
      bus_in => reinterpret1_output_port_net_x4,
      msb_lsb_out1 => reinterpret1_output_port_net_x3
    );

  neg1: entity work.negate_f983e30a8b
    port map (
      ce => ce_1_sg_x88,
      clk => clk_1_sg_x88,
      clr => '0',
      ip => reinterpret1_output_port_net_x3,
      op => neg1_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/mirror_spectrum/complex_conj0"

entity complex_conj0_entity_a2b6f10ca0 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    z: in std_logic_vector(35 downto 0); 
    z_x0: out std_logic_vector(35 downto 0)
  );
end complex_conj0_entity_a2b6f10ca0;

architecture structural of complex_conj0_entity_a2b6f10ca0 is
  signal ce_1_sg_x89: std_logic;
  signal clk_1_sg_x89: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(35 downto 0);
  signal d3_q_net_x1: std_logic_vector(35 downto 0);
  signal real_delay_q_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret_out_output_port_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x89 <= ce_1;
  clk_1_sg_x89 <= clk_1;
  d3_q_net_x1 <= z;
  z_x0 <= reinterpret_out_output_port_net_x2;

  bus_create_0faf938d93: entity work.join_entity_60290f1f6b
    port map (
      in1 => real_delay_q_net_x0,
      in2 => reinterpret1_output_port_net_x5,
      bus_out => concatenate_y_net_x2
    );

  bus_expand_0debbd66a8: entity work.bus_expand_a_entity_708163d551
    port map (
      bus_in => reinterpret_out_output_port_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x4,
      msb_out2 => reinterpret2_output_port_net_x0
    );

  imag_negate_61ee852ab7: entity work.imag_negate_entity_61ee852ab7
    port map (
      ce_1 => ce_1_sg_x89,
      clk_1 => clk_1_sg_x89,
      din => reinterpret1_output_port_net_x4,
      dout => reinterpret1_output_port_net_x5
    );

  munge_in_e6140c6944: entity work.munge_a_entity_327df61d65
    port map (
      din => d3_q_net_x1,
      dout => reinterpret_out_output_port_net_x1
    );

  munge_out_15115f155f: entity work.munge_a_entity_327df61d65
    port map (
      din => concatenate_y_net_x2,
      dout => reinterpret_out_output_port_net_x2
    );

  real_delay: entity work.delay_6699ee0916
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret2_output_port_net_x0,
      q => real_delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/mirror_spectrum/dmux0/d_bussify"

entity d_bussify_entity_02f24549a3 is
  port (
    in1: in std_logic_vector(35 downto 0); 
    bus_out: out std_logic_vector(35 downto 0)
  );
end d_bussify_entity_02f24549a3;

architecture structural of d_bussify_entity_02f24549a3 is
  signal mux0_y_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);

begin
  mux0_y_net_x0 <= in1;
  bus_out <= reinterpret1_output_port_net_x0;

  reinterpret1: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux0_y_net_x0,
      output_port => reinterpret1_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/mirror_spectrum/dmux0/expand0"

entity expand0_entity_4f272c7f41 is
  port (
    bus_in: in std_logic_vector(35 downto 0); 
    msb_lsb_out1: out std_logic_vector(35 downto 0)
  );
end expand0_entity_4f272c7f41;

architecture structural of expand0_entity_4f272c7f41 is
  signal delay0_q_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal slice1_y_net: std_logic_vector(35 downto 0);

begin
  delay0_q_net_x0 <= bus_in;
  msb_lsb_out1 <= reinterpret1_output_port_net_x0;

  reinterpret1: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 35,
      x_width => 36,
      y_width => 36
    )
    port map (
      x => delay0_q_net_x0,
      y => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/mirror_spectrum/dmux0/sel_expand"

entity sel_expand_entity_27fd1dfb22 is
  port (
    bus_in: in std_logic; 
    msb_lsb_out1: out std_logic
  );
end sel_expand_entity_27fd1dfb22;

architecture structural of sel_expand_entity_27fd1dfb22 is
  signal reinterpret1_output_port_net_x1: std_logic;
  signal reinterpret1_output_port_net_x2: std_logic;
  signal slice1_y_net: std_logic;

begin
  reinterpret1_output_port_net_x1 <= bus_in;
  msb_lsb_out1 <= reinterpret1_output_port_net_x2;

  reinterpret1: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice1_y_net,
      output_port(0) => reinterpret1_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => reinterpret1_output_port_net_x1,
      y(0) => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/mirror_spectrum/dmux0"

entity dmux0_entity_b906b638bb is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d0: in std_logic_vector(35 downto 0); 
    d1: in std_logic_vector(35 downto 0); 
    sel: in std_logic; 
    out_x0: out std_logic_vector(35 downto 0)
  );
end dmux0_entity_b906b638bb;

architecture structural of dmux0_entity_b906b638bb is
  signal ce_1_sg_x96: std_logic;
  signal clk_1_sg_x96: std_logic;
  signal delay0_q_net_x1: std_logic_vector(35 downto 0);
  signal mux0_y_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic;
  signal reinterpret1_output_port_net_x5: std_logic;
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x4: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x96 <= ce_1;
  clk_1_sg_x96 <= clk_1;
  delay0_q_net_x1 <= d0;
  reinterpret_out_output_port_net_x4 <= d1;
  reinterpret1_output_port_net_x5 <= sel;
  out_x0 <= reinterpret1_output_port_net_x6;

  d_bussify_02f24549a3: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => mux0_y_net_x0,
      bus_out => reinterpret1_output_port_net_x6
    );

  expand0_4f272c7f41: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => delay0_q_net_x1,
      msb_lsb_out1 => reinterpret1_output_port_net_x1
    );

  expand1_e942930935: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret_out_output_port_net_x4,
      msb_lsb_out1 => reinterpret1_output_port_net_x2
    );

  mux0: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x96,
      clk => clk_1_sg_x96,
      clr => '0',
      d0 => reinterpret1_output_port_net_x1,
      d1 => reinterpret1_output_port_net_x2,
      sel(0) => reinterpret1_output_port_net_x3,
      y => mux0_y_net_x0
    );

  sel_expand_27fd1dfb22: entity work.sel_expand_entity_27fd1dfb22
    port map (
      bus_in => reinterpret1_output_port_net_x5,
      msb_lsb_out1 => reinterpret1_output_port_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/mirror_spectrum/sel_replicate0/bussify"

entity bussify_entity_ac1ae9cf2f is
  port (
    in1: in std_logic; 
    bus_out: out std_logic
  );
end bussify_entity_ac1ae9cf2f;

architecture structural of bussify_entity_ac1ae9cf2f is
  signal reinterpret1_output_port_net_x6: std_logic;
  signal relational_op_net_x0: std_logic;

begin
  relational_op_net_x0 <= in1;
  bus_out <= reinterpret1_output_port_net_x6;

  reinterpret1: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => relational_op_net_x0,
      output_port(0) => reinterpret1_output_port_net_x6
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/mirror_spectrum/sel_replicate0"

entity sel_replicate0_entity_463a6c0651 is
  port (
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sel_replicate0_entity_463a6c0651;

architecture structural of sel_replicate0_entity_463a6c0651 is
  signal reinterpret1_output_port_net_x7: std_logic;
  signal relational_op_net_x1: std_logic;

begin
  relational_op_net_x1 <= in_x0;
  out_x0 <= reinterpret1_output_port_net_x7;

  bussify_ac1ae9cf2f: entity work.bussify_entity_ac1ae9cf2f
    port map (
      in1 => relational_op_net_x1,
      bus_out => reinterpret1_output_port_net_x7
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/mirror_spectrum"

entity mirror_spectrum_entity_eea467ac75 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din0: in std_logic_vector(35 downto 0); 
    din1: in std_logic_vector(35 downto 0); 
    din2: in std_logic_vector(35 downto 0); 
    din3: in std_logic_vector(35 downto 0); 
    reo_in0: in std_logic_vector(35 downto 0); 
    reo_in1: in std_logic_vector(35 downto 0); 
    reo_in2: in std_logic_vector(35 downto 0); 
    reo_in3: in std_logic_vector(35 downto 0); 
    sync: in std_logic; 
    dout0: out std_logic_vector(35 downto 0); 
    dout1: out std_logic_vector(35 downto 0); 
    dout2: out std_logic_vector(35 downto 0); 
    dout3: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end mirror_spectrum_entity_eea467ac75;

architecture structural of mirror_spectrum_entity_eea467ac75 is
  signal ce_1_sg_x100: std_logic;
  signal clk_1_sg_x100: std_logic;
  signal constant_op_net: std_logic_vector(8 downto 0);
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal d3_q_net_x2: std_logic_vector(35 downto 0);
  signal d4_q_net_x2: std_logic_vector(35 downto 0);
  signal d5_q_net_x2: std_logic_vector(35 downto 0);
  signal d6_q_net_x2: std_logic_vector(35 downto 0);
  signal delay0_q_net_x1: std_logic_vector(35 downto 0);
  signal delay1_q_net_x1: std_logic_vector(35 downto 0);
  signal delay2_q_net_x1: std_logic_vector(35 downto 0);
  signal delay3_q_net_x1: std_logic_vector(35 downto 0);
  signal mux_y_net_x0: std_logic;
  signal ram_data_out_net_x2: std_logic_vector(35 downto 0);
  signal ram_data_out_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x10: std_logic;
  signal reinterpret1_output_port_net_x11: std_logic;
  signal reinterpret1_output_port_net_x12: std_logic;
  signal reinterpret1_output_port_net_x13: std_logic;
  signal reinterpret1_output_port_net_x14: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x15: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x16: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x17: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x10: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x7: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x8: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x9: std_logic_vector(35 downto 0);
  signal relational_op_net_x7: std_logic;
  signal sync_delay0_q_net: std_logic;
  signal sync_delay1_q_net_x0: std_logic;

begin
  ce_1_sg_x100 <= ce_1;
  clk_1_sg_x100 <= clk_1;
  ram_data_out_net_x2 <= din0;
  ram_data_out_net_x3 <= din1;
  reinterpret_out_output_port_net_x10 <= din2;
  reinterpret_out_output_port_net_x11 <= din3;
  d3_q_net_x2 <= reo_in0;
  d4_q_net_x2 <= reo_in1;
  d5_q_net_x2 <= reo_in2;
  d6_q_net_x2 <= reo_in3;
  mux_y_net_x0 <= sync;
  dout0 <= reinterpret1_output_port_net_x14;
  dout1 <= reinterpret1_output_port_net_x15;
  dout2 <= reinterpret1_output_port_net_x16;
  dout3 <= reinterpret1_output_port_net_x17;
  sync_out <= sync_delay1_q_net_x0;

  complex_conj0_a2b6f10ca0: entity work.complex_conj0_entity_a2b6f10ca0
    port map (
      ce_1 => ce_1_sg_x100,
      clk_1 => clk_1_sg_x100,
      z => d3_q_net_x2,
      z_x0 => reinterpret_out_output_port_net_x6
    );

  complex_conj1_f5b179dbbf: entity work.complex_conj0_entity_a2b6f10ca0
    port map (
      ce_1 => ce_1_sg_x100,
      clk_1 => clk_1_sg_x100,
      z => d4_q_net_x2,
      z_x0 => reinterpret_out_output_port_net_x7
    );

  complex_conj2_b067f756e8: entity work.complex_conj0_entity_a2b6f10ca0
    port map (
      ce_1 => ce_1_sg_x100,
      clk_1 => clk_1_sg_x100,
      z => d5_q_net_x2,
      z_x0 => reinterpret_out_output_port_net_x8
    );

  complex_conj3_505ec10f24: entity work.complex_conj0_entity_a2b6f10ca0
    port map (
      ce_1 => ce_1_sg_x100,
      clk_1 => clk_1_sg_x100,
      z => d6_q_net_x2,
      z_x0 => reinterpret_out_output_port_net_x9
    );

  constant_x0: entity work.constant_4a391b9a0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_d5d467f1b8
    port map (
      ce => ce_1_sg_x100,
      clk => clk_1_sg_x100,
      clr => '0',
      rst(0) => sync_delay0_q_net,
      op => counter_op_net
    );

  delay0: entity work.delay_faa52967c8
    port map (
      ce => ce_1_sg_x100,
      clk => clk_1_sg_x100,
      clr => '0',
      d => ram_data_out_net_x2,
      q => delay0_q_net_x1
    );

  delay1: entity work.delay_faa52967c8
    port map (
      ce => ce_1_sg_x100,
      clk => clk_1_sg_x100,
      clr => '0',
      d => ram_data_out_net_x3,
      q => delay1_q_net_x1
    );

  delay2: entity work.delay_faa52967c8
    port map (
      ce => ce_1_sg_x100,
      clk => clk_1_sg_x100,
      clr => '0',
      d => reinterpret_out_output_port_net_x10,
      q => delay2_q_net_x1
    );

  delay3: entity work.delay_faa52967c8
    port map (
      ce => ce_1_sg_x100,
      clk => clk_1_sg_x100,
      clr => '0',
      d => reinterpret_out_output_port_net_x11,
      q => delay3_q_net_x1
    );

  dmux0_b906b638bb: entity work.dmux0_entity_b906b638bb
    port map (
      ce_1 => ce_1_sg_x100,
      clk_1 => clk_1_sg_x100,
      d0 => delay0_q_net_x1,
      d1 => reinterpret_out_output_port_net_x6,
      sel => reinterpret1_output_port_net_x10,
      out_x0 => reinterpret1_output_port_net_x14
    );

  dmux1_23217d5476: entity work.dmux0_entity_b906b638bb
    port map (
      ce_1 => ce_1_sg_x100,
      clk_1 => clk_1_sg_x100,
      d0 => delay1_q_net_x1,
      d1 => reinterpret_out_output_port_net_x7,
      sel => reinterpret1_output_port_net_x11,
      out_x0 => reinterpret1_output_port_net_x15
    );

  dmux2_ed0877aa23: entity work.dmux0_entity_b906b638bb
    port map (
      ce_1 => ce_1_sg_x100,
      clk_1 => clk_1_sg_x100,
      d0 => delay2_q_net_x1,
      d1 => reinterpret_out_output_port_net_x8,
      sel => reinterpret1_output_port_net_x12,
      out_x0 => reinterpret1_output_port_net_x16
    );

  dmux3_42e785f02a: entity work.dmux0_entity_b906b638bb
    port map (
      ce_1 => ce_1_sg_x100,
      clk_1 => clk_1_sg_x100,
      d0 => delay3_q_net_x1,
      d1 => reinterpret_out_output_port_net_x9,
      sel => reinterpret1_output_port_net_x13,
      out_x0 => reinterpret1_output_port_net_x17
    );

  relational: entity work.relational_e962c41658
    port map (
      a => counter_op_net,
      b => constant_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net_x7
    );

  sel_replicate0_463a6c0651: entity work.sel_replicate0_entity_463a6c0651
    port map (
      in_x0 => relational_op_net_x7,
      out_x0 => reinterpret1_output_port_net_x10
    );

  sel_replicate1_f383d46506: entity work.sel_replicate0_entity_463a6c0651
    port map (
      in_x0 => relational_op_net_x7,
      out_x0 => reinterpret1_output_port_net_x11
    );

  sel_replicate2_50f5321dfd: entity work.sel_replicate0_entity_463a6c0651
    port map (
      in_x0 => relational_op_net_x7,
      out_x0 => reinterpret1_output_port_net_x12
    );

  sel_replicate3_b4113df869: entity work.sel_replicate0_entity_463a6c0651
    port map (
      in_x0 => relational_op_net_x7,
      out_x0 => reinterpret1_output_port_net_x13
    );

  sync_delay0: entity work.delay_14a6a51cbc
    port map (
      ce => ce_1_sg_x100,
      clk => clk_1_sg_x100,
      clr => '0',
      d(0) => mux_y_net_x0,
      q(0) => sync_delay0_q_net
    );

  sync_delay1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x100,
      clk => clk_1_sg_x100,
      clr => '0',
      d(0) => sync_delay0_q_net,
      q(0) => sync_delay1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_even/addr_expand"

entity addr_expand_entity_096a421146 is
  port (
    bus_in: in std_logic_vector(7 downto 0); 
    msb_lsb_out1: out std_logic_vector(7 downto 0)
  );
end addr_expand_entity_096a421146;

architecture structural of addr_expand_entity_096a421146 is
  signal reinterpret1_output_port_net_x1: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(7 downto 0);
  signal slice1_y_net: std_logic_vector(7 downto 0);

begin
  reinterpret1_output_port_net_x1 <= bus_in;
  msb_lsb_out1 <= reinterpret1_output_port_net_x2;

  reinterpret1: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 8,
      y_width => 8
    )
    port map (
      x => reinterpret1_output_port_net_x1,
      y => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_even/addr_replicate/bussify"

entity bussify_entity_e9bf8b2ef0 is
  port (
    in1: in std_logic_vector(7 downto 0); 
    bus_out: out std_logic_vector(7 downto 0)
  );
end bussify_entity_e9bf8b2ef0;

architecture structural of bussify_entity_e9bf8b2ef0 is
  signal mux_y_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(7 downto 0);

begin
  mux_y_net_x0 <= in1;
  bus_out <= reinterpret1_output_port_net_x2;

  reinterpret1: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux_y_net_x0,
      output_port => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_even/addr_replicate"

entity addr_replicate_entity_5e97189755 is
  port (
    in_x0: in std_logic_vector(7 downto 0); 
    out_x0: out std_logic_vector(7 downto 0)
  );
end addr_replicate_entity_5e97189755;

architecture structural of addr_replicate_entity_5e97189755 is
  signal mux_y_net_x1: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(7 downto 0);

begin
  mux_y_net_x1 <= in_x0;
  out_x0 <= reinterpret1_output_port_net_x3;

  bussify_e9bf8b2ef0: entity work.bussify_entity_e9bf8b2ef0
    port map (
      in1 => mux_y_net_x1,
      bus_out => reinterpret1_output_port_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_even/buf0/debus_we"

entity debus_we_entity_13d5242861 is
  port (
    bus_in: in std_logic; 
    msb_lsb_out1: out std_logic
  );
end debus_we_entity_13d5242861;

architecture structural of debus_we_entity_13d5242861 is
  signal reinterpret1_output_port_net_x0: std_logic;
  signal slice1_y_net_x0: std_logic;

begin
  reinterpret1_output_port_net_x0 <= bus_in;
  msb_lsb_out1 <= slice1_y_net_x0;

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => reinterpret1_output_port_net_x0,
      y(0) => slice1_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_even/buf0"

entity buf0_entity_232262617c is
  port (
    addr: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    we: in std_logic; 
    dout: out std_logic_vector(35 downto 0)
  );
end buf0_entity_232262617c;

architecture structural of buf0_entity_232262617c is
  signal bram0_data_out_net_x0: std_logic_vector(35 downto 0);
  signal ce_1_sg_x101: std_logic;
  signal clk_1_sg_x101: std_logic;
  signal ddin_q_net_x0: std_logic_vector(35 downto 0);
  signal delay_din0_q_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic;
  signal reinterpret1_output_port_net_x8: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(35 downto 0);
  signal slice1_y_net_x0: std_logic;
  signal slice1_y_net_x2: std_logic;

begin
  reinterpret1_output_port_net_x8 <= addr;
  ce_1_sg_x101 <= ce_1;
  clk_1_sg_x101 <= clk_1;
  delay_din0_q_net_x0 <= din;
  slice1_y_net_x2 <= we;
  dout <= reinterpret1_output_port_net_x9;

  bram0: entity work.xlspram_window_and_fft_test_v4
    generic map (
      c_address_width => 8,
      c_width => 36,
      core_name0 => "bmg_72_88a7df48df176590",
      latency => 1
    )
    port map (
      addr => reinterpret1_output_port_net_x2,
      ce => ce_1_sg_x101,
      clk => clk_1_sg_x101,
      data_in => reinterpret1_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => slice1_y_net_x0,
      data_out => bram0_data_out_net_x0
    );

  ddin: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => delay_din0_q_net_x0,
      q => ddin_q_net_x0
    );

  debus_addr_8e09aa1e69: entity work.addr_expand_entity_096a421146
    port map (
      bus_in => reinterpret1_output_port_net_x6,
      msb_lsb_out1 => reinterpret1_output_port_net_x2
    );

  debus_din_eaabfbd036: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => ddin_q_net_x0,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  debus_we_13d5242861: entity work.debus_we_entity_13d5242861
    port map (
      bus_in => reinterpret1_output_port_net_x7,
      msb_lsb_out1 => slice1_y_net_x0
    );

  din_bussify_6a814dc3b6: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => bram0_data_out_net_x0,
      bus_out => reinterpret1_output_port_net_x9
    );

  rep_addr_17fc54d359: entity work.addr_replicate_entity_5e97189755
    port map (
      in_x0 => reinterpret1_output_port_net_x8,
      out_x0 => reinterpret1_output_port_net_x6
    );

  rep_we_00f9eb8f02: entity work.sel_replicate0_entity_463a6c0651
    port map (
      in_x0 => slice1_y_net_x2,
      out_x0 => reinterpret1_output_port_net_x7
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_even/sync_delay_en"

entity sync_delay_en_entity_d734fc6fda is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    en: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_en_entity_d734fc6fda;

architecture structural of sync_delay_en_entity_d734fc6fda is
  signal ce_1_sg_x102: std_logic;
  signal clk_1_sg_x102: std_logic;
  signal constant1_op_net: std_logic_vector(8 downto 0);
  signal constant2_op_net: std_logic_vector(8 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(8 downto 0);
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal logical1_y_net: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x0: std_logic;
  signal or_y_net_x0: std_logic;
  signal pre_sync_delay_q_net_x0: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x102 <= ce_1;
  clk_1_sg_x102 <= clk_1;
  or_y_net_x0 <= en;
  pre_sync_delay_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x0;

  constant1: entity work.constant_fd85eb7067
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_4a391b9a0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_b4ec9de7d1
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_1dea202a2f
    port map (
      ce => ce_1_sg_x102,
      clk => clk_1_sg_x102,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical1_y_net,
      load(0) => pre_sync_delay_q_net_x0,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => pre_sync_delay_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  logical1: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => logical_y_net,
      d1(0) => or_y_net_x0,
      y(0) => logical1_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => pre_sync_delay_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x0
    );

  relational: entity work.relational_6c3ee657fa
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_78eac2928d
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_even"

entity reorder_even_entity_3d95ec0a9d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din0: in std_logic_vector(35 downto 0); 
    en: in std_logic; 
    sync: in std_logic; 
    dout0: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end reorder_even_entity_3d95ec0a9d;

architecture structural of reorder_even_entity_3d95ec0a9d is
  signal ce_1_sg_x103: std_logic;
  signal clk_1_sg_x103: std_logic;
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal delay0_q_net_x0: std_logic;
  signal delay_d0_q_net: std_logic_vector(7 downto 0);
  signal delay_din0_q_net_x0: std_logic_vector(35 downto 0);
  signal delay_map1_q_net: std_logic_vector(7 downto 0);
  signal delay_sel_q_net: std_logic;
  signal delay_we0_q_net: std_logic;
  signal delay_we2_q_net_x1: std_logic;
  signal en_even_op_net_x0: std_logic;
  signal map1_data_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x0: std_logic;
  signal mux_y_net_x1: std_logic_vector(7 downto 0);
  signal or_y_net_x0: std_logic;
  signal post_sync_delay_q_net_x0: std_logic;
  signal pre_sync_delay_q_net_x0: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic;
  signal reinterpret1_output_port_net_x3: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x8: std_logic_vector(7 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(35 downto 0);
  signal slice1_y_net: std_logic;
  signal slice1_y_net_x3: std_logic;
  signal slice2_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x103 <= ce_1;
  clk_1_sg_x103 <= clk_1;
  reinterpret2_output_port_net_x0 <= din0;
  en_even_op_net_x0 <= en;
  delay0_q_net_x0 <= sync;
  dout0 <= reinterpret1_output_port_net_x10;
  sync_out <= post_sync_delay_q_net_x0;

  addr_expand_096a421146: entity work.addr_expand_entity_096a421146
    port map (
      bus_in => reinterpret1_output_port_net_x3,
      msb_lsb_out1 => reinterpret1_output_port_net_x8
    );

  addr_replicate_5e97189755: entity work.addr_replicate_entity_5e97189755
    port map (
      in_x0 => mux_y_net_x1,
      out_x0 => reinterpret1_output_port_net_x3
    );

  buf0_232262617c: entity work.buf0_entity_232262617c
    port map (
      addr => reinterpret1_output_port_net_x8,
      ce_1 => ce_1_sg_x103,
      clk_1 => clk_1_sg_x103,
      din => delay_din0_q_net_x0,
      we => slice1_y_net_x3,
      dout => reinterpret1_output_port_net_x10
    );

  counter: entity work.counter_eeeda8f61f
    port map (
      ce => ce_1_sg_x103,
      clk => clk_1_sg_x103,
      clr => '0',
      en(0) => en_even_op_net_x0,
      rst(0) => delay0_q_net_x0,
      op => counter_op_net
    );

  delay_d0: entity work.delay_9565135955
    port map (
      ce => ce_1_sg_x103,
      clk => clk_1_sg_x103,
      clr => '0',
      d => slice2_y_net,
      q => delay_d0_q_net
    );

  delay_din0: entity work.delay_bdaf6c9e55
    port map (
      ce => ce_1_sg_x103,
      clk => clk_1_sg_x103,
      clr => '0',
      d => reinterpret2_output_port_net_x0,
      q => delay_din0_q_net_x0
    );

  delay_map1: entity work.delay_423c6c1400
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => map1_data_net,
      q => delay_map1_q_net
    );

  delay_sel: entity work.delay_85c2ef968b
    port map (
      ce => ce_1_sg_x103,
      clk => clk_1_sg_x103,
      clr => '0',
      d(0) => slice1_y_net,
      q(0) => delay_sel_q_net
    );

  delay_we0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x103,
      clk => clk_1_sg_x103,
      clr => '0',
      d(0) => en_even_op_net_x0,
      q(0) => delay_we0_q_net
    );

  delay_we2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x103,
      clk => clk_1_sg_x103,
      clr => '0',
      d(0) => en_even_op_net_x0,
      q(0) => delay_we2_q_net_x1
    );

  map1: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 8,
      c_width => 8,
      core_name0 => "bmg_72_71453be4ec33d4ae",
      latency => 2
    )
    port map (
      addr => slice2_y_net,
      ce => ce_1_sg_x103,
      clk => clk_1_sg_x103,
      en => "1",
      rst => "0",
      data => map1_data_net
    );

  mux: entity work.mux_7f6b7da686
    port map (
      ce => ce_1_sg_x103,
      clk => clk_1_sg_x103,
      clr => '0',
      d0 => delay_d0_q_net,
      d1 => delay_map1_q_net,
      sel(0) => delay_sel_q_net,
      y => mux_y_net_x1
    );

  or_x0: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => pre_sync_delay_q_net_x0,
      d1(0) => delay_we0_q_net,
      y(0) => or_y_net_x0
    );

  post_sync_delay: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x103,
      clk => clk_1_sg_x103,
      clr => '0',
      d(0) => mux_y_net_x0,
      q(0) => post_sync_delay_q_net_x0
    );

  pre_sync_delay: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x103,
      clk => clk_1_sg_x103,
      clr => '0',
      d(0) => delay0_q_net_x0,
      q(0) => pre_sync_delay_q_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 9,
      y_width => 8
    )
    port map (
      x => counter_op_net,
      y => slice2_y_net
    );

  sync_delay_en_d734fc6fda: entity work.sync_delay_en_entity_d734fc6fda
    port map (
      ce_1 => ce_1_sg_x103,
      clk_1 => clk_1_sg_x103,
      en => or_y_net_x0,
      in_x0 => pre_sync_delay_q_net_x0,
      out_x0 => mux_y_net_x0
    );

  we_expand_97c1a808d0: entity work.debus_we_entity_13d5242861
    port map (
      bus_in => reinterpret1_output_port_net_x2,
      msb_lsb_out1 => slice1_y_net_x3
    );

  we_replicate_a77f4e5af5: entity work.sel_replicate0_entity_463a6c0651
    port map (
      in_x0 => delay_we2_q_net_x1,
      out_x0 => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_odd"

entity reorder_odd_entity_19b1685430 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din0: in std_logic_vector(35 downto 0); 
    en: in std_logic; 
    sync: in std_logic; 
    dout0: out std_logic_vector(35 downto 0)
  );
end reorder_odd_entity_19b1685430;

architecture structural of reorder_odd_entity_19b1685430 is
  signal ce_1_sg_x105: std_logic;
  signal clk_1_sg_x105: std_logic;
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal delay0_q_net_x1: std_logic;
  signal delay_d0_q_net: std_logic_vector(7 downto 0);
  signal delay_din0_q_net_x0: std_logic_vector(35 downto 0);
  signal delay_map1_q_net: std_logic_vector(7 downto 0);
  signal delay_sel_q_net: std_logic;
  signal delay_we2_q_net_x1: std_logic;
  signal en_odd_op_net_x0: std_logic;
  signal map1_data_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x1: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x10: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic;
  signal reinterpret1_output_port_net_x3: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x8: std_logic_vector(7 downto 0);
  signal slice1_y_net: std_logic;
  signal slice1_y_net_x3: std_logic;
  signal slice2_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x105 <= ce_1;
  clk_1_sg_x105 <= clk_1;
  reinterpret1_output_port_net_x0 <= din0;
  en_odd_op_net_x0 <= en;
  delay0_q_net_x1 <= sync;
  dout0 <= reinterpret1_output_port_net_x10;

  addr_expand_f663e274a9: entity work.addr_expand_entity_096a421146
    port map (
      bus_in => reinterpret1_output_port_net_x3,
      msb_lsb_out1 => reinterpret1_output_port_net_x8
    );

  addr_replicate_b17f04c169: entity work.addr_replicate_entity_5e97189755
    port map (
      in_x0 => mux_y_net_x1,
      out_x0 => reinterpret1_output_port_net_x3
    );

  buf0_a058f87a6e: entity work.buf0_entity_232262617c
    port map (
      addr => reinterpret1_output_port_net_x8,
      ce_1 => ce_1_sg_x105,
      clk_1 => clk_1_sg_x105,
      din => delay_din0_q_net_x0,
      we => slice1_y_net_x3,
      dout => reinterpret1_output_port_net_x10
    );

  counter: entity work.counter_eeeda8f61f
    port map (
      ce => ce_1_sg_x105,
      clk => clk_1_sg_x105,
      clr => '0',
      en(0) => en_odd_op_net_x0,
      rst(0) => delay0_q_net_x1,
      op => counter_op_net
    );

  delay_d0: entity work.delay_9565135955
    port map (
      ce => ce_1_sg_x105,
      clk => clk_1_sg_x105,
      clr => '0',
      d => slice2_y_net,
      q => delay_d0_q_net
    );

  delay_din0: entity work.delay_bdaf6c9e55
    port map (
      ce => ce_1_sg_x105,
      clk => clk_1_sg_x105,
      clr => '0',
      d => reinterpret1_output_port_net_x0,
      q => delay_din0_q_net_x0
    );

  delay_map1: entity work.delay_423c6c1400
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => map1_data_net,
      q => delay_map1_q_net
    );

  delay_sel: entity work.delay_85c2ef968b
    port map (
      ce => ce_1_sg_x105,
      clk => clk_1_sg_x105,
      clr => '0',
      d(0) => slice1_y_net,
      q(0) => delay_sel_q_net
    );

  delay_we2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x105,
      clk => clk_1_sg_x105,
      clr => '0',
      d(0) => en_odd_op_net_x0,
      q(0) => delay_we2_q_net_x1
    );

  map1: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 8,
      c_width => 8,
      core_name0 => "bmg_72_fc83b5c52a6ea9e3",
      latency => 2
    )
    port map (
      addr => slice2_y_net,
      ce => ce_1_sg_x105,
      clk => clk_1_sg_x105,
      en => "1",
      rst => "0",
      data => map1_data_net
    );

  mux: entity work.mux_7f6b7da686
    port map (
      ce => ce_1_sg_x105,
      clk => clk_1_sg_x105,
      clr => '0',
      d0 => delay_d0_q_net,
      d1 => delay_map1_q_net,
      sel(0) => delay_sel_q_net,
      y => mux_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 9,
      y_width => 8
    )
    port map (
      x => counter_op_net,
      y => slice2_y_net
    );

  we_expand_79b4ce91d7: entity work.debus_we_entity_13d5242861
    port map (
      bus_in => reinterpret1_output_port_net_x2,
      msb_lsb_out1 => slice1_y_net_x3
    );

  we_replicate_593b56fe98: entity work.sel_replicate0_entity_463a6c0651
    port map (
      in_x0 => delay_we2_q_net_x1,
      out_x0 => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_out/addr_expand"

entity addr_expand_entity_9a94747d91 is
  port (
    bus_in: in std_logic_vector(31 downto 0); 
    lsb_out1: out std_logic_vector(7 downto 0); 
    msb_out4: out std_logic_vector(7 downto 0); 
    out2: out std_logic_vector(7 downto 0); 
    out3: out std_logic_vector(7 downto 0)
  );
end addr_expand_entity_9a94747d91;

architecture structural of addr_expand_entity_9a94747d91 is
  signal concatenate_y_net_x0: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(7 downto 0);
  signal slice1_y_net: std_logic_vector(7 downto 0);
  signal slice2_y_net: std_logic_vector(7 downto 0);
  signal slice3_y_net: std_logic_vector(7 downto 0);
  signal slice4_y_net: std_logic_vector(7 downto 0);

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 15,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 16,
      new_msb => 23,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 24,
      new_msb => 31,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_out/addr_replicate/bussify"

entity bussify_entity_25f955b4c3 is
  port (
    in1: in std_logic_vector(7 downto 0); 
    in2: in std_logic_vector(7 downto 0); 
    in3: in std_logic_vector(7 downto 0); 
    in4: in std_logic_vector(7 downto 0); 
    bus_out: out std_logic_vector(31 downto 0)
  );
end bussify_entity_25f955b4c3;

architecture structural of bussify_entity_25f955b4c3 is
  signal concatenate_y_net_x1: std_logic_vector(31 downto 0);
  signal din1_0_q_net_x0: std_logic_vector(7 downto 0);
  signal din1_1_q_net_x0: std_logic_vector(7 downto 0);
  signal din1_2_q_net_x0: std_logic_vector(7 downto 0);
  signal din1_3_q_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(7 downto 0);

begin
  din1_0_q_net_x0 <= in1;
  din1_1_q_net_x0 <= in2;
  din1_2_q_net_x0 <= in3;
  din1_3_q_net_x0 <= in4;
  bus_out <= concatenate_y_net_x1;

  concatenate: entity work.concat_a1e126f11c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x1
    );

  reinterpret1: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din1_0_q_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din1_1_q_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din1_2_q_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din1_3_q_net_x0,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_out/addr_replicate"

entity addr_replicate_entity_86bc6d4fb7 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(7 downto 0); 
    out_x0: out std_logic_vector(31 downto 0)
  );
end addr_replicate_entity_86bc6d4fb7;

architecture structural of addr_replicate_entity_86bc6d4fb7 is
  signal ce_1_sg_x106: std_logic;
  signal clk_1_sg_x106: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(31 downto 0);
  signal din0_0_q_net: std_logic_vector(7 downto 0);
  signal din0_1_q_net: std_logic_vector(7 downto 0);
  signal din1_0_q_net_x0: std_logic_vector(7 downto 0);
  signal din1_1_q_net_x0: std_logic_vector(7 downto 0);
  signal din1_2_q_net_x0: std_logic_vector(7 downto 0);
  signal din1_3_q_net_x0: std_logic_vector(7 downto 0);
  signal mux_y_net_x0: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x106 <= ce_1;
  clk_1_sg_x106 <= clk_1;
  mux_y_net_x0 <= in_x0;
  out_x0 <= concatenate_y_net_x2;

  bussify_25f955b4c3: entity work.bussify_entity_25f955b4c3
    port map (
      in1 => din1_0_q_net_x0,
      in2 => din1_1_q_net_x0,
      in3 => din1_2_q_net_x0,
      in4 => din1_3_q_net_x0,
      bus_out => concatenate_y_net_x2
    );

  din0_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x106,
      clk => clk_1_sg_x106,
      d => mux_y_net_x0,
      en => '1',
      rst => '1',
      q => din0_0_q_net
    );

  din0_1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x106,
      clk => clk_1_sg_x106,
      d => mux_y_net_x0,
      en => '1',
      rst => '1',
      q => din0_1_q_net
    );

  din1_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x106,
      clk => clk_1_sg_x106,
      d => din0_0_q_net,
      en => '1',
      rst => '1',
      q => din1_0_q_net_x0
    );

  din1_1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x106,
      clk => clk_1_sg_x106,
      d => din0_1_q_net,
      en => '1',
      rst => '1',
      q => din1_1_q_net_x0
    );

  din1_2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x106,
      clk => clk_1_sg_x106,
      d => din0_0_q_net,
      en => '1',
      rst => '1',
      q => din1_2_q_net_x0
    );

  din1_3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x106,
      clk => clk_1_sg_x106,
      d => din0_1_q_net,
      en => '1',
      rst => '1',
      q => din1_3_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_out/we_expand"

entity we_expand_entity_8c4a77d2ed is
  port (
    bus_in: in std_logic_vector(3 downto 0); 
    lsb_out1: out std_logic; 
    msb_out4: out std_logic; 
    out2: out std_logic; 
    out3: out std_logic
  );
end we_expand_entity_8c4a77d2ed;

architecture structural of we_expand_entity_8c4a77d2ed is
  signal concatenate_y_net_x0: std_logic_vector(3 downto 0);
  signal slice1_y_net_x3: std_logic;
  signal slice2_y_net_x3: std_logic;
  signal slice3_y_net_x3: std_logic;
  signal slice4_y_net_x3: std_logic;

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= slice1_y_net_x3;
  msb_out4 <= slice4_y_net_x3;
  out2 <= slice2_y_net_x3;
  out3 <= slice3_y_net_x3;

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice1_y_net_x3
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice2_y_net_x3
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice3_y_net_x3
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice4_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_out/we_replicate/bussify"

entity bussify_entity_5c62d70bd7 is
  port (
    in1: in std_logic; 
    in2: in std_logic; 
    in3: in std_logic; 
    in4: in std_logic; 
    bus_out: out std_logic_vector(3 downto 0)
  );
end bussify_entity_5c62d70bd7;

architecture structural of bussify_entity_5c62d70bd7 is
  signal concatenate_y_net_x1: std_logic_vector(3 downto 0);
  signal din1_0_q_net_x0: std_logic;
  signal din1_1_q_net_x0: std_logic;
  signal din1_2_q_net_x0: std_logic;
  signal din1_3_q_net_x0: std_logic;
  signal reinterpret1_output_port_net: std_logic;
  signal reinterpret2_output_port_net: std_logic;
  signal reinterpret3_output_port_net: std_logic;
  signal reinterpret4_output_port_net: std_logic;

begin
  din1_0_q_net_x0 <= in1;
  din1_1_q_net_x0 <= in2;
  din1_2_q_net_x0 <= in3;
  din1_3_q_net_x0 <= in4;
  bus_out <= concatenate_y_net_x1;

  concatenate: entity work.concat_a0c7cd7a34
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => reinterpret1_output_port_net,
      in1(0) => reinterpret2_output_port_net,
      in2(0) => reinterpret3_output_port_net,
      in3(0) => reinterpret4_output_port_net,
      y => concatenate_y_net_x1
    );

  reinterpret1: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din1_0_q_net_x0,
      output_port(0) => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din1_1_q_net_x0,
      output_port(0) => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din1_2_q_net_x0,
      output_port(0) => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din1_3_q_net_x0,
      output_port(0) => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_out/we_replicate"

entity we_replicate_entity_4c813c783b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic_vector(3 downto 0)
  );
end we_replicate_entity_4c813c783b;

architecture structural of we_replicate_entity_4c813c783b is
  signal ce_1_sg_x111: std_logic;
  signal clk_1_sg_x111: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(3 downto 0);
  signal delay_we2_q_net_x0: std_logic;
  signal din0_0_q_net: std_logic;
  signal din0_1_q_net: std_logic;
  signal din1_0_q_net_x0: std_logic;
  signal din1_1_q_net_x0: std_logic;
  signal din1_2_q_net_x0: std_logic;
  signal din1_3_q_net_x0: std_logic;

begin
  ce_1_sg_x111 <= ce_1;
  clk_1_sg_x111 <= clk_1;
  delay_we2_q_net_x0 <= in_x0;
  out_x0 <= concatenate_y_net_x2;

  bussify_5c62d70bd7: entity work.bussify_entity_5c62d70bd7
    port map (
      in1 => din1_0_q_net_x0,
      in2 => din1_1_q_net_x0,
      in3 => din1_2_q_net_x0,
      in4 => din1_3_q_net_x0,
      bus_out => concatenate_y_net_x2
    );

  din0_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x111,
      clk => clk_1_sg_x111,
      d(0) => delay_we2_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_0_q_net
    );

  din0_1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x111,
      clk => clk_1_sg_x111,
      d(0) => delay_we2_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_1_q_net
    );

  din1_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x111,
      clk => clk_1_sg_x111,
      d(0) => din0_0_q_net,
      en => '1',
      rst => '1',
      q(0) => din1_0_q_net_x0
    );

  din1_1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x111,
      clk => clk_1_sg_x111,
      d(0) => din0_1_q_net,
      en => '1',
      rst => '1',
      q(0) => din1_1_q_net_x0
    );

  din1_2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x111,
      clk => clk_1_sg_x111,
      d(0) => din0_0_q_net,
      en => '1',
      rst => '1',
      q(0) => din1_2_q_net_x0
    );

  din1_3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x111,
      clk => clk_1_sg_x111,
      d(0) => din0_1_q_net,
      en => '1',
      rst => '1',
      q(0) => din1_3_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/reorder_out"

entity reorder_out_entity_c7d133390a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din0: in std_logic_vector(35 downto 0); 
    din1: in std_logic_vector(35 downto 0); 
    din2: in std_logic_vector(35 downto 0); 
    din3: in std_logic_vector(35 downto 0); 
    en: in std_logic; 
    sync: in std_logic; 
    dout0: out std_logic_vector(35 downto 0); 
    dout1: out std_logic_vector(35 downto 0); 
    dout2: out std_logic_vector(35 downto 0); 
    dout3: out std_logic_vector(35 downto 0)
  );
end reorder_out_entity_c7d133390a;

architecture structural of reorder_out_entity_c7d133390a is
  signal ce_1_sg_x112: std_logic;
  signal clk_1_sg_x112: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(31 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(3 downto 0);
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal delay_d0_q_net: std_logic_vector(7 downto 0);
  signal delay_din0_q_net_x0: std_logic_vector(35 downto 0);
  signal delay_din1_q_net_x0: std_logic_vector(35 downto 0);
  signal delay_din2_q_net_x0: std_logic_vector(35 downto 0);
  signal delay_din3_q_net_x0: std_logic_vector(35 downto 0);
  signal delay_map1_q_net: std_logic_vector(7 downto 0);
  signal delay_sel_q_net: std_logic;
  signal delay_we2_q_net_x0: std_logic;
  signal en_out_op_net_x0: std_logic;
  signal map1_data_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x0: std_logic_vector(7 downto 0);
  signal mux_y_net_x2: std_logic;
  signal ram_data_out_net_x4: std_logic_vector(35 downto 0);
  signal ram_data_out_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x10: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x13: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic_vector(7 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(7 downto 0);
  signal reinterpret3_output_port_net_x3: std_logic_vector(7 downto 0);
  signal reinterpret4_output_port_net_x3: std_logic_vector(7 downto 0);
  signal reinterpret_out_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x13: std_logic_vector(35 downto 0);
  signal slice1_y_net: std_logic;
  signal slice1_y_net_x3: std_logic;
  signal slice2_y_net: std_logic_vector(7 downto 0);
  signal slice2_y_net_x3: std_logic;
  signal slice3_y_net_x3: std_logic;
  signal slice4_y_net_x3: std_logic;

begin
  ce_1_sg_x112 <= ce_1;
  clk_1_sg_x112 <= clk_1;
  ram_data_out_net_x4 <= din0;
  ram_data_out_net_x5 <= din1;
  reinterpret_out_output_port_net_x12 <= din2;
  reinterpret_out_output_port_net_x13 <= din3;
  en_out_op_net_x0 <= en;
  mux_y_net_x2 <= sync;
  dout0 <= reinterpret1_output_port_net_x10;
  dout1 <= reinterpret1_output_port_net_x11;
  dout2 <= reinterpret1_output_port_net_x12;
  dout3 <= reinterpret1_output_port_net_x13;

  addr_expand_9a94747d91: entity work.addr_expand_entity_9a94747d91
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x7,
      msb_out4 => reinterpret4_output_port_net_x3,
      out2 => reinterpret2_output_port_net_x3,
      out3 => reinterpret3_output_port_net_x3
    );

  addr_replicate_86bc6d4fb7: entity work.addr_replicate_entity_86bc6d4fb7
    port map (
      ce_1 => ce_1_sg_x112,
      clk_1 => clk_1_sg_x112,
      in_x0 => mux_y_net_x0,
      out_x0 => concatenate_y_net_x2
    );

  buf0_8e3e29005c: entity work.buf0_entity_232262617c
    port map (
      addr => reinterpret4_output_port_net_x3,
      ce_1 => ce_1_sg_x112,
      clk_1 => clk_1_sg_x112,
      din => delay_din0_q_net_x0,
      we => slice4_y_net_x3,
      dout => reinterpret1_output_port_net_x10
    );

  buf1_cbcb29b34c: entity work.buf0_entity_232262617c
    port map (
      addr => reinterpret3_output_port_net_x3,
      ce_1 => ce_1_sg_x112,
      clk_1 => clk_1_sg_x112,
      din => delay_din1_q_net_x0,
      we => slice3_y_net_x3,
      dout => reinterpret1_output_port_net_x11
    );

  buf2_79d4fd962d: entity work.buf0_entity_232262617c
    port map (
      addr => reinterpret2_output_port_net_x3,
      ce_1 => ce_1_sg_x112,
      clk_1 => clk_1_sg_x112,
      din => delay_din2_q_net_x0,
      we => slice2_y_net_x3,
      dout => reinterpret1_output_port_net_x12
    );

  buf3_214a13354c: entity work.buf0_entity_232262617c
    port map (
      addr => reinterpret1_output_port_net_x7,
      ce_1 => ce_1_sg_x112,
      clk_1 => clk_1_sg_x112,
      din => delay_din3_q_net_x0,
      we => slice1_y_net_x3,
      dout => reinterpret1_output_port_net_x13
    );

  counter: entity work.counter_eeeda8f61f
    port map (
      ce => ce_1_sg_x112,
      clk => clk_1_sg_x112,
      clr => '0',
      en(0) => en_out_op_net_x0,
      rst(0) => mux_y_net_x2,
      op => counter_op_net
    );

  delay_d0: entity work.delay_9565135955
    port map (
      ce => ce_1_sg_x112,
      clk => clk_1_sg_x112,
      clr => '0',
      d => slice2_y_net,
      q => delay_d0_q_net
    );

  delay_din0: entity work.delay_28d2c9d50c
    port map (
      ce => ce_1_sg_x112,
      clk => clk_1_sg_x112,
      clr => '0',
      d => ram_data_out_net_x4,
      q => delay_din0_q_net_x0
    );

  delay_din1: entity work.delay_28d2c9d50c
    port map (
      ce => ce_1_sg_x112,
      clk => clk_1_sg_x112,
      clr => '0',
      d => ram_data_out_net_x5,
      q => delay_din1_q_net_x0
    );

  delay_din2: entity work.delay_28d2c9d50c
    port map (
      ce => ce_1_sg_x112,
      clk => clk_1_sg_x112,
      clr => '0',
      d => reinterpret_out_output_port_net_x12,
      q => delay_din2_q_net_x0
    );

  delay_din3: entity work.delay_28d2c9d50c
    port map (
      ce => ce_1_sg_x112,
      clk => clk_1_sg_x112,
      clr => '0',
      d => reinterpret_out_output_port_net_x13,
      q => delay_din3_q_net_x0
    );

  delay_map1: entity work.delay_423c6c1400
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => map1_data_net,
      q => delay_map1_q_net
    );

  delay_sel: entity work.delay_85c2ef968b
    port map (
      ce => ce_1_sg_x112,
      clk => clk_1_sg_x112,
      clr => '0',
      d(0) => slice1_y_net,
      q(0) => delay_sel_q_net
    );

  delay_we2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x112,
      clk => clk_1_sg_x112,
      clr => '0',
      d(0) => en_out_op_net_x0,
      q(0) => delay_we2_q_net_x0
    );

  map1: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 8,
      c_width => 8,
      core_name0 => "bmg_72_92d96d23faa10f27",
      latency => 2
    )
    port map (
      addr => slice2_y_net,
      ce => ce_1_sg_x112,
      clk => clk_1_sg_x112,
      en => "1",
      rst => "0",
      data => map1_data_net
    );

  mux: entity work.mux_7f6b7da686
    port map (
      ce => ce_1_sg_x112,
      clk => clk_1_sg_x112,
      clr => '0',
      d0 => delay_d0_q_net,
      d1 => delay_map1_q_net,
      sel(0) => delay_sel_q_net,
      y => mux_y_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 9,
      y_width => 8
    )
    port map (
      x => counter_op_net,
      y => slice2_y_net
    );

  we_expand_8c4a77d2ed: entity work.we_expand_entity_8c4a77d2ed
    port map (
      bus_in => concatenate_y_net_x3,
      lsb_out1 => slice1_y_net_x3,
      msb_out4 => slice4_y_net_x3,
      out2 => slice2_y_net_x3,
      out3 => slice3_y_net_x3
    );

  we_replicate_4c813c783b: entity work.we_replicate_entity_4c813c783b
    port map (
      ce_1 => ce_1_sg_x112,
      clk_1 => clk_1_sg_x112,
      in_x0 => delay_we2_q_net_x0,
      out_x0 => concatenate_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x/sync_delay"

entity sync_delay_entity_21cb29c8f4 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_entity_21cb29c8f4;

architecture structural of sync_delay_entity_21cb29c8f4 is
  signal ce_1_sg_x113: std_logic;
  signal clk_1_sg_x113: std_logic;
  signal constant1_op_net: std_logic_vector(8 downto 0);
  signal constant2_op_net: std_logic_vector(8 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(8 downto 0);
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal d2_q_net_x0: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x3: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x113 <= ce_1;
  clk_1_sg_x113 <= clk_1;
  d2_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x3;

  constant1: entity work.constant_fd85eb7067
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_4a391b9a0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_b4ec9de7d1
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.xlcounter_free_window_and_fft_test_v4
    generic map (
      core_name0 => "cntr_11_0_21ee79a31172f35f",
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x113,
      clk => clk_1_sg_x113,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical_y_net,
      load(0) => d2_q_net_x0,
      rst => "0",
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => d2_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => d2_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x3
    );

  relational: entity work.relational_6c3ee657fa
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_78eac2928d
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/bi_real_unscr_4x"

entity bi_real_unscr_4x_entity_73f633bed2 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    even: in std_logic_vector(35 downto 0); 
    odd: in std_logic_vector(35 downto 0); 
    sync: in std_logic; 
    pol1_out: out std_logic_vector(35 downto 0); 
    pol2_out: out std_logic_vector(35 downto 0); 
    pol3_out: out std_logic_vector(35 downto 0); 
    pol4_out: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end bi_real_unscr_4x_entity_73f633bed2;

architecture structural of bi_real_unscr_4x_entity_73f633bed2 is
  signal c0_op_net: std_logic_vector(8 downto 0);
  signal c1_op_net: std_logic_vector(8 downto 0);
  signal ce_1_sg_x114: std_logic;
  signal clk_1_sg_x114: std_logic;
  signal count_op_net: std_logic_vector(8 downto 0);
  signal d0_q_net: std_logic_vector(35 downto 0);
  signal d2_q_net_x0: std_logic;
  signal d3_q_net_x2: std_logic_vector(35 downto 0);
  signal d4_q_net_x2: std_logic_vector(35 downto 0);
  signal d5_q_net_x2: std_logic_vector(35 downto 0);
  signal d6_q_net_x2: std_logic_vector(35 downto 0);
  signal delay0_q_net_x2: std_logic;
  signal en_even_op_net_x0: std_logic;
  signal en_odd_op_net_x0: std_logic;
  signal en_out_op_net_x0: std_logic;
  signal mux0_y_net_x1: std_logic_vector(35 downto 0);
  signal mux1_y_net_x1: std_logic_vector(35 downto 0);
  signal mux2_y_net_x1: std_logic_vector(35 downto 0);
  signal mux3_y_net_x1: std_logic_vector(35 downto 0);
  signal mux_y_net_x3: std_logic;
  signal post_sync_delay_q_net_x0: std_logic;
  signal r0_op_net: std_logic;
  signal r1_op_net: std_logic;
  signal ram_data_out_net_x4: std_logic_vector(35 downto 0);
  signal ram_data_out_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x10: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x13: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x18: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x19: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x20: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x21: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x22: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x23: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x24: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x13: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x6: std_logic_vector(35 downto 0);
  signal sync_delay1_q_net_x1: std_logic;

begin
  ce_1_sg_x114 <= ce_1;
  clk_1_sg_x114 <= clk_1;
  reinterpret2_output_port_net_x1 <= even;
  reinterpret1_output_port_net_x20 <= odd;
  delay0_q_net_x2 <= sync;
  pol1_out <= reinterpret1_output_port_net_x21;
  pol2_out <= reinterpret1_output_port_net_x22;
  pol3_out <= reinterpret1_output_port_net_x23;
  pol4_out <= reinterpret1_output_port_net_x24;
  sync_out <= sync_delay1_q_net_x1;

  c0: entity work.constant_4a391b9a0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => c0_op_net
    );

  c1: entity work.constant_fd85eb7067
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => c1_op_net
    );

  count: entity work.counter_d5d467f1b8
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      clr => '0',
      rst(0) => post_sync_delay_q_net_x0,
      op => count_op_net
    );

  d0: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      clr => '0',
      d => reinterpret1_output_port_net_x18,
      q => d0_q_net
    );

  d2: entity work.delay_23d71a76f2
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      clr => '0',
      d(0) => post_sync_delay_q_net_x0,
      q(0) => d2_q_net_x0
    );

  d3: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      clr => '0',
      d => reinterpret1_output_port_net_x19,
      q => d3_q_net_x2
    );

  d4: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      clr => '0',
      d => reinterpret1_output_port_net_x11,
      q => d4_q_net_x2
    );

  d5: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      clr => '0',
      d => reinterpret1_output_port_net_x12,
      q => d5_q_net_x2
    );

  d6: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      clr => '0',
      d => reinterpret1_output_port_net_x13,
      q => d6_q_net_x2
    );

  delay0_ea819b516e: entity work.delay0_entity_ea819b516e
    port map (
      ce_1 => ce_1_sg_x114,
      clk_1 => clk_1_sg_x114,
      din => reinterpret_out_output_port_net_x5,
      dout => ram_data_out_net_x4
    );

  delay1_696cf65d05: entity work.delay0_entity_ea819b516e
    port map (
      ce_1 => ce_1_sg_x114,
      clk_1 => clk_1_sg_x114,
      din => reinterpret_out_output_port_net_x6,
      dout => ram_data_out_net_x5
    );

  en_even: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => en_even_op_net_x0
    );

  en_odd: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => en_odd_op_net_x0
    );

  en_out: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => en_out_op_net_x0
    );

  hilbert0_704d36ba55: entity work.hilbert0_entity_704d36ba55
    port map (
      a => mux0_y_net_x1,
      b => mux1_y_net_x1,
      ce_1 => ce_1_sg_x114,
      clk_1 => clk_1_sg_x114,
      even => reinterpret_out_output_port_net_x5,
      odd => reinterpret_out_output_port_net_x6
    );

  hilbert1_1baaad82bd: entity work.hilbert0_entity_704d36ba55
    port map (
      a => mux2_y_net_x1,
      b => mux3_y_net_x1,
      ce_1 => ce_1_sg_x114,
      clk_1 => clk_1_sg_x114,
      even => reinterpret_out_output_port_net_x12,
      odd => reinterpret_out_output_port_net_x13
    );

  mirror_spectrum_eea467ac75: entity work.mirror_spectrum_entity_eea467ac75
    port map (
      ce_1 => ce_1_sg_x114,
      clk_1 => clk_1_sg_x114,
      din0 => ram_data_out_net_x4,
      din1 => ram_data_out_net_x5,
      din2 => reinterpret_out_output_port_net_x12,
      din3 => reinterpret_out_output_port_net_x13,
      reo_in0 => d3_q_net_x2,
      reo_in1 => d4_q_net_x2,
      reo_in2 => d5_q_net_x2,
      reo_in3 => d6_q_net_x2,
      sync => mux_y_net_x3,
      dout0 => reinterpret1_output_port_net_x21,
      dout1 => reinterpret1_output_port_net_x22,
      dout2 => reinterpret1_output_port_net_x23,
      dout3 => reinterpret1_output_port_net_x24,
      sync_out => sync_delay1_q_net_x1
    );

  mux0: entity work.mux_fca786f2ff
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      clr => '0',
      d0 => reinterpret1_output_port_net_x10,
      d1 => d0_q_net,
      sel(0) => r0_op_net,
      y => mux0_y_net_x1
    );

  mux1: entity work.mux_fca786f2ff
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      clr => '0',
      d0 => d0_q_net,
      d1 => reinterpret1_output_port_net_x10,
      sel(0) => r1_op_net,
      y => mux1_y_net_x1
    );

  mux2: entity work.mux_fca786f2ff
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      clr => '0',
      d0 => reinterpret1_output_port_net_x10,
      d1 => d0_q_net,
      sel(0) => r1_op_net,
      y => mux2_y_net_x1
    );

  mux3: entity work.mux_fca786f2ff
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      clr => '0',
      d0 => d0_q_net,
      d1 => reinterpret1_output_port_net_x10,
      sel(0) => r0_op_net,
      y => mux3_y_net_x1
    );

  r0: entity work.relational_6c3ee657fa
    port map (
      a => c0_op_net,
      b => count_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => r0_op_net
    );

  r1: entity work.relational_6c3ee657fa
    port map (
      a => count_op_net,
      b => c1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => r1_op_net
    );

  reorder_even_3d95ec0a9d: entity work.reorder_even_entity_3d95ec0a9d
    port map (
      ce_1 => ce_1_sg_x114,
      clk_1 => clk_1_sg_x114,
      din0 => reinterpret2_output_port_net_x1,
      en => en_even_op_net_x0,
      sync => delay0_q_net_x2,
      dout0 => reinterpret1_output_port_net_x10,
      sync_out => post_sync_delay_q_net_x0
    );

  reorder_odd_19b1685430: entity work.reorder_odd_entity_19b1685430
    port map (
      ce_1 => ce_1_sg_x114,
      clk_1 => clk_1_sg_x114,
      din0 => reinterpret1_output_port_net_x20,
      en => en_odd_op_net_x0,
      sync => delay0_q_net_x2,
      dout0 => reinterpret1_output_port_net_x18
    );

  reorder_out_c7d133390a: entity work.reorder_out_entity_c7d133390a
    port map (
      ce_1 => ce_1_sg_x114,
      clk_1 => clk_1_sg_x114,
      din0 => ram_data_out_net_x4,
      din1 => ram_data_out_net_x5,
      din2 => reinterpret_out_output_port_net_x12,
      din3 => reinterpret_out_output_port_net_x13,
      en => en_out_op_net_x0,
      sync => mux_y_net_x3,
      dout0 => reinterpret1_output_port_net_x19,
      dout1 => reinterpret1_output_port_net_x11,
      dout2 => reinterpret1_output_port_net_x12,
      dout3 => reinterpret1_output_port_net_x13
    );

  sync_delay_21cb29c8f4: entity work.sync_delay_entity_21cb29c8f4
    port map (
      ce_1 => ce_1_sg_x114,
      clk_1 => clk_1_sg_x114,
      in_x0 => d2_q_net_x0,
      out_x0 => mux_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_add/a_debus"

entity a_debus_entity_3c9ba35999 is
  port (
    bus_in: in std_logic_vector(35 downto 0); 
    lsb_out1: out std_logic_vector(17 downto 0); 
    msb_out2: out std_logic_vector(17 downto 0)
  );
end a_debus_entity_3c9ba35999;

architecture structural of a_debus_entity_3c9ba35999 is
  signal reinterpret1_output_port_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal slice1_y_net: std_logic_vector(17 downto 0);
  signal slice2_y_net: std_logic_vector(17 downto 0);

begin
  reinterpret1_output_port_net_x1 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x2;
  msb_out2 <= reinterpret2_output_port_net_x0;

  reinterpret1: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x2
    );

  reinterpret2: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => reinterpret1_output_port_net_x1,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 35,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => reinterpret1_output_port_net_x1,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_add/op_bussify"

entity op_bussify_entity_86a680cc9c is
  port (
    in1: in std_logic_vector(18 downto 0); 
    in2: in std_logic_vector(18 downto 0); 
    bus_out: out std_logic_vector(37 downto 0)
  );
end op_bussify_entity_86a680cc9c;

architecture structural of op_bussify_entity_86a680cc9c is
  signal addsub1_s_net_x0: std_logic_vector(18 downto 0);
  signal addsub2_s_net_x0: std_logic_vector(18 downto 0);
  signal concatenate_y_net_x0: std_logic_vector(37 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(18 downto 0);

begin
  addsub1_s_net_x0 <= in1;
  addsub2_s_net_x0 <= in2;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_5a12f8f9be
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub1_s_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub2_s_net_x0,
      output_port => reinterpret2_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_add"

entity bus_add_entity_d4d899fd09 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    dout: out std_logic_vector(37 downto 0)
  );
end bus_add_entity_d4d899fd09;

architecture structural of bus_add_entity_d4d899fd09 is
  signal addsub1_s_net_x0: std_logic_vector(18 downto 0);
  signal addsub2_s_net_x0: std_logic_vector(18 downto 0);
  signal ce_1_sg_x115: std_logic;
  signal clk_1_sg_x115: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(37 downto 0);
  signal dmux0_q_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(17 downto 0);

begin
  reinterpret1_output_port_net_x3 <= a;
  dmux0_q_net_x1 <= b;
  ce_1_sg_x115 <= ce_1;
  clk_1_sg_x115 <= clk_1;
  dout <= concatenate_y_net_x1;

  a_debus_3c9ba35999: entity work.a_debus_entity_3c9ba35999
    port map (
      bus_in => reinterpret1_output_port_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out2 => reinterpret2_output_port_net_x0
    );

  addsub1: entity work.addsub_e140b59ec8
    port map (
      a => reinterpret2_output_port_net_x0,
      b => reinterpret2_output_port_net_x1,
      ce => ce_1_sg_x115,
      clk => clk_1_sg_x115,
      clr => '0',
      s => addsub1_s_net_x0
    );

  addsub2: entity work.addsub_e140b59ec8
    port map (
      a => reinterpret1_output_port_net_x2,
      b => reinterpret1_output_port_net_x0,
      ce => ce_1_sg_x115,
      clk => clk_1_sg_x115,
      clr => '0',
      s => addsub2_s_net_x0
    );

  b_debus_cc0633c758: entity work.a_debus_entity_3c9ba35999
    port map (
      bus_in => dmux0_q_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  op_bussify_86a680cc9c: entity work.op_bussify_entity_86a680cc9c
    port map (
      in1 => addsub1_s_net_x0,
      in2 => addsub2_s_net_x0,
      bus_out => concatenate_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_convert/conv1/convert"

entity convert_entity_a55c72d4a2 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(19 downto 0); 
    out_x0: out std_logic_vector(17 downto 0)
  );
end convert_entity_a55c72d4a2;

architecture structural of convert_entity_a55c72d4a2 is
  signal adder_s_net_x4: std_logic_vector(17 downto 0);
  signal almost_half_op_net: std_logic_vector(18 downto 0);
  signal bit_y_net: std_logic;
  signal ce_1_sg_x116: std_logic;
  signal clk_1_sg_x116: std_logic;
  signal concat_y_net: std_logic_vector(20 downto 0);
  signal constant_op_net: std_logic;
  signal force1_output_port_net: std_logic_vector(20 downto 0);
  signal force2_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(19 downto 0);
  signal tweak_op_y_net: std_logic;

begin
  ce_1_sg_x116 <= ce_1;
  clk_1_sg_x116 <= clk_1;
  reinterpret4_output_port_net_x0 <= in_x0;
  out_x0 <= adder_s_net_x4;

  adder: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 19,
      a_width => 21,
      b_arith => xlUnsigned,
      b_bin_pt => 19,
      b_width => 19,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 22,
      core_name0 => "addsb_11_0_d11668e2ba580388",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 22,
      latency => 1,
      overflow => 2,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 18
    )
    port map (
      a => force1_output_port_net,
      b => force2_output_port_net,
      ce => ce_1_sg_x116,
      clk => clk_1_sg_x116,
      clr => '0',
      en => "1",
      s => adder_s_net_x4
    );

  almost_half: entity work.constant_4709ea49b5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => almost_half_op_net
    );

  bit: entity work.xlslice
    generic map (
      new_lsb => 19,
      new_msb => 19,
      x_width => 20,
      y_width => 1
    )
    port map (
      x => reinterpret4_output_port_net_x0,
      y(0) => bit_y_net
    );

  concat: entity work.concat_c615d93998
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret_output_port_net,
      in1(0) => tweak_op_y_net,
      y => concat_y_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  force1: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat_y_net,
      output_port => force1_output_port_net
    );

  force2: entity work.reinterpret_d2180c9169
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => almost_half_op_net,
      output_port => force2_output_port_net
    );

  reinterpret: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret4_output_port_net_x0,
      output_port => reinterpret_output_port_net
    );

  tweak_op: entity work.logical_9d76333483
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => bit_y_net,
      d1(0) => constant_op_net,
      y(0) => tweak_op_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_convert/conv1"

entity conv1_entity_fbafc22419 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(19 downto 0); 
    dout: out std_logic_vector(17 downto 0)
  );
end conv1_entity_fbafc22419;

architecture structural of conv1_entity_fbafc22419 is
  signal adder_s_net_x5: std_logic_vector(17 downto 0);
  signal ce_1_sg_x117: std_logic;
  signal clk_1_sg_x117: std_logic;
  signal reinterpret4_output_port_net_x1: std_logic_vector(19 downto 0);

begin
  ce_1_sg_x117 <= ce_1;
  clk_1_sg_x117 <= clk_1;
  reinterpret4_output_port_net_x1 <= din;
  dout <= adder_s_net_x5;

  convert_a55c72d4a2: entity work.convert_entity_a55c72d4a2
    port map (
      ce_1 => ce_1_sg_x117,
      clk_1 => clk_1_sg_x117,
      in_x0 => reinterpret4_output_port_net_x1,
      out_x0 => adder_s_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_convert/debus"

entity debus_entity_ebf3290928 is
  port (
    bus_in: in std_logic_vector(79 downto 0); 
    lsb_out1: out std_logic_vector(19 downto 0); 
    msb_out4: out std_logic_vector(19 downto 0); 
    out2: out std_logic_vector(19 downto 0); 
    out3: out std_logic_vector(19 downto 0)
  );
end debus_entity_ebf3290928;

architecture structural of debus_entity_ebf3290928 is
  signal concatenate_y_net_x0: std_logic_vector(79 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x2: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic_vector(19 downto 0);
  signal slice1_y_net: std_logic_vector(19 downto 0);
  signal slice2_y_net: std_logic_vector(19 downto 0);
  signal slice3_y_net: std_logic_vector(19 downto 0);
  signal slice4_y_net: std_logic_vector(19 downto 0);

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x2;
  msb_out4 <= reinterpret4_output_port_net_x2;
  out2 <= reinterpret2_output_port_net_x2;
  out3 <= reinterpret3_output_port_net_x2;

  reinterpret1: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x2
    );

  reinterpret2: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x2
    );

  reinterpret3: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x2
    );

  reinterpret4: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 19,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 20,
      new_msb => 39,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 40,
      new_msb => 59,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 60,
      new_msb => 79,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_convert"

entity bus_convert_entity_53b3c6c8fb is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(79 downto 0); 
    dout: out std_logic_vector(71 downto 0)
  );
end bus_convert_entity_53b3c6c8fb;

architecture structural of bus_convert_entity_53b3c6c8fb is
  signal adder_s_net_x5: std_logic_vector(17 downto 0);
  signal adder_s_net_x6: std_logic_vector(17 downto 0);
  signal adder_s_net_x7: std_logic_vector(17 downto 0);
  signal adder_s_net_x8: std_logic_vector(17 downto 0);
  signal ce_1_sg_x124: std_logic;
  signal clk_1_sg_x124: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x2: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic_vector(19 downto 0);

begin
  ce_1_sg_x124 <= ce_1;
  clk_1_sg_x124 <= clk_1;
  concatenate_y_net_x2 <= din;
  dout <= concatenate_y_net_x3;

  bussify_ba86ba22e0: entity work.bussify_entity_4a7767fc64
    port map (
      in1 => adder_s_net_x5,
      in2 => adder_s_net_x6,
      in3 => adder_s_net_x7,
      in4 => adder_s_net_x8,
      bus_out => concatenate_y_net_x3
    );

  conv1_fbafc22419: entity work.conv1_entity_fbafc22419
    port map (
      ce_1 => ce_1_sg_x124,
      clk_1 => clk_1_sg_x124,
      din => reinterpret4_output_port_net_x2,
      dout => adder_s_net_x5
    );

  conv2_78428e574d: entity work.conv1_entity_fbafc22419
    port map (
      ce_1 => ce_1_sg_x124,
      clk_1 => clk_1_sg_x124,
      din => reinterpret3_output_port_net_x2,
      dout => adder_s_net_x6
    );

  conv3_7c8dee159c: entity work.conv1_entity_fbafc22419
    port map (
      ce_1 => ce_1_sg_x124,
      clk_1 => clk_1_sg_x124,
      din => reinterpret2_output_port_net_x2,
      dout => adder_s_net_x7
    );

  conv4_c0f18c29d0: entity work.conv1_entity_fbafc22419
    port map (
      ce_1 => ce_1_sg_x124,
      clk_1 => clk_1_sg_x124,
      din => reinterpret1_output_port_net_x2,
      dout => adder_s_net_x8
    );

  debus_ebf3290928: entity work.debus_entity_ebf3290928
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out4 => reinterpret4_output_port_net_x2,
      out2 => reinterpret2_output_port_net_x2,
      out3 => reinterpret3_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_expand"

entity bus_expand_entity_8d8547ea86 is
  port (
    bus_in: in std_logic_vector(71 downto 0); 
    lsb_out1: out std_logic_vector(35 downto 0); 
    msb_out2: out std_logic_vector(35 downto 0)
  );
end bus_expand_entity_8d8547ea86;

architecture structural of bus_expand_entity_8d8547ea86 is
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(35 downto 0);
  signal slice1_y_net: std_logic_vector(35 downto 0);
  signal slice2_y_net: std_logic_vector(35 downto 0);

begin
  concatenate_y_net_x4 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out2 <= reinterpret2_output_port_net_x0;

  reinterpret1: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 35,
      x_width => 72,
      y_width => 36
    )
    port map (
      x => concatenate_y_net_x4,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 36,
      new_msb => 71,
      x_width => 72,
      y_width => 36
    )
    port map (
      x => concatenate_y_net_x4,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_norm0/bussify"

entity bussify_entity_21d703805b is
  port (
    in1: in std_logic_vector(19 downto 0); 
    in2: in std_logic_vector(19 downto 0); 
    in3: in std_logic_vector(19 downto 0); 
    in4: in std_logic_vector(19 downto 0); 
    bus_out: out std_logic_vector(79 downto 0)
  );
end bussify_entity_21d703805b;

architecture structural of bussify_entity_21d703805b is
  signal concatenate_y_net_x0: std_logic_vector(79 downto 0);
  signal conv1_dout_net_x0: std_logic_vector(19 downto 0);
  signal conv2_dout_net_x0: std_logic_vector(19 downto 0);
  signal conv3_dout_net_x0: std_logic_vector(19 downto 0);
  signal conv4_dout_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(19 downto 0);

begin
  conv1_dout_net_x0 <= in1;
  conv2_dout_net_x0 <= in2;
  conv3_dout_net_x0 <= in3;
  conv4_dout_net_x0 <= in4;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_f86ebb6084
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv1_dout_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv2_dout_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv3_dout_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv4_dout_net_x0,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_norm0"

entity bus_norm0_entity_556f388e48 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(75 downto 0); 
    dout: out std_logic_vector(79 downto 0)
  );
end bus_norm0_entity_556f388e48;

architecture structural of bus_norm0_entity_556f388e48 is
  signal ce_1_sg_x125: std_logic;
  signal clk_1_sg_x125: std_logic;
  signal concat_y_net_x1: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(79 downto 0);
  signal conv1_dout_net_x0: std_logic_vector(19 downto 0);
  signal conv2_dout_net_x0: std_logic_vector(19 downto 0);
  signal conv3_dout_net_x0: std_logic_vector(19 downto 0);
  signal conv4_dout_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(18 downto 0);

begin
  ce_1_sg_x125 <= ce_1;
  clk_1_sg_x125 <= clk_1;
  concat_y_net_x1 <= din;
  dout <= concatenate_y_net_x1;

  bussify_21d703805b: entity work.bussify_entity_21d703805b
    port map (
      in1 => conv1_dout_net_x0,
      in2 => conv2_dout_net_x0,
      in3 => conv3_dout_net_x0,
      in4 => conv4_dout_net_x0,
      bus_out => concatenate_y_net_x1
    );

  conv1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 20,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x125,
      clk => clk_1_sg_x125,
      clr => '0',
      din => reinterpret4_output_port_net_x0,
      en => "1",
      dout => conv1_dout_net_x0
    );

  conv2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 20,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x125,
      clk => clk_1_sg_x125,
      clr => '0',
      din => reinterpret3_output_port_net_x0,
      en => "1",
      dout => conv2_dout_net_x0
    );

  conv3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 20,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x125,
      clk => clk_1_sg_x125,
      clr => '0',
      din => reinterpret2_output_port_net_x0,
      en => "1",
      dout => conv3_dout_net_x0
    );

  conv4: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 20,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x125,
      clk => clk_1_sg_x125,
      clr => '0',
      din => reinterpret1_output_port_net_x0,
      en => "1",
      dout => conv4_dout_net_x0
    );

  debus_7377f70a1b: entity work.debus_entity_4d0b597c59
    port map (
      bus_in => concat_y_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out4 => reinterpret4_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_norm1/conv1"

entity conv1_entity_1aac117f63 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(18 downto 0); 
    out_x0: out std_logic_vector(19 downto 0)
  );
end conv1_entity_1aac117f63;

architecture structural of conv1_entity_1aac117f63 is
  signal adder_s_net_x4: std_logic_vector(19 downto 0);
  signal almost_half_op_net: std_logic_vector(18 downto 0);
  signal bit_y_net: std_logic;
  signal ce_1_sg_x126: std_logic;
  signal clk_1_sg_x126: std_logic;
  signal concat_y_net: std_logic_vector(19 downto 0);
  signal constant_op_net: std_logic;
  signal force1_output_port_net: std_logic_vector(19 downto 0);
  signal force2_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(18 downto 0);
  signal tweak_op_y_net: std_logic;

begin
  ce_1_sg_x126 <= ce_1;
  clk_1_sg_x126 <= clk_1;
  reinterpret4_output_port_net_x0 <= in_x0;
  out_x0 <= adder_s_net_x4;

  adder: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 19,
      a_width => 20,
      b_arith => xlUnsigned,
      b_bin_pt => 19,
      b_width => 19,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 21,
      core_name0 => "addsb_11_0_5b4a22e47f2359ce",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 21,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 20
    )
    port map (
      a => force1_output_port_net,
      b => force2_output_port_net,
      ce => ce_1_sg_x126,
      clk => clk_1_sg_x126,
      clr => '0',
      en => "1",
      s => adder_s_net_x4
    );

  almost_half: entity work.constant_b366689086
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => almost_half_op_net
    );

  bit: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 19,
      y_width => 1
    )
    port map (
      x => reinterpret4_output_port_net_x0,
      y(0) => bit_y_net
    );

  concat: entity work.concat_504cae28bd
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret_output_port_net,
      in1(0) => tweak_op_y_net,
      y => concat_y_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  force1: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat_y_net,
      output_port => force1_output_port_net
    );

  force2: entity work.reinterpret_d2180c9169
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => almost_half_op_net,
      output_port => force2_output_port_net
    );

  reinterpret: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret4_output_port_net_x0,
      output_port => reinterpret_output_port_net
    );

  tweak_op: entity work.logical_b1e9d7c303
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => bit_y_net,
      d1(0) => constant_op_net,
      y(0) => tweak_op_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_norm1"

entity bus_norm1_entity_5b41a7e04f is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(75 downto 0); 
    dout: out std_logic_vector(79 downto 0)
  );
end bus_norm1_entity_5b41a7e04f;

architecture structural of bus_norm1_entity_5b41a7e04f is
  signal adder_s_net_x4: std_logic_vector(19 downto 0);
  signal adder_s_net_x5: std_logic_vector(19 downto 0);
  signal adder_s_net_x6: std_logic_vector(19 downto 0);
  signal adder_s_net_x7: std_logic_vector(19 downto 0);
  signal ce_1_sg_x130: std_logic;
  signal clk_1_sg_x130: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(79 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(18 downto 0);

begin
  ce_1_sg_x130 <= ce_1;
  clk_1_sg_x130 <= clk_1;
  concatenate_y_net_x2 <= din;
  dout <= concatenate_y_net_x3;

  bussify_335acc5f5e: entity work.bussify_entity_21d703805b
    port map (
      in1 => adder_s_net_x4,
      in2 => adder_s_net_x5,
      in3 => adder_s_net_x6,
      in4 => adder_s_net_x7,
      bus_out => concatenate_y_net_x3
    );

  conv1_1aac117f63: entity work.conv1_entity_1aac117f63
    port map (
      ce_1 => ce_1_sg_x130,
      clk_1 => clk_1_sg_x130,
      in_x0 => reinterpret4_output_port_net_x1,
      out_x0 => adder_s_net_x4
    );

  conv2_52eab551bc: entity work.conv1_entity_1aac117f63
    port map (
      ce_1 => ce_1_sg_x130,
      clk_1 => clk_1_sg_x130,
      in_x0 => reinterpret3_output_port_net_x1,
      out_x0 => adder_s_net_x5
    );

  conv3_09d2038ecc: entity work.conv1_entity_1aac117f63
    port map (
      ce_1 => ce_1_sg_x130,
      clk_1 => clk_1_sg_x130,
      in_x0 => reinterpret2_output_port_net_x1,
      out_x0 => adder_s_net_x6
    );

  conv4_674711cb72: entity work.conv1_entity_1aac117f63
    port map (
      ce_1 => ce_1_sg_x130,
      clk_1 => clk_1_sg_x130,
      in_x0 => reinterpret1_output_port_net_x1,
      out_x0 => adder_s_net_x7
    );

  debus_7480433945: entity work.debus_entity_fcefc4e7b0
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/bus_sub"

entity bus_sub_entity_3a23401f6f is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    dout: out std_logic_vector(37 downto 0)
  );
end bus_sub_entity_3a23401f6f;

architecture structural of bus_sub_entity_3a23401f6f is
  signal addsub1_s_net_x0: std_logic_vector(18 downto 0);
  signal addsub2_s_net_x0: std_logic_vector(18 downto 0);
  signal ce_1_sg_x131: std_logic;
  signal clk_1_sg_x131: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(37 downto 0);
  signal dmux0_q_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(17 downto 0);

begin
  reinterpret1_output_port_net_x5 <= a;
  dmux0_q_net_x3 <= b;
  ce_1_sg_x131 <= ce_1;
  clk_1_sg_x131 <= clk_1;
  dout <= concatenate_y_net_x1;

  a_debus_aa7e0ae256: entity work.a_debus_entity_3c9ba35999
    port map (
      bus_in => reinterpret1_output_port_net_x5,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out2 => reinterpret2_output_port_net_x0
    );

  addsub1: entity work.addsub_7461f1deba
    port map (
      a => reinterpret2_output_port_net_x0,
      b => reinterpret2_output_port_net_x1,
      ce => ce_1_sg_x131,
      clk => clk_1_sg_x131,
      clr => '0',
      s => addsub1_s_net_x0
    );

  addsub2: entity work.addsub_7461f1deba
    port map (
      a => reinterpret1_output_port_net_x0,
      b => reinterpret1_output_port_net_x1,
      ce => ce_1_sg_x131,
      clk => clk_1_sg_x131,
      clr => '0',
      s => addsub2_s_net_x0
    );

  b_debus_ba1db15323: entity work.a_debus_entity_3c9ba35999
    port map (
      bus_in => dmux0_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  op_bussify_29d1480908: entity work.op_bussify_entity_86a680cc9c
    port map (
      in1 => addsub1_s_net_x0,
      in2 => addsub2_s_net_x0,
      bus_out => concatenate_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/mux/d_bussify"

entity d_bussify_entity_3ab6885c6c is
  port (
    in1: in std_logic_vector(19 downto 0); 
    in2: in std_logic_vector(19 downto 0); 
    in3: in std_logic_vector(19 downto 0); 
    in4: in std_logic_vector(19 downto 0); 
    bus_out: out std_logic_vector(79 downto 0)
  );
end d_bussify_entity_3ab6885c6c;

architecture structural of d_bussify_entity_3ab6885c6c is
  signal concatenate_y_net_x3: std_logic_vector(79 downto 0);
  signal mux0_y_net_x0: std_logic_vector(19 downto 0);
  signal mux1_y_net_x0: std_logic_vector(19 downto 0);
  signal mux2_y_net_x0: std_logic_vector(19 downto 0);
  signal mux3_y_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(19 downto 0);

begin
  mux0_y_net_x0 <= in1;
  mux1_y_net_x0 <= in2;
  mux2_y_net_x0 <= in3;
  mux3_y_net_x0 <= in4;
  bus_out <= concatenate_y_net_x3;

  concatenate: entity work.concat_f86ebb6084
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x3
    );

  reinterpret1: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux0_y_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux1_y_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux2_y_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux3_y_net_x0,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/mux/expand0"

entity expand0_entity_64db0ebd0e is
  port (
    bus_in: in std_logic_vector(79 downto 0); 
    lsb_out1: out std_logic_vector(19 downto 0); 
    msb_out4: out std_logic_vector(19 downto 0); 
    out2: out std_logic_vector(19 downto 0); 
    out3: out std_logic_vector(19 downto 0)
  );
end expand0_entity_64db0ebd0e;

architecture structural of expand0_entity_64db0ebd0e is
  signal concatenate_y_net_x2: std_logic_vector(79 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(19 downto 0);
  signal slice1_y_net: std_logic_vector(19 downto 0);
  signal slice2_y_net: std_logic_vector(19 downto 0);
  signal slice3_y_net: std_logic_vector(19 downto 0);
  signal slice4_y_net: std_logic_vector(19 downto 0);

begin
  concatenate_y_net_x2 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 19,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 20,
      new_msb => 39,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 40,
      new_msb => 59,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 60,
      new_msb => 79,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/mux/sel_expand"

entity sel_expand_entity_80d467162d is
  port (
    bus_in: in std_logic_vector(3 downto 0); 
    lsb_out1: out std_logic; 
    msb_out4: out std_logic; 
    out2: out std_logic; 
    out3: out std_logic
  );
end sel_expand_entity_80d467162d;

architecture structural of sel_expand_entity_80d467162d is
  signal concatenate_y_net_x0: std_logic_vector(3 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic;
  signal reinterpret2_output_port_net_x0: std_logic;
  signal reinterpret3_output_port_net_x0: std_logic;
  signal reinterpret4_output_port_net_x0: std_logic;
  signal slice1_y_net: std_logic;
  signal slice2_y_net: std_logic;
  signal slice3_y_net: std_logic;
  signal slice4_y_net: std_logic;

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice1_y_net,
      output_port(0) => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice2_y_net,
      output_port(0) => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice3_y_net,
      output_port(0) => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice4_y_net,
      output_port(0) => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/mux"

entity mux_entity_2728a89004 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d0: in std_logic_vector(79 downto 0); 
    d1: in std_logic_vector(79 downto 0); 
    sel: in std_logic_vector(3 downto 0); 
    out_x0: out std_logic_vector(79 downto 0)
  );
end mux_entity_2728a89004;

architecture structural of mux_entity_2728a89004 is
  signal ce_1_sg_x132: std_logic;
  signal clk_1_sg_x132: std_logic;
  signal concatenate_y_net_x5: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(79 downto 0);
  signal mux0_y_net_x0: std_logic_vector(19 downto 0);
  signal mux1_y_net_x0: std_logic_vector(19 downto 0);
  signal mux2_y_net_x0: std_logic_vector(19 downto 0);
  signal mux3_y_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic;
  signal reinterpret2_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic;
  signal reinterpret3_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x2: std_logic;
  signal reinterpret4_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic;

begin
  ce_1_sg_x132 <= ce_1;
  clk_1_sg_x132 <= clk_1;
  concatenate_y_net_x5 <= d0;
  concatenate_y_net_x6 <= d1;
  concatenate_y_net_x7 <= sel;
  out_x0 <= concatenate_y_net_x8;

  d_bussify_3ab6885c6c: entity work.d_bussify_entity_3ab6885c6c
    port map (
      in1 => mux0_y_net_x0,
      in2 => mux1_y_net_x0,
      in3 => mux2_y_net_x0,
      in4 => mux3_y_net_x0,
      bus_out => concatenate_y_net_x8
    );

  expand0_64db0ebd0e: entity work.expand0_entity_64db0ebd0e
    port map (
      bus_in => concatenate_y_net_x5,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out4 => reinterpret4_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0
    );

  expand1_54168a3c30: entity work.expand0_entity_64db0ebd0e
    port map (
      bus_in => concatenate_y_net_x6,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

  mux0: entity work.mux_ce20fdf7b8
    port map (
      ce => ce_1_sg_x132,
      clk => clk_1_sg_x132,
      clr => '0',
      d0 => reinterpret4_output_port_net_x0,
      d1 => reinterpret4_output_port_net_x1,
      sel(0) => reinterpret4_output_port_net_x2,
      y => mux0_y_net_x0
    );

  mux1: entity work.mux_ce20fdf7b8
    port map (
      ce => ce_1_sg_x132,
      clk => clk_1_sg_x132,
      clr => '0',
      d0 => reinterpret3_output_port_net_x0,
      d1 => reinterpret3_output_port_net_x1,
      sel(0) => reinterpret3_output_port_net_x2,
      y => mux1_y_net_x0
    );

  mux2: entity work.mux_ce20fdf7b8
    port map (
      ce => ce_1_sg_x132,
      clk => clk_1_sg_x132,
      clr => '0',
      d0 => reinterpret2_output_port_net_x0,
      d1 => reinterpret2_output_port_net_x1,
      sel(0) => reinterpret2_output_port_net_x2,
      y => mux2_y_net_x0
    );

  mux3: entity work.mux_ce20fdf7b8
    port map (
      ce => ce_1_sg_x132,
      clk => clk_1_sg_x132,
      clr => '0',
      d0 => reinterpret1_output_port_net_x0,
      d1 => reinterpret1_output_port_net_x1,
      sel(0) => reinterpret1_output_port_net_x2,
      y => mux3_y_net_x0
    );

  sel_expand_80d467162d: entity work.sel_expand_entity_80d467162d
    port map (
      bus_in => concatenate_y_net_x7,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out4 => reinterpret4_output_port_net_x2,
      out2 => reinterpret2_output_port_net_x2,
      out3 => reinterpret3_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct/shift_replicate"

entity shift_replicate_entity_7f26e672bf is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic_vector(3 downto 0)
  );
end shift_replicate_entity_7f26e672bf;

architecture structural of shift_replicate_entity_7f26e672bf is
  signal ce_1_sg_x133: std_logic;
  signal clk_1_sg_x133: std_logic;
  signal concatenate_y_net_x9: std_logic_vector(3 downto 0);
  signal din0_0_q_net_x0: std_logic;
  signal din0_1_q_net_x0: std_logic;
  signal din0_2_q_net_x0: std_logic;
  signal din0_3_q_net_x0: std_logic;
  signal slice0_y_net_x0: std_logic;

begin
  ce_1_sg_x133 <= ce_1;
  clk_1_sg_x133 <= clk_1;
  slice0_y_net_x0 <= in_x0;
  out_x0 <= concatenate_y_net_x9;

  bussify_d803f98ab4: entity work.bussify_entity_5c62d70bd7
    port map (
      in1 => din0_0_q_net_x0,
      in2 => din0_1_q_net_x0,
      in3 => din0_2_q_net_x0,
      in4 => din0_3_q_net_x0,
      bus_out => concatenate_y_net_x9
    );

  din0_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x133,
      clk => clk_1_sg_x133,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_0_q_net_x0
    );

  din0_1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x133,
      clk => clk_1_sg_x133,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_1_q_net_x0
    );

  din0_2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x133,
      clk => clk_1_sg_x133,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_2_q_net_x0
    );

  din0_3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x133,
      clk => clk_1_sg_x133,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_3_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/butterfly_direct"

entity butterfly_direct_entity_b23e641f27 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(35 downto 0); 
    a_bw_x0: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end butterfly_direct_entity_b23e641f27;

architecture structural of butterfly_direct_entity_b23e641f27 is
  signal ce_1_sg_x134: std_logic;
  signal clk_1_sg_x134: std_logic;
  signal concat_y_net_x3: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(79 downto 0);
  signal delay0_q_net_x0: std_logic;
  signal dmux0_q_net_x4: std_logic_vector(35 downto 0);
  signal mux_y_net_x0: std_logic;
  signal reinterpret1_output_port_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x6 <= a;
  dmux0_q_net_x4 <= b;
  ce_1_sg_x134 <= ce_1;
  clk_1_sg_x134 <= clk_1;
  slice0_y_net_x1 <= shift;
  mux_y_net_x0 <= sync_in;
  a_bw <= reinterpret1_output_port_net_x1;
  a_bw_x0 <= reinterpret2_output_port_net_x1;
  sync_out <= delay0_q_net_x0;

  bus_add_d4d899fd09: entity work.bus_add_entity_d4d899fd09
    port map (
      a => reinterpret1_output_port_net_x6,
      b => dmux0_q_net_x4,
      ce_1 => ce_1_sg_x134,
      clk_1 => clk_1_sg_x134,
      dout => concatenate_y_net_x1
    );

  bus_convert_53b3c6c8fb: entity work.bus_convert_entity_53b3c6c8fb
    port map (
      ce_1 => ce_1_sg_x134,
      clk_1 => clk_1_sg_x134,
      din => concatenate_y_net_x9,
      dout => concatenate_y_net_x4
    );

  bus_expand_8d8547ea86: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  bus_norm0_556f388e48: entity work.bus_norm0_entity_556f388e48
    port map (
      ce_1 => ce_1_sg_x134,
      clk_1 => clk_1_sg_x134,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x5
    );

  bus_norm1_5b41a7e04f: entity work.bus_norm1_entity_5b41a7e04f
    port map (
      ce_1 => ce_1_sg_x134,
      clk_1 => clk_1_sg_x134,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x6
    );

  bus_scale_4457125418: entity work.bus_scale_entity_a0e6fff9af
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_3a23401f6f: entity work.bus_sub_entity_3a23401f6f
    port map (
      a => reinterpret1_output_port_net_x6,
      b => dmux0_q_net_x4,
      ce_1 => ce_1_sg_x134,
      clk_1 => clk_1_sg_x134,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_4822199898
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x1,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  delay0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      clr => '0',
      d(0) => mux_y_net_x0,
      q(0) => delay0_q_net_x0
    );

  mux_2728a89004: entity work.mux_entity_2728a89004
    port map (
      ce_1 => ce_1_sg_x134,
      clk_1 => clk_1_sg_x134,
      d0 => concatenate_y_net_x5,
      d1 => concatenate_y_net_x6,
      sel => concatenate_y_net_x10,
      out_x0 => concatenate_y_net_x9
    );

  shift_replicate_7f26e672bf: entity work.shift_replicate_entity_7f26e672bf
    port map (
      ce_1 => ce_1_sg_x134,
      clk_1 => clk_1_sg_x134,
      in_x0 => slice0_y_net_x1,
      out_x0 => concatenate_y_net_x10
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/delay0"

entity delay0_entity_84c44c44f7 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end delay0_entity_84c44c44f7;

architecture structural of delay0_entity_84c44c44f7 is
  signal ce_1_sg_x135: std_logic;
  signal clk_1_sg_x135: std_logic;
  signal del1_q_net_x0: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x135 <= ce_1;
  clk_1_sg_x135 <= clk_1;
  din2_q_net_x1 <= din;
  dout <= reinterpret1_output_port_net_x2;

  del1: entity work.delay_1f855d073b
    port map (
      ce => ce_1_sg_x135,
      clk => clk_1_sg_x135,
      clr => '0',
      d => reinterpret1_output_port_net_x0,
      q => del1_q_net_x0
    );

  din_expand_17323a5850: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => din2_q_net_x1,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  dout_compress_0eb0dbe2ed: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => del1_q_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1/sync_delay"

entity sync_delay_entity_ce328052c4 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_entity_ce328052c4;

architecture structural of sync_delay_entity_ce328052c4 is
  signal ce_1_sg_x137: std_logic;
  signal clk_1_sg_x137: std_logic;
  signal constant1_op_net: std_logic_vector(8 downto 0);
  signal constant2_op_net: std_logic_vector(8 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(8 downto 0);
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal dsync1_q_net_x0: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x1: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x137 <= ce_1;
  clk_1_sg_x137 <= clk_1;
  dsync1_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x1;

  constant1: entity work.constant_fd85eb7067
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_4a391b9a0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_b4ec9de7d1
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_1dea202a2f
    port map (
      ce => ce_1_sg_x137,
      clk => clk_1_sg_x137,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical_y_net,
      load(0) => dsync1_q_net_x0,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x1
    );

  relational: entity work.relational_6c3ee657fa
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_78eac2928d
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_1"

entity fft_stage_1_entity_034856f8b2 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    out1: out std_logic_vector(35 downto 0); 
    out2: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_stage_1_entity_034856f8b2;

architecture structural of fft_stage_1_entity_034856f8b2 is
  signal ce_1_sg_x138: std_logic;
  signal clk_1_sg_x138: std_logic;
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal delay0_q_net_x1: std_logic;
  signal delay10_q_net_x0: std_logic;
  signal delay11_q_net_x0: std_logic_vector(10 downto 0);
  signal din0_q_net: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal dmux0_q_net_x4: std_logic_vector(35 downto 0);
  signal dmux1_q_net_x1: std_logic_vector(35 downto 0);
  signal dsync0_q_net: std_logic;
  signal dsync1_q_net_x0: std_logic;
  signal mux0_y_net: std_logic_vector(35 downto 0);
  signal mux1_y_net: std_logic_vector(35 downto 0);
  signal mux_y_net_x1: std_logic;
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x8: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice1_y_net: std_logic;

begin
  ce_1_sg_x138 <= ce_1;
  clk_1_sg_x138 <= clk_1;
  reinterpret1_output_port_net_x3 <= in1;
  reinterpret1_output_port_net_x4 <= in2;
  delay11_q_net_x0 <= shift;
  delay10_q_net_x0 <= sync;
  out1 <= reinterpret2_output_port_net_x2;
  out2 <= reinterpret1_output_port_net_x9;
  sync_out <= delay0_q_net_x1;

  butterfly_direct_b23e641f27: entity work.butterfly_direct_entity_b23e641f27
    port map (
      a => reinterpret1_output_port_net_x8,
      b => dmux0_q_net_x4,
      ce_1 => ce_1_sg_x138,
      clk_1 => clk_1_sg_x138,
      shift => slice0_y_net_x1,
      sync_in => mux_y_net_x1,
      a_bw => reinterpret1_output_port_net_x9,
      a_bw_x0 => reinterpret2_output_port_net_x2,
      sync_out => delay0_q_net_x1
    );

  counter: entity work.counter_d5d467f1b8
    port map (
      ce => ce_1_sg_x138,
      clk => clk_1_sg_x138,
      clr => '0',
      rst(0) => dsync0_q_net,
      op => counter_op_net
    );

  delay0_84c44c44f7: entity work.delay0_entity_84c44c44f7
    port map (
      ce_1 => ce_1_sg_x138,
      clk_1 => clk_1_sg_x138,
      din => din2_q_net_x1,
      dout => reinterpret1_output_port_net_x2
    );

  delay1_27031942da: entity work.delay0_entity_84c44c44f7
    port map (
      ce_1 => ce_1_sg_x138,
      clk_1 => clk_1_sg_x138,
      din => dmux1_q_net_x1,
      dout => reinterpret1_output_port_net_x8
    );

  din0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret1_output_port_net_x3,
      q => din0_q_net
    );

  din2: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret1_output_port_net_x4,
      q => din2_q_net_x1
    );

  dmux0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux0_y_net,
      q => dmux0_q_net_x4
    );

  dmux1: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux1_y_net,
      q => dmux1_q_net_x1
    );

  dsync0: entity work.delay_0341f7be44
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d(0) => delay10_q_net_x0,
      q(0) => dsync0_q_net
    );

  dsync1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x138,
      clk => clk_1_sg_x138,
      clr => '0',
      d(0) => dsync0_q_net,
      q(0) => dsync1_q_net_x0
    );

  mux0: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x138,
      clk => clk_1_sg_x138,
      clr => '0',
      d0 => reinterpret1_output_port_net_x2,
      d1 => din0_q_net,
      sel(0) => slice1_y_net,
      y => mux0_y_net
    );

  mux1: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x138,
      clk => clk_1_sg_x138,
      clr => '0',
      d0 => din0_q_net,
      d1 => reinterpret1_output_port_net_x2,
      sel(0) => slice1_y_net,
      y => mux1_y_net
    );

  slice0: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 11,
      y_width => 1
    )
    port map (
      x => delay11_q_net_x0,
      y(0) => slice0_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice1_y_net
    );

  sync_delay_ce328052c4: entity work.sync_delay_entity_ce328052c4
    port map (
      ce_1 => ce_1_sg_x138,
      clk_1 => clk_1_sg_x138,
      in_x0 => dsync1_q_net_x0,
      out_x0 => mux_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_2/butterfly_direct/twiddle/negate"

entity negate_entity_02f5c8ab94 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(17 downto 0); 
    dout: out std_logic_vector(17 downto 0)
  );
end negate_entity_02f5c8ab94;

architecture structural of negate_entity_02f5c8ab94 is
  signal ce_1_sg_x158: std_logic;
  signal clk_1_sg_x158: std_logic;
  signal neg1_op_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x158 <= ce_1;
  clk_1_sg_x158 <= clk_1;
  reinterpret2_output_port_net_x2 <= din;
  dout <= reinterpret1_output_port_net_x2;

  bussify_a8c912744d: entity work.bussify_entity_03337980a5
    port map (
      in1 => neg1_op_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

  debus_7969604100: entity work.a_debus_entity_96461a65c3
    port map (
      bus_in => reinterpret2_output_port_net_x2,
      msb_lsb_out1 => reinterpret1_output_port_net_x1
    );

  neg1: entity work.negate_a9c5a8edc5
    port map (
      ce => ce_1_sg_x158,
      clk => clk_1_sg_x158,
      clr => '0',
      ip => reinterpret1_output_port_net_x1,
      op => neg1_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_2/butterfly_direct/twiddle"

entity twiddle_entity_32c6348bc5 is
  port (
    ai: in std_logic_vector(35 downto 0); 
    bi: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ao: out std_logic_vector(35 downto 0); 
    bwo: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end twiddle_entity_32c6348bc5;

architecture structural of twiddle_entity_32c6348bc5 is
  signal ce_1_sg_x159: std_logic;
  signal clk_1_sg_x159: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(35 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay0_q_net_x4: std_logic_vector(35 downto 0);
  signal delay2_q_net: std_logic;
  signal delay3_q_net: std_logic_vector(17 downto 0);
  signal delay4_q_net: std_logic_vector(17 downto 0);
  signal delay5_q_net: std_logic_vector(17 downto 0);
  signal delay6_q_net: std_logic_vector(17 downto 0);
  signal delay7_q_net: std_logic;
  signal delay8_q_net_x0: std_logic;
  signal dmux0_q_net_x1: std_logic_vector(35 downto 0);
  signal mux0_y_net_x0: std_logic_vector(17 downto 0);
  signal mux1_y_net_x0: std_logic_vector(17 downto 0);
  signal mux_y_net_x0: std_logic;
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret_out_output_port_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x5: std_logic_vector(35 downto 0);
  signal slice_y_net: std_logic;

begin
  reinterpret1_output_port_net_x1 <= ai;
  dmux0_q_net_x1 <= bi;
  ce_1_sg_x159 <= ce_1;
  clk_1_sg_x159 <= clk_1;
  mux_y_net_x0 <= sync_in;
  ao <= delay0_q_net_x4;
  bwo <= reinterpret_out_output_port_net_x5;
  sync_out <= delay8_q_net_x0;

  bus_create_6e939801d3: entity work.join_entity_60290f1f6b
    port map (
      in1 => mux0_y_net_x0,
      in2 => mux1_y_net_x0,
      bus_out => concatenate_y_net_x2
    );

  bus_expand_f05c58a49f: entity work.bus_expand_a_entity_708163d551
    port map (
      bus_in => reinterpret_out_output_port_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out2 => reinterpret2_output_port_net_x2
    );

  counter: entity work.counter_11ccef49a2
    port map (
      ce => ce_1_sg_x159,
      clk => clk_1_sg_x159,
      clr => '0',
      rst(0) => delay7_q_net,
      op => counter_op_net
    );

  delay0: entity work.delay_28d2c9d50c
    port map (
      ce => ce_1_sg_x159,
      clk => clk_1_sg_x159,
      clr => '0',
      d => reinterpret1_output_port_net_x1,
      q => delay0_q_net_x4
    );

  delay2: entity work.delay_85c2ef968b
    port map (
      ce => ce_1_sg_x159,
      clk => clk_1_sg_x159,
      clr => '0',
      d(0) => slice_y_net,
      q(0) => delay2_q_net
    );

  delay3: entity work.delay_328e8ebbb5
    port map (
      ce => ce_1_sg_x159,
      clk => clk_1_sg_x159,
      clr => '0',
      d => delay6_q_net,
      q => delay3_q_net
    );

  delay4: entity work.delay_328e8ebbb5
    port map (
      ce => ce_1_sg_x159,
      clk => clk_1_sg_x159,
      clr => '0',
      d => reinterpret1_output_port_net_x2,
      q => delay4_q_net
    );

  delay5: entity work.delay_cbdfa55dc3
    port map (
      ce => ce_1_sg_x159,
      clk => clk_1_sg_x159,
      clr => '0',
      d => reinterpret2_output_port_net_x2,
      q => delay5_q_net
    );

  delay6: entity work.delay_cbdfa55dc3
    port map (
      ce => ce_1_sg_x159,
      clk => clk_1_sg_x159,
      clr => '0',
      d => reinterpret1_output_port_net_x0,
      q => delay6_q_net
    );

  delay7: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x159,
      clk => clk_1_sg_x159,
      clr => '0',
      d(0) => mux_y_net_x0,
      q(0) => delay7_q_net
    );

  delay8: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x159,
      clk => clk_1_sg_x159,
      clr => '0',
      d(0) => delay7_q_net,
      q(0) => delay8_q_net_x0
    );

  munge_in_5bed356d8a: entity work.munge_a_entity_327df61d65
    port map (
      din => dmux0_q_net_x1,
      dout => reinterpret_out_output_port_net_x1
    );

  munge_out_4d24a9791b: entity work.munge_a_entity_327df61d65
    port map (
      din => concatenate_y_net_x2,
      dout => reinterpret_out_output_port_net_x5
    );

  mux0: entity work.mux_74a3397f06
    port map (
      ce => ce_1_sg_x159,
      clk => clk_1_sg_x159,
      clr => '0',
      d0 => delay5_q_net,
      d1 => delay6_q_net,
      sel(0) => slice_y_net,
      y => mux0_y_net_x0
    );

  mux1: entity work.mux_181e58d842
    port map (
      ce => ce_1_sg_x159,
      clk => clk_1_sg_x159,
      clr => '0',
      d0 => delay3_q_net,
      d1 => delay4_q_net,
      sel(0) => delay2_q_net,
      y => mux1_y_net_x0
    );

  negate_02f5c8ab94: entity work.negate_entity_02f5c8ab94
    port map (
      ce_1 => ce_1_sg_x159,
      clk_1 => clk_1_sg_x159,
      din => reinterpret2_output_port_net_x2,
      dout => reinterpret1_output_port_net_x2
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 7,
      new_msb => 7,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_2/butterfly_direct"

entity butterfly_direct_entity_cb7d3cc823 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(35 downto 0); 
    a_bw_x0: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end butterfly_direct_entity_cb7d3cc823;

architecture structural of butterfly_direct_entity_cb7d3cc823 is
  signal ce_1_sg_x160: std_logic;
  signal clk_1_sg_x160: std_logic;
  signal concat_y_net_x3: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(79 downto 0);
  signal delay0_q_net_x0: std_logic;
  signal delay0_q_net_x4: std_logic_vector(35 downto 0);
  signal delay8_q_net_x0: std_logic;
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal mux_y_net_x1: std_logic;
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret_out_output_port_net_x5: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x2 <= a;
  dmux0_q_net_x2 <= b;
  ce_1_sg_x160 <= ce_1;
  clk_1_sg_x160 <= clk_1;
  slice0_y_net_x1 <= shift;
  mux_y_net_x1 <= sync_in;
  a_bw <= reinterpret1_output_port_net_x3;
  a_bw_x0 <= reinterpret2_output_port_net_x1;
  sync_out <= delay0_q_net_x0;

  bus_add_8db883d746: entity work.bus_add_entity_d4d899fd09
    port map (
      a => delay0_q_net_x4,
      b => reinterpret_out_output_port_net_x5,
      ce_1 => ce_1_sg_x160,
      clk_1 => clk_1_sg_x160,
      dout => concatenate_y_net_x1
    );

  bus_convert_6cf938669f: entity work.bus_convert_entity_53b3c6c8fb
    port map (
      ce_1 => ce_1_sg_x160,
      clk_1 => clk_1_sg_x160,
      din => concatenate_y_net_x9,
      dout => concatenate_y_net_x4
    );

  bus_expand_a97bf16f9d: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x3,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  bus_norm0_170e5a1b26: entity work.bus_norm0_entity_556f388e48
    port map (
      ce_1 => ce_1_sg_x160,
      clk_1 => clk_1_sg_x160,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x5
    );

  bus_norm1_c9ba836d83: entity work.bus_norm1_entity_5b41a7e04f
    port map (
      ce_1 => ce_1_sg_x160,
      clk_1 => clk_1_sg_x160,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x6
    );

  bus_scale_1c82797d8d: entity work.bus_scale_entity_a0e6fff9af
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_6ec0ee0af9: entity work.bus_sub_entity_3a23401f6f
    port map (
      a => delay0_q_net_x4,
      b => reinterpret_out_output_port_net_x5,
      ce_1 => ce_1_sg_x160,
      clk_1 => clk_1_sg_x160,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_4822199898
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x1,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  delay0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x160,
      clk => clk_1_sg_x160,
      clr => '0',
      d(0) => delay8_q_net_x0,
      q(0) => delay0_q_net_x0
    );

  mux_9b43790396: entity work.mux_entity_2728a89004
    port map (
      ce_1 => ce_1_sg_x160,
      clk_1 => clk_1_sg_x160,
      d0 => concatenate_y_net_x5,
      d1 => concatenate_y_net_x6,
      sel => concatenate_y_net_x10,
      out_x0 => concatenate_y_net_x9
    );

  shift_replicate_fbdfdde73c: entity work.shift_replicate_entity_7f26e672bf
    port map (
      ce_1 => ce_1_sg_x160,
      clk_1 => clk_1_sg_x160,
      in_x0 => slice0_y_net_x1,
      out_x0 => concatenate_y_net_x10
    );

  twiddle_32c6348bc5: entity work.twiddle_entity_32c6348bc5
    port map (
      ai => reinterpret1_output_port_net_x2,
      bi => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x160,
      clk_1 => clk_1_sg_x160,
      sync_in => mux_y_net_x1,
      ao => delay0_q_net_x4,
      bwo => reinterpret_out_output_port_net_x5,
      sync_out => delay8_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_2/delay0"

entity delay0_entity_171fb53a25 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end delay0_entity_171fb53a25;

architecture structural of delay0_entity_171fb53a25 is
  signal ce_1_sg_x161: std_logic;
  signal clk_1_sg_x161: std_logic;
  signal del1_q_net_x0: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x161 <= ce_1;
  clk_1_sg_x161 <= clk_1;
  din2_q_net_x1 <= din;
  dout <= reinterpret1_output_port_net_x2;

  del1: entity work.delay_c33e9b879a
    port map (
      ce => ce_1_sg_x161,
      clk => clk_1_sg_x161,
      clr => '0',
      d => reinterpret1_output_port_net_x0,
      q => del1_q_net_x0
    );

  din_expand_92d3ebf8b4: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => din2_q_net_x1,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  dout_compress_bc4ee5ec2d: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => del1_q_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_2/sync_delay"

entity sync_delay_entity_9d62e7f1b5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_entity_9d62e7f1b5;

architecture structural of sync_delay_entity_9d62e7f1b5 is
  signal ce_1_sg_x163: std_logic;
  signal clk_1_sg_x163: std_logic;
  signal constant1_op_net: std_logic_vector(7 downto 0);
  signal constant2_op_net: std_logic_vector(7 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(7 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal dsync1_q_net_x0: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x2: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x163 <= ce_1;
  clk_1_sg_x163 <= clk_1;
  dsync1_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x2;

  constant1: entity work.constant_91ef1678ca
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_e8aae5d3bb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_b437b02512
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_a98fb09579
    port map (
      ce => ce_1_sg_x163,
      clk => clk_1_sg_x163,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical_y_net,
      load(0) => dsync1_q_net_x0,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x2
    );

  relational: entity work.relational_54048c8b02
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_16235eb2bf
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_2"

entity fft_stage_2_entity_4375fddaf7 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    out1: out std_logic_vector(35 downto 0); 
    out2: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_stage_2_entity_4375fddaf7;

architecture structural of fft_stage_2_entity_4375fddaf7 is
  signal ce_1_sg_x164: std_logic;
  signal clk_1_sg_x164: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay0_q_net_x2: std_logic;
  signal delay0_q_net_x3: std_logic;
  signal delay11_q_net_x1: std_logic_vector(10 downto 0);
  signal din0_q_net: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal dmux1_q_net_x1: std_logic_vector(35 downto 0);
  signal dsync0_q_net: std_logic;
  signal dsync1_q_net_x0: std_logic;
  signal mux0_y_net: std_logic_vector(35 downto 0);
  signal mux1_y_net: std_logic_vector(35 downto 0);
  signal mux_y_net_x2: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x4: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice1_y_net: std_logic;

begin
  ce_1_sg_x164 <= ce_1;
  clk_1_sg_x164 <= clk_1;
  reinterpret2_output_port_net_x3 <= in1;
  reinterpret1_output_port_net_x10 <= in2;
  delay11_q_net_x1 <= shift;
  delay0_q_net_x2 <= sync;
  out1 <= reinterpret2_output_port_net_x4;
  out2 <= reinterpret1_output_port_net_x11;
  sync_out <= delay0_q_net_x3;

  butterfly_direct_cb7d3cc823: entity work.butterfly_direct_entity_cb7d3cc823
    port map (
      a => reinterpret1_output_port_net_x4,
      b => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x164,
      clk_1 => clk_1_sg_x164,
      shift => slice0_y_net_x1,
      sync_in => mux_y_net_x2,
      a_bw => reinterpret1_output_port_net_x11,
      a_bw_x0 => reinterpret2_output_port_net_x4,
      sync_out => delay0_q_net_x3
    );

  counter: entity work.counter_11ccef49a2
    port map (
      ce => ce_1_sg_x164,
      clk => clk_1_sg_x164,
      clr => '0',
      rst(0) => dsync0_q_net,
      op => counter_op_net
    );

  delay0_171fb53a25: entity work.delay0_entity_171fb53a25
    port map (
      ce_1 => ce_1_sg_x164,
      clk_1 => clk_1_sg_x164,
      din => din2_q_net_x1,
      dout => reinterpret1_output_port_net_x2
    );

  delay1_9729284d42: entity work.delay0_entity_171fb53a25
    port map (
      ce_1 => ce_1_sg_x164,
      clk_1 => clk_1_sg_x164,
      din => dmux1_q_net_x1,
      dout => reinterpret1_output_port_net_x4
    );

  din0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret2_output_port_net_x3,
      q => din0_q_net
    );

  din2: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret1_output_port_net_x10,
      q => din2_q_net_x1
    );

  dmux0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux0_y_net,
      q => dmux0_q_net_x2
    );

  dmux1: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux1_y_net,
      q => dmux1_q_net_x1
    );

  dsync0: entity work.delay_0341f7be44
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d(0) => delay0_q_net_x2,
      q(0) => dsync0_q_net
    );

  dsync1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x164,
      clk => clk_1_sg_x164,
      clr => '0',
      d(0) => dsync0_q_net,
      q(0) => dsync1_q_net_x0
    );

  mux0: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x164,
      clk => clk_1_sg_x164,
      clr => '0',
      d0 => reinterpret1_output_port_net_x2,
      d1 => din0_q_net,
      sel(0) => slice1_y_net,
      y => mux0_y_net
    );

  mux1: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x164,
      clk => clk_1_sg_x164,
      clr => '0',
      d0 => din0_q_net,
      d1 => reinterpret1_output_port_net_x2,
      sel(0) => slice1_y_net,
      y => mux1_y_net
    );

  slice0: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 11,
      y_width => 1
    )
    port map (
      x => delay11_q_net_x1,
      y(0) => slice0_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 7,
      new_msb => 7,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice1_y_net
    );

  sync_delay_9d62e7f1b5: entity work.sync_delay_entity_9d62e7f1b5
    port map (
      ce_1 => ce_1_sg_x164,
      clk_1 => clk_1_sg_x164,
      in_x0 => dsync1_q_net_x0,
      out_x0 => mux_y_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_add/b_debus"

entity b_debus_entity_f0b98765c5 is
  port (
    bus_in: in std_logic_vector(37 downto 0); 
    lsb_out1: out std_logic_vector(18 downto 0); 
    msb_out2: out std_logic_vector(18 downto 0)
  );
end b_debus_entity_f0b98765c5;

architecture structural of b_debus_entity_f0b98765c5 is
  signal concatenate_y_net_x0: std_logic_vector(37 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(18 downto 0);
  signal slice1_y_net: std_logic_vector(18 downto 0);
  signal slice2_y_net: std_logic_vector(18 downto 0);

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out2 <= reinterpret2_output_port_net_x0;

  reinterpret1: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 18,
      x_width => 38,
      y_width => 19
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 19,
      new_msb => 37,
      x_width => 38,
      y_width => 19
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_add/op_bussify"

entity op_bussify_entity_6c938aee01 is
  port (
    in1: in std_logic_vector(19 downto 0); 
    in2: in std_logic_vector(19 downto 0); 
    bus_out: out std_logic_vector(39 downto 0)
  );
end op_bussify_entity_6c938aee01;

architecture structural of op_bussify_entity_6c938aee01 is
  signal addsub1_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub2_s_net_x0: std_logic_vector(19 downto 0);
  signal concatenate_y_net_x0: std_logic_vector(39 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(19 downto 0);

begin
  addsub1_s_net_x0 <= in1;
  addsub2_s_net_x0 <= in2;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_9e724c4b50
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub1_s_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub2_s_net_x0,
      output_port => reinterpret2_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_add"

entity bus_add_entity_b1cdda5af7 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(37 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    dout: out std_logic_vector(39 downto 0)
  );
end bus_add_entity_b1cdda5af7;

architecture structural of bus_add_entity_b1cdda5af7 is
  signal addsub1_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub2_s_net_x0: std_logic_vector(19 downto 0);
  signal ce_1_sg_x165: std_logic;
  signal clk_1_sg_x165: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(39 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(18 downto 0);

begin
  reinterpret1_output_port_net_x3 <= a;
  concatenate_y_net_x2 <= b;
  ce_1_sg_x165 <= ce_1;
  clk_1_sg_x165 <= clk_1;
  dout <= concatenate_y_net_x3;

  a_debus_4bbd8ab8d3: entity work.a_debus_entity_3c9ba35999
    port map (
      bus_in => reinterpret1_output_port_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out2 => reinterpret2_output_port_net_x0
    );

  addsub1: entity work.addsub_c1b57d7d0a
    port map (
      a => reinterpret2_output_port_net_x0,
      b => reinterpret2_output_port_net_x1,
      ce => ce_1_sg_x165,
      clk => clk_1_sg_x165,
      clr => '0',
      s => addsub1_s_net_x0
    );

  addsub2: entity work.addsub_c1b57d7d0a
    port map (
      a => reinterpret1_output_port_net_x2,
      b => reinterpret1_output_port_net_x0,
      ce => ce_1_sg_x165,
      clk => clk_1_sg_x165,
      clr => '0',
      s => addsub2_s_net_x0
    );

  b_debus_f0b98765c5: entity work.b_debus_entity_f0b98765c5
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  op_bussify_6c938aee01: entity work.op_bussify_entity_6c938aee01
    port map (
      in1 => addsub1_s_net_x0,
      in2 => addsub2_s_net_x0,
      bus_out => concatenate_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_convert/conv1/convert"

entity convert_entity_280b3ebdf8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(20 downto 0); 
    out_x0: out std_logic_vector(17 downto 0)
  );
end convert_entity_280b3ebdf8;

architecture structural of convert_entity_280b3ebdf8 is
  signal adder_s_net_x4: std_logic_vector(17 downto 0);
  signal almost_half_op_net: std_logic_vector(18 downto 0);
  signal bit_y_net: std_logic;
  signal ce_1_sg_x166: std_logic;
  signal clk_1_sg_x166: std_logic;
  signal concat_y_net: std_logic_vector(21 downto 0);
  signal constant_op_net: std_logic;
  signal force1_output_port_net: std_logic_vector(21 downto 0);
  signal force2_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(20 downto 0);
  signal tweak_op_y_net: std_logic;

begin
  ce_1_sg_x166 <= ce_1;
  clk_1_sg_x166 <= clk_1;
  reinterpret4_output_port_net_x0 <= in_x0;
  out_x0 <= adder_s_net_x4;

  adder: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 19,
      a_width => 22,
      b_arith => xlUnsigned,
      b_bin_pt => 19,
      b_width => 19,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 23,
      core_name0 => "addsb_11_0_6c65a885198b42c3",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 23,
      latency => 1,
      overflow => 2,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 18
    )
    port map (
      a => force1_output_port_net,
      b => force2_output_port_net,
      ce => ce_1_sg_x166,
      clk => clk_1_sg_x166,
      clr => '0',
      en => "1",
      s => adder_s_net_x4
    );

  almost_half: entity work.constant_4709ea49b5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => almost_half_op_net
    );

  bit: entity work.xlslice
    generic map (
      new_lsb => 20,
      new_msb => 20,
      x_width => 21,
      y_width => 1
    )
    port map (
      x => reinterpret4_output_port_net_x0,
      y(0) => bit_y_net
    );

  concat: entity work.concat_e6bc20c81b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret_output_port_net,
      in1(0) => tweak_op_y_net,
      y => concat_y_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  force1: entity work.reinterpret_c84451c80b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat_y_net,
      output_port => force1_output_port_net
    );

  force2: entity work.reinterpret_d2180c9169
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => almost_half_op_net,
      output_port => force2_output_port_net
    );

  reinterpret: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret4_output_port_net_x0,
      output_port => reinterpret_output_port_net
    );

  tweak_op: entity work.logical_9d76333483
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => bit_y_net,
      d1(0) => constant_op_net,
      y(0) => tweak_op_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_convert/conv1"

entity conv1_entity_f1cf70b581 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(20 downto 0); 
    dout: out std_logic_vector(17 downto 0)
  );
end conv1_entity_f1cf70b581;

architecture structural of conv1_entity_f1cf70b581 is
  signal adder_s_net_x5: std_logic_vector(17 downto 0);
  signal ce_1_sg_x167: std_logic;
  signal clk_1_sg_x167: std_logic;
  signal reinterpret4_output_port_net_x1: std_logic_vector(20 downto 0);

begin
  ce_1_sg_x167 <= ce_1;
  clk_1_sg_x167 <= clk_1;
  reinterpret4_output_port_net_x1 <= din;
  dout <= adder_s_net_x5;

  convert_280b3ebdf8: entity work.convert_entity_280b3ebdf8
    port map (
      ce_1 => ce_1_sg_x167,
      clk_1 => clk_1_sg_x167,
      in_x0 => reinterpret4_output_port_net_x1,
      out_x0 => adder_s_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_convert/debus"

entity debus_entity_ea042f654e is
  port (
    bus_in: in std_logic_vector(83 downto 0); 
    lsb_out1: out std_logic_vector(20 downto 0); 
    msb_out4: out std_logic_vector(20 downto 0); 
    out2: out std_logic_vector(20 downto 0); 
    out3: out std_logic_vector(20 downto 0)
  );
end debus_entity_ea042f654e;

architecture structural of debus_entity_ea042f654e is
  signal concatenate_y_net_x0: std_logic_vector(83 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic_vector(20 downto 0);
  signal slice1_y_net: std_logic_vector(20 downto 0);
  signal slice2_y_net: std_logic_vector(20 downto 0);
  signal slice3_y_net: std_logic_vector(20 downto 0);
  signal slice4_y_net: std_logic_vector(20 downto 0);

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x2;
  msb_out4 <= reinterpret4_output_port_net_x2;
  out2 <= reinterpret2_output_port_net_x2;
  out3 <= reinterpret3_output_port_net_x2;

  reinterpret1: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x2
    );

  reinterpret2: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x2
    );

  reinterpret3: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x2
    );

  reinterpret4: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 20,
      x_width => 84,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 21,
      new_msb => 41,
      x_width => 84,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 42,
      new_msb => 62,
      x_width => 84,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 63,
      new_msb => 83,
      x_width => 84,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_convert"

entity bus_convert_entity_b950f53ae4 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(83 downto 0); 
    dout: out std_logic_vector(71 downto 0)
  );
end bus_convert_entity_b950f53ae4;

architecture structural of bus_convert_entity_b950f53ae4 is
  signal adder_s_net_x5: std_logic_vector(17 downto 0);
  signal adder_s_net_x6: std_logic_vector(17 downto 0);
  signal adder_s_net_x7: std_logic_vector(17 downto 0);
  signal adder_s_net_x8: std_logic_vector(17 downto 0);
  signal ce_1_sg_x174: std_logic;
  signal clk_1_sg_x174: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic_vector(20 downto 0);

begin
  ce_1_sg_x174 <= ce_1;
  clk_1_sg_x174 <= clk_1;
  concatenate_y_net_x2 <= din;
  dout <= concatenate_y_net_x3;

  bussify_aa58fad317: entity work.bussify_entity_4a7767fc64
    port map (
      in1 => adder_s_net_x5,
      in2 => adder_s_net_x6,
      in3 => adder_s_net_x7,
      in4 => adder_s_net_x8,
      bus_out => concatenate_y_net_x3
    );

  conv1_f1cf70b581: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x174,
      clk_1 => clk_1_sg_x174,
      din => reinterpret4_output_port_net_x2,
      dout => adder_s_net_x5
    );

  conv2_17c51b9c31: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x174,
      clk_1 => clk_1_sg_x174,
      din => reinterpret3_output_port_net_x2,
      dout => adder_s_net_x6
    );

  conv3_a70425aa52: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x174,
      clk_1 => clk_1_sg_x174,
      din => reinterpret2_output_port_net_x2,
      dout => adder_s_net_x7
    );

  conv4_039470be4c: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x174,
      clk_1 => clk_1_sg_x174,
      din => reinterpret1_output_port_net_x2,
      dout => adder_s_net_x8
    );

  debus_ea042f654e: entity work.debus_entity_ea042f654e
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out4 => reinterpret4_output_port_net_x2,
      out2 => reinterpret2_output_port_net_x2,
      out3 => reinterpret3_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_norm0/bussify"

entity bussify_entity_2bf223d543 is
  port (
    in1: in std_logic_vector(20 downto 0); 
    in2: in std_logic_vector(20 downto 0); 
    in3: in std_logic_vector(20 downto 0); 
    in4: in std_logic_vector(20 downto 0); 
    bus_out: out std_logic_vector(83 downto 0)
  );
end bussify_entity_2bf223d543;

architecture structural of bussify_entity_2bf223d543 is
  signal concatenate_y_net_x0: std_logic_vector(83 downto 0);
  signal conv1_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv2_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv3_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv4_dout_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(20 downto 0);

begin
  conv1_dout_net_x0 <= in1;
  conv2_dout_net_x0 <= in2;
  conv3_dout_net_x0 <= in3;
  conv4_dout_net_x0 <= in4;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_356a264444
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv1_dout_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv2_dout_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv3_dout_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv4_dout_net_x0,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_norm0/debus"

entity debus_entity_b562640a6f is
  port (
    bus_in: in std_logic_vector(79 downto 0); 
    lsb_out1: out std_logic_vector(19 downto 0); 
    msb_out4: out std_logic_vector(19 downto 0); 
    out2: out std_logic_vector(19 downto 0); 
    out3: out std_logic_vector(19 downto 0)
  );
end debus_entity_b562640a6f;

architecture structural of debus_entity_b562640a6f is
  signal concat_y_net_x0: std_logic_vector(79 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(19 downto 0);
  signal slice1_y_net: std_logic_vector(19 downto 0);
  signal slice2_y_net: std_logic_vector(19 downto 0);
  signal slice3_y_net: std_logic_vector(19 downto 0);
  signal slice4_y_net: std_logic_vector(19 downto 0);

begin
  concat_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 19,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 20,
      new_msb => 39,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 40,
      new_msb => 59,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 60,
      new_msb => 79,
      x_width => 80,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_norm0"

entity bus_norm0_entity_e7ca085468 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(79 downto 0); 
    dout: out std_logic_vector(83 downto 0)
  );
end bus_norm0_entity_e7ca085468;

architecture structural of bus_norm0_entity_e7ca085468 is
  signal ce_1_sg_x175: std_logic;
  signal clk_1_sg_x175: std_logic;
  signal concat_y_net_x1: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(83 downto 0);
  signal conv1_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv2_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv3_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv4_dout_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(19 downto 0);

begin
  ce_1_sg_x175 <= ce_1;
  clk_1_sg_x175 <= clk_1;
  concat_y_net_x1 <= din;
  dout <= concatenate_y_net_x1;

  bussify_2bf223d543: entity work.bussify_entity_2bf223d543
    port map (
      in1 => conv1_dout_net_x0,
      in2 => conv2_dout_net_x0,
      in3 => conv3_dout_net_x0,
      in4 => conv4_dout_net_x0,
      bus_out => concatenate_y_net_x1
    );

  conv1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x175,
      clk => clk_1_sg_x175,
      clr => '0',
      din => reinterpret4_output_port_net_x0,
      en => "1",
      dout => conv1_dout_net_x0
    );

  conv2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x175,
      clk => clk_1_sg_x175,
      clr => '0',
      din => reinterpret3_output_port_net_x0,
      en => "1",
      dout => conv2_dout_net_x0
    );

  conv3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x175,
      clk => clk_1_sg_x175,
      clr => '0',
      din => reinterpret2_output_port_net_x0,
      en => "1",
      dout => conv3_dout_net_x0
    );

  conv4: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x175,
      clk => clk_1_sg_x175,
      clr => '0',
      din => reinterpret1_output_port_net_x0,
      en => "1",
      dout => conv4_dout_net_x0
    );

  debus_b562640a6f: entity work.debus_entity_b562640a6f
    port map (
      bus_in => concat_y_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out4 => reinterpret4_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_norm1/conv1"

entity conv1_entity_9907950251 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(19 downto 0); 
    out_x0: out std_logic_vector(20 downto 0)
  );
end conv1_entity_9907950251;

architecture structural of conv1_entity_9907950251 is
  signal adder_s_net_x4: std_logic_vector(20 downto 0);
  signal almost_half_op_net: std_logic_vector(18 downto 0);
  signal bit_y_net: std_logic;
  signal ce_1_sg_x176: std_logic;
  signal clk_1_sg_x176: std_logic;
  signal concat_y_net: std_logic_vector(20 downto 0);
  signal constant_op_net: std_logic;
  signal force1_output_port_net: std_logic_vector(20 downto 0);
  signal force2_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(19 downto 0);
  signal tweak_op_y_net: std_logic;

begin
  ce_1_sg_x176 <= ce_1;
  clk_1_sg_x176 <= clk_1;
  reinterpret4_output_port_net_x0 <= in_x0;
  out_x0 <= adder_s_net_x4;

  adder: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 19,
      a_width => 21,
      b_arith => xlUnsigned,
      b_bin_pt => 19,
      b_width => 19,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 22,
      core_name0 => "addsb_11_0_3892e7a2bbe55936",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 22,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 21
    )
    port map (
      a => force1_output_port_net,
      b => force2_output_port_net,
      ce => ce_1_sg_x176,
      clk => clk_1_sg_x176,
      clr => '0',
      en => "1",
      s => adder_s_net_x4
    );

  almost_half: entity work.constant_b366689086
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => almost_half_op_net
    );

  bit: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 20,
      y_width => 1
    )
    port map (
      x => reinterpret4_output_port_net_x0,
      y(0) => bit_y_net
    );

  concat: entity work.concat_c615d93998
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret_output_port_net,
      in1(0) => tweak_op_y_net,
      y => concat_y_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  force1: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat_y_net,
      output_port => force1_output_port_net
    );

  force2: entity work.reinterpret_d2180c9169
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => almost_half_op_net,
      output_port => force2_output_port_net
    );

  reinterpret: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret4_output_port_net_x0,
      output_port => reinterpret_output_port_net
    );

  tweak_op: entity work.logical_b1e9d7c303
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => bit_y_net,
      d1(0) => constant_op_net,
      y(0) => tweak_op_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_norm1"

entity bus_norm1_entity_bd510a87ea is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(79 downto 0); 
    dout: out std_logic_vector(83 downto 0)
  );
end bus_norm1_entity_bd510a87ea;

architecture structural of bus_norm1_entity_bd510a87ea is
  signal adder_s_net_x4: std_logic_vector(20 downto 0);
  signal adder_s_net_x5: std_logic_vector(20 downto 0);
  signal adder_s_net_x6: std_logic_vector(20 downto 0);
  signal adder_s_net_x7: std_logic_vector(20 downto 0);
  signal ce_1_sg_x180: std_logic;
  signal clk_1_sg_x180: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(83 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(19 downto 0);

begin
  ce_1_sg_x180 <= ce_1;
  clk_1_sg_x180 <= clk_1;
  concatenate_y_net_x2 <= din;
  dout <= concatenate_y_net_x3;

  bussify_791ef20471: entity work.bussify_entity_2bf223d543
    port map (
      in1 => adder_s_net_x4,
      in2 => adder_s_net_x5,
      in3 => adder_s_net_x6,
      in4 => adder_s_net_x7,
      bus_out => concatenate_y_net_x3
    );

  conv1_9907950251: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x180,
      clk_1 => clk_1_sg_x180,
      in_x0 => reinterpret4_output_port_net_x1,
      out_x0 => adder_s_net_x4
    );

  conv2_55d805c5ae: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x180,
      clk_1 => clk_1_sg_x180,
      in_x0 => reinterpret3_output_port_net_x1,
      out_x0 => adder_s_net_x5
    );

  conv3_2eade379ff: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x180,
      clk_1 => clk_1_sg_x180,
      in_x0 => reinterpret2_output_port_net_x1,
      out_x0 => adder_s_net_x6
    );

  conv4_43599195f4: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x180,
      clk_1 => clk_1_sg_x180,
      in_x0 => reinterpret1_output_port_net_x1,
      out_x0 => adder_s_net_x7
    );

  debus_4a3d17d954: entity work.debus_entity_ebf3290928
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_scale"

entity bus_scale_entity_25e603273f is
  port (
    din: in std_logic_vector(79 downto 0); 
    dout: out std_logic_vector(79 downto 0)
  );
end bus_scale_entity_25e603273f;

architecture structural of bus_scale_entity_25e603273f is
  signal concat_y_net_x3: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(79 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(19 downto 0);
  signal scale1_op_net_x0: std_logic_vector(19 downto 0);
  signal scale2_op_net_x0: std_logic_vector(19 downto 0);
  signal scale3_op_net_x0: std_logic_vector(19 downto 0);
  signal scale4_op_net_x0: std_logic_vector(19 downto 0);

begin
  concat_y_net_x3 <= din;
  dout <= concatenate_y_net_x4;

  bussify_21228bd925: entity work.bussify_entity_21d703805b
    port map (
      in1 => scale1_op_net_x0,
      in2 => scale2_op_net_x0,
      in3 => scale3_op_net_x0,
      in4 => scale4_op_net_x0,
      bus_out => concatenate_y_net_x4
    );

  debus_e100f46c25: entity work.debus_entity_b562640a6f
    port map (
      bus_in => concat_y_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out4 => reinterpret4_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0
    );

  scale1: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret4_output_port_net_x0,
      op => scale1_op_net_x0
    );

  scale2: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret3_output_port_net_x0,
      op => scale2_op_net_x0
    );

  scale3: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret2_output_port_net_x0,
      op => scale3_op_net_x0
    );

  scale4: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret1_output_port_net_x0,
      op => scale4_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/bus_sub"

entity bus_sub_entity_9893acc382 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(37 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    dout: out std_logic_vector(39 downto 0)
  );
end bus_sub_entity_9893acc382;

architecture structural of bus_sub_entity_9893acc382 is
  signal addsub1_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub2_s_net_x0: std_logic_vector(19 downto 0);
  signal ce_1_sg_x181: std_logic;
  signal clk_1_sg_x181: std_logic;
  signal concatenate_y_net_x4: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(39 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(18 downto 0);

begin
  reinterpret1_output_port_net_x5 <= a;
  concatenate_y_net_x4 <= b;
  ce_1_sg_x181 <= ce_1;
  clk_1_sg_x181 <= clk_1;
  dout <= concatenate_y_net_x5;

  a_debus_66ab320dbb: entity work.a_debus_entity_3c9ba35999
    port map (
      bus_in => reinterpret1_output_port_net_x5,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out2 => reinterpret2_output_port_net_x0
    );

  addsub1: entity work.addsub_5f641f1cd5
    port map (
      a => reinterpret2_output_port_net_x0,
      b => reinterpret2_output_port_net_x1,
      ce => ce_1_sg_x181,
      clk => clk_1_sg_x181,
      clr => '0',
      s => addsub1_s_net_x0
    );

  addsub2: entity work.addsub_5f641f1cd5
    port map (
      a => reinterpret1_output_port_net_x0,
      b => reinterpret1_output_port_net_x1,
      ce => ce_1_sg_x181,
      clk => clk_1_sg_x181,
      clr => '0',
      s => addsub2_s_net_x0
    );

  b_debus_6d6002b6e3: entity work.b_debus_entity_f0b98765c5
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  op_bussify_d14e7128fe: entity work.op_bussify_entity_6c938aee01
    port map (
      in1 => addsub1_s_net_x0,
      in2 => addsub2_s_net_x0,
      bus_out => concatenate_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/mux/d_bussify"

entity d_bussify_entity_2b21b9ca6b is
  port (
    in1: in std_logic_vector(20 downto 0); 
    in2: in std_logic_vector(20 downto 0); 
    in3: in std_logic_vector(20 downto 0); 
    in4: in std_logic_vector(20 downto 0); 
    bus_out: out std_logic_vector(83 downto 0)
  );
end d_bussify_entity_2b21b9ca6b;

architecture structural of d_bussify_entity_2b21b9ca6b is
  signal concatenate_y_net_x3: std_logic_vector(83 downto 0);
  signal mux0_y_net_x0: std_logic_vector(20 downto 0);
  signal mux1_y_net_x0: std_logic_vector(20 downto 0);
  signal mux2_y_net_x0: std_logic_vector(20 downto 0);
  signal mux3_y_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(20 downto 0);

begin
  mux0_y_net_x0 <= in1;
  mux1_y_net_x0 <= in2;
  mux2_y_net_x0 <= in3;
  mux3_y_net_x0 <= in4;
  bus_out <= concatenate_y_net_x3;

  concatenate: entity work.concat_356a264444
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x3
    );

  reinterpret1: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux0_y_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux1_y_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux2_y_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux3_y_net_x0,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/mux/expand0"

entity expand0_entity_abd9d12112 is
  port (
    bus_in: in std_logic_vector(83 downto 0); 
    lsb_out1: out std_logic_vector(20 downto 0); 
    msb_out4: out std_logic_vector(20 downto 0); 
    out2: out std_logic_vector(20 downto 0); 
    out3: out std_logic_vector(20 downto 0)
  );
end expand0_entity_abd9d12112;

architecture structural of expand0_entity_abd9d12112 is
  signal concatenate_y_net_x2: std_logic_vector(83 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(20 downto 0);
  signal slice1_y_net: std_logic_vector(20 downto 0);
  signal slice2_y_net: std_logic_vector(20 downto 0);
  signal slice3_y_net: std_logic_vector(20 downto 0);
  signal slice4_y_net: std_logic_vector(20 downto 0);

begin
  concatenate_y_net_x2 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 20,
      x_width => 84,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 21,
      new_msb => 41,
      x_width => 84,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 42,
      new_msb => 62,
      x_width => 84,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 63,
      new_msb => 83,
      x_width => 84,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/mux"

entity mux_entity_83804557c8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d0: in std_logic_vector(83 downto 0); 
    d1: in std_logic_vector(83 downto 0); 
    sel: in std_logic_vector(3 downto 0); 
    out_x0: out std_logic_vector(83 downto 0)
  );
end mux_entity_83804557c8;

architecture structural of mux_entity_83804557c8 is
  signal ce_1_sg_x182: std_logic;
  signal clk_1_sg_x182: std_logic;
  signal concatenate_y_net_x5: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(83 downto 0);
  signal mux0_y_net_x0: std_logic_vector(20 downto 0);
  signal mux1_y_net_x0: std_logic_vector(20 downto 0);
  signal mux2_y_net_x0: std_logic_vector(20 downto 0);
  signal mux3_y_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic;
  signal reinterpret2_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic;
  signal reinterpret3_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net_x2: std_logic;
  signal reinterpret4_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic;

begin
  ce_1_sg_x182 <= ce_1;
  clk_1_sg_x182 <= clk_1;
  concatenate_y_net_x5 <= d0;
  concatenate_y_net_x6 <= d1;
  concatenate_y_net_x7 <= sel;
  out_x0 <= concatenate_y_net_x8;

  d_bussify_2b21b9ca6b: entity work.d_bussify_entity_2b21b9ca6b
    port map (
      in1 => mux0_y_net_x0,
      in2 => mux1_y_net_x0,
      in3 => mux2_y_net_x0,
      in4 => mux3_y_net_x0,
      bus_out => concatenate_y_net_x8
    );

  expand0_abd9d12112: entity work.expand0_entity_abd9d12112
    port map (
      bus_in => concatenate_y_net_x5,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out4 => reinterpret4_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0
    );

  expand1_45c3b75183: entity work.expand0_entity_abd9d12112
    port map (
      bus_in => concatenate_y_net_x6,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

  mux0: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x182,
      clk => clk_1_sg_x182,
      clr => '0',
      d0 => reinterpret4_output_port_net_x0,
      d1 => reinterpret4_output_port_net_x1,
      sel(0) => reinterpret4_output_port_net_x2,
      y => mux0_y_net_x0
    );

  mux1: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x182,
      clk => clk_1_sg_x182,
      clr => '0',
      d0 => reinterpret3_output_port_net_x0,
      d1 => reinterpret3_output_port_net_x1,
      sel(0) => reinterpret3_output_port_net_x2,
      y => mux1_y_net_x0
    );

  mux2: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x182,
      clk => clk_1_sg_x182,
      clr => '0',
      d0 => reinterpret2_output_port_net_x0,
      d1 => reinterpret2_output_port_net_x1,
      sel(0) => reinterpret2_output_port_net_x2,
      y => mux2_y_net_x0
    );

  mux3: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x182,
      clk => clk_1_sg_x182,
      clr => '0',
      d0 => reinterpret1_output_port_net_x0,
      d1 => reinterpret1_output_port_net_x1,
      sel(0) => reinterpret1_output_port_net_x2,
      y => mux3_y_net_x0
    );

  sel_expand_5aabe67eb3: entity work.sel_expand_entity_80d467162d
    port map (
      bus_in => concatenate_y_net_x7,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out4 => reinterpret4_output_port_net_x2,
      out2 => reinterpret2_output_port_net_x2,
      out3 => reinterpret3_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_convert/conv1"

entity conv1_entity_4123be0548 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(36 downto 0); 
    out_x0: out std_logic_vector(18 downto 0)
  );
end conv1_entity_4123be0548;

architecture structural of conv1_entity_4123be0548 is
  signal adder_s_net_x2: std_logic_vector(18 downto 0);
  signal almost_half_op_net: std_logic_vector(34 downto 0);
  signal bit_y_net: std_logic;
  signal ce_1_sg_x184: std_logic;
  signal clk_1_sg_x184: std_logic;
  signal concat_y_net: std_logic_vector(37 downto 0);
  signal constant_op_net: std_logic;
  signal force1_output_port_net: std_logic_vector(37 downto 0);
  signal force2_output_port_net: std_logic_vector(34 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(36 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(36 downto 0);
  signal tweak_op_y_net: std_logic;

begin
  ce_1_sg_x184 <= ce_1;
  clk_1_sg_x184 <= clk_1;
  reinterpret2_output_port_net_x0 <= in_x0;
  out_x0 <= adder_s_net_x2;

  adder: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 35,
      a_width => 38,
      b_arith => xlUnsigned,
      b_bin_pt => 35,
      b_width => 35,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 39,
      core_name0 => "addsb_11_0_259024b6977697b1",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 39,
      latency => 1,
      overflow => 2,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 19
    )
    port map (
      a => force1_output_port_net,
      b => force2_output_port_net,
      ce => ce_1_sg_x184,
      clk => clk_1_sg_x184,
      clr => '0',
      en => "1",
      s => adder_s_net_x2
    );

  almost_half: entity work.constant_2da6af93c2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => almost_half_op_net
    );

  bit: entity work.xlslice
    generic map (
      new_lsb => 36,
      new_msb => 36,
      x_width => 37,
      y_width => 1
    )
    port map (
      x => reinterpret2_output_port_net_x0,
      y(0) => bit_y_net
    );

  concat: entity work.concat_83820b2faf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret_output_port_net,
      in1(0) => tweak_op_y_net,
      y => concat_y_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  force1: entity work.reinterpret_620dd01637
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat_y_net,
      output_port => force1_output_port_net
    );

  force2: entity work.reinterpret_ec14c62a89
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => almost_half_op_net,
      output_port => force2_output_port_net
    );

  reinterpret: entity work.reinterpret_db4c53ade5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret2_output_port_net_x0,
      output_port => reinterpret_output_port_net
    );

  tweak_op: entity work.logical_9d76333483
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => bit_y_net,
      d1(0) => constant_op_net,
      y(0) => tweak_op_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_convert/debus"

entity debus_entity_3a0d4b86b8 is
  port (
    bus_in: in std_logic_vector(73 downto 0); 
    lsb_out1: out std_logic_vector(36 downto 0); 
    msb_out2: out std_logic_vector(36 downto 0)
  );
end debus_entity_3a0d4b86b8;

architecture structural of debus_entity_3a0d4b86b8 is
  signal reinterpret1_output_port_net_x1: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(36 downto 0);
  signal slice1_y_net: std_logic_vector(36 downto 0);
  signal slice2_y_net: std_logic_vector(36 downto 0);

begin
  reinterpret1_output_port_net_x1 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x2;
  msb_out2 <= reinterpret2_output_port_net_x1;

  reinterpret1: entity work.reinterpret_5b4829fb41
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x2
    );

  reinterpret2: entity work.reinterpret_5b4829fb41
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 36,
      x_width => 74,
      y_width => 37
    )
    port map (
      x => reinterpret1_output_port_net_x1,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 37,
      new_msb => 73,
      x_width => 74,
      y_width => 37
    )
    port map (
      x => reinterpret1_output_port_net_x1,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_convert"

entity bus_convert_entity_8995348ed7 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(73 downto 0); 
    misci: in std_logic_vector(36 downto 0); 
    dout: out std_logic_vector(37 downto 0); 
    misco: out std_logic_vector(36 downto 0)
  );
end bus_convert_entity_8995348ed7;

architecture structural of bus_convert_entity_8995348ed7 is
  signal adder_s_net_x2: std_logic_vector(18 downto 0);
  signal adder_s_net_x3: std_logic_vector(18 downto 0);
  signal ce_1_sg_x186: std_logic;
  signal clk_1_sg_x186: std_logic;
  signal concatenate_y_net_x6: std_logic_vector(37 downto 0);
  signal dmisc_q_net_x1: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(36 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(36 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(73 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(36 downto 0);

begin
  ce_1_sg_x186 <= ce_1;
  clk_1_sg_x186 <= clk_1;
  reinterpret1_output_port_net_x3 <= din;
  dmisc_q_net_x1 <= misci;
  dout <= concatenate_y_net_x6;
  misco <= dmisc_q_net_x2;

  bussify_fab2756853: entity work.op_bussify_entity_86a680cc9c
    port map (
      in1 => adder_s_net_x2,
      in2 => adder_s_net_x3,
      bus_out => concatenate_y_net_x6
    );

  conv1_4123be0548: entity work.conv1_entity_4123be0548
    port map (
      ce_1 => ce_1_sg_x186,
      clk_1 => clk_1_sg_x186,
      in_x0 => reinterpret2_output_port_net_x1,
      out_x0 => adder_s_net_x2
    );

  conv2_86c79ef881: entity work.conv1_entity_4123be0548
    port map (
      ce_1 => ce_1_sg_x186,
      clk_1 => clk_1_sg_x186,
      in_x0 => reinterpret1_output_port_net_x2,
      out_x0 => adder_s_net_x3
    );

  debus_3a0d4b86b8: entity work.debus_entity_3a0d4b86b8
    port map (
      bus_in => reinterpret1_output_port_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  dmisc: entity work.delay_cdda6c7e6c
    port map (
      ce => ce_1_sg_x186,
      clk => clk_1_sg_x186,
      clr => '0',
      d => dmisc_q_net_x1,
      q => dmisc_q_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_create"

entity bus_create_entity_bca4476356 is
  port (
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic; 
    in3: in std_logic_vector(35 downto 0); 
    bus_out: out std_logic_vector(72 downto 0)
  );
end bus_create_entity_bca4476356;

architecture structural of bus_create_entity_bca4476356 is
  signal concatenate_y_net_x0: std_logic_vector(72 downto 0);
  signal dmux0_q_net_x0: std_logic_vector(35 downto 0);
  signal mux_y_net_x0: std_logic;
  signal reinterpret1_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net: std_logic;
  signal reinterpret3_output_port_net: std_logic_vector(35 downto 0);

begin
  dmux0_q_net_x0 <= in1;
  mux_y_net_x0 <= in2;
  reinterpret1_output_port_net_x1 <= in3;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_b28df1ab2e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1(0) => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => dmux0_q_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => mux_y_net_x0,
      output_port(0) => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret1_output_port_net_x1,
      output_port => reinterpret3_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_expand"

entity bus_expand_entity_0c73098dab is
  port (
    bus_in: in std_logic_vector(72 downto 0); 
    lsb_out1: out std_logic_vector(36 downto 0); 
    msb_out2: out std_logic_vector(35 downto 0)
  );
end bus_expand_entity_0c73098dab;

architecture structural of bus_expand_entity_0c73098dab is
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(35 downto 0);
  signal slice1_y_net: std_logic_vector(36 downto 0);
  signal slice2_y_net: std_logic_vector(35 downto 0);

begin
  delay1_q_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out2 <= reinterpret2_output_port_net_x0;

  reinterpret1: entity work.reinterpret_892b735f0d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 36,
      x_width => 73,
      y_width => 37
    )
    port map (
      x => delay1_q_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 37,
      new_msb => 72,
      x_width => 73,
      y_width => 36
    )
    port map (
      x => delay1_q_net_x0,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_expand1"

entity bus_expand1_entity_94af2caf5e is
  port (
    bus_in: in std_logic_vector(36 downto 0); 
    lsb_out1: out std_logic_vector(35 downto 0); 
    msb_out2: out std_logic
  );
end bus_expand1_entity_94af2caf5e;

architecture structural of bus_expand1_entity_94af2caf5e is
  signal dmisc_q_net_x3: std_logic_vector(36 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);
  signal slice1_y_net: std_logic_vector(35 downto 0);
  signal slice2_y_net_x0: std_logic;

begin
  dmisc_q_net_x3 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x6;
  msb_out2 <= slice2_y_net_x0;

  reinterpret1: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x6
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 35,
      x_width => 37,
      y_width => 36
    )
    port map (
      x => dmisc_q_net_x3,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 36,
      new_msb => 36,
      x_width => 37,
      y_width => 1
    )
    port map (
      x => dmisc_q_net_x3,
      y(0) => slice2_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_mult/a*b_bussify"

entity a_b_bussify_entity_49910e5ce2 is
  port (
    in1: in std_logic_vector(73 downto 0); 
    bus_out: out std_logic_vector(73 downto 0)
  );
end a_b_bussify_entity_49910e5ce2;

architecture structural of a_b_bussify_entity_49910e5ce2 is
  signal concat_y_net_x0: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(73 downto 0);

begin
  concat_y_net_x0 <= in1;
  bus_out <= reinterpret1_output_port_net_x4;

  reinterpret1: entity work.reinterpret_efdf1c3890
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat_y_net_x0,
      output_port => reinterpret1_output_port_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_mult/mult1/a_expand"

entity a_expand_entity_c51fa07742 is
  port (
    bus_in: in std_logic_vector(71 downto 0); 
    lsb_out1: out std_logic_vector(17 downto 0); 
    msb_out4: out std_logic_vector(17 downto 0); 
    out2: out std_logic_vector(17 downto 0); 
    out3: out std_logic_vector(17 downto 0)
  );
end a_expand_entity_c51fa07742;

architecture structural of a_expand_entity_c51fa07742 is
  signal concatenate_y_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(17 downto 0);
  signal slice1_y_net: std_logic_vector(17 downto 0);
  signal slice2_y_net: std_logic_vector(17 downto 0);
  signal slice3_y_net: std_logic_vector(17 downto 0);
  signal slice4_y_net: std_logic_vector(17 downto 0);

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 35,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 36,
      new_msb => 53,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 54,
      new_msb => 71,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_mult/mult1/a_replicate/bussify"

entity bussify_entity_400b078c8a is
  port (
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    bus_out: out std_logic_vector(71 downto 0)
  );
end bussify_entity_400b078c8a;

architecture structural of bussify_entity_400b078c8a is
  signal concatenate_y_net_x1: std_logic_vector(71 downto 0);
  signal din0_0_q_net_x0: std_logic_vector(35 downto 0);
  signal din0_1_q_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(35 downto 0);

begin
  din0_0_q_net_x0 <= in1;
  din0_1_q_net_x0 <= in2;
  bus_out <= concatenate_y_net_x1;

  concatenate: entity work.concat_c3ccc04d1a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      y => concatenate_y_net_x1
    );

  reinterpret1: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din0_0_q_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din0_1_q_net_x0,
      output_port => reinterpret2_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_mult/mult1/a_replicate"

entity a_replicate_entity_fe36abb22a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(35 downto 0); 
    out_x0: out std_logic_vector(71 downto 0)
  );
end a_replicate_entity_fe36abb22a;

architecture structural of a_replicate_entity_fe36abb22a is
  signal ce_1_sg_x187: std_logic;
  signal clk_1_sg_x187: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(71 downto 0);
  signal din0_0_q_net_x0: std_logic_vector(35 downto 0);
  signal din0_1_q_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x187 <= ce_1;
  clk_1_sg_x187 <= clk_1;
  reinterpret1_output_port_net_x3 <= in_x0;
  out_x0 <= concatenate_y_net_x2;

  bussify_400b078c8a: entity work.bussify_entity_400b078c8a
    port map (
      in1 => din0_0_q_net_x0,
      in2 => din0_1_q_net_x0,
      bus_out => concatenate_y_net_x2
    );

  din0_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 36
    )
    port map (
      ce => ce_1_sg_x187,
      clk => clk_1_sg_x187,
      d => reinterpret1_output_port_net_x3,
      en => '1',
      rst => '1',
      q => din0_0_q_net_x0
    );

  din0_1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 36
    )
    port map (
      ce => ce_1_sg_x187,
      clk => clk_1_sg_x187,
      d => reinterpret1_output_port_net_x3,
      en => '1',
      rst => '1',
      q => din0_1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_mult/mult1/ri_to_c"

entity ri_to_c_entity_40be2e33cb is
  port (
    im: in std_logic_vector(36 downto 0); 
    re: in std_logic_vector(36 downto 0); 
    c: out std_logic_vector(73 downto 0)
  );
end ri_to_c_entity_40be2e33cb;

architecture structural of ri_to_c_entity_40be2e33cb is
  signal concat_y_net_x1: std_logic_vector(73 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(36 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(36 downto 0);
  signal force_im_output_port_net: std_logic_vector(36 downto 0);
  signal force_re_output_port_net: std_logic_vector(36 downto 0);

begin
  convert_im_dout_net_x0 <= im;
  convert_re_dout_net_x0 <= re;
  c <= concat_y_net_x1;

  concat: entity work.concat_56d57d2c92
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x1
    );

  force_im: entity work.reinterpret_db4c53ade5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_im_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_db4c53ade5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_re_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_mult/mult1"

entity mult1_entity_c19da6e8af is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    ab: out std_logic_vector(73 downto 0)
  );
end mult1_entity_c19da6e8af;

architecture structural of mult1_entity_c19da6e8af is
  signal addsub_im_s_net: std_logic_vector(36 downto 0);
  signal addsub_re_s_net: std_logic_vector(36 downto 0);
  signal ce_1_sg_x189: std_logic;
  signal clk_1_sg_x189: std_logic;
  signal concat_y_net_x2: std_logic_vector(73 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(71 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(36 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(36 downto 0);
  signal imim_p_net: std_logic_vector(35 downto 0);
  signal imre_p_net: std_logic_vector(35 downto 0);
  signal reim_p_net: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(17 downto 0);
  signal rere_p_net: std_logic_vector(35 downto 0);

begin
  reinterpret1_output_port_net_x6 <= a;
  reinterpret1_output_port_net_x7 <= b;
  ce_1_sg_x189 <= ce_1;
  clk_1_sg_x189 <= clk_1;
  ab <= concat_y_net_x2;

  a_expand_c51fa07742: entity work.a_expand_entity_c51fa07742
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out4 => reinterpret4_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0
    );

  a_replicate_fe36abb22a: entity work.a_replicate_entity_fe36abb22a
    port map (
      ce_1 => ce_1_sg_x189,
      clk_1 => clk_1_sg_x189,
      in_x0 => reinterpret1_output_port_net_x6,
      out_x0 => concatenate_y_net_x2
    );

  addsub_im: entity work.addsub_44b396c607
    port map (
      a => imre_p_net,
      b => reim_p_net,
      ce => ce_1_sg_x189,
      clk => clk_1_sg_x189,
      clr => '0',
      s => addsub_im_s_net
    );

  addsub_re: entity work.addsub_74747a130a
    port map (
      a => rere_p_net,
      b => imim_p_net,
      ce => ce_1_sg_x189,
      clk => clk_1_sg_x189,
      clr => '0',
      s => addsub_re_s_net
    );

  b_expand_19efa3f951: entity work.a_expand_entity_c51fa07742
    port map (
      bus_in => concatenate_y_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x5,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

  b_replicate_acd3d066db: entity work.a_replicate_entity_fe36abb22a
    port map (
      ce_1 => ce_1_sg_x189,
      clk_1 => clk_1_sg_x189,
      in_x0 => reinterpret1_output_port_net_x7,
      out_x0 => concatenate_y_net_x3
    );

  convert_im: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 34,
      din_width => 37,
      dout_arith => 2,
      dout_bin_pt => 34,
      dout_width => 37,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x189,
      clk => clk_1_sg_x189,
      clr => '0',
      din => addsub_im_s_net,
      en => "1",
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 34,
      din_width => 37,
      dout_arith => 2,
      dout_bin_pt => 34,
      dout_width => 37,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x189,
      clk => clk_1_sg_x189,
      clr => '0',
      din => addsub_re_s_net,
      en => "1",
      dout => convert_re_dout_net_x0
    );

  imim: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret3_output_port_net_x0,
      b => reinterpret3_output_port_net_x1,
      ce => ce_1_sg_x189,
      clk => clk_1_sg_x189,
      clr => '0',
      p => imim_p_net
    );

  imre: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret1_output_port_net_x0,
      b => reinterpret2_output_port_net_x1,
      ce => ce_1_sg_x189,
      clk => clk_1_sg_x189,
      clr => '0',
      p => imre_p_net
    );

  reim: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret2_output_port_net_x0,
      b => reinterpret1_output_port_net_x5,
      ce => ce_1_sg_x189,
      clk => clk_1_sg_x189,
      clr => '0',
      p => reim_p_net
    );

  rere: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret4_output_port_net_x0,
      b => reinterpret4_output_port_net_x1,
      ce => ce_1_sg_x189,
      clk => clk_1_sg_x189,
      clr => '0',
      p => rere_p_net
    );

  ri_to_c_40be2e33cb: entity work.ri_to_c_entity_40be2e33cb
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_mult/repa"

entity repa_entity_bd320d9b64 is
  port (
    in_x0: in std_logic_vector(35 downto 0); 
    out_x0: out std_logic_vector(35 downto 0)
  );
end repa_entity_bd320d9b64;

architecture structural of repa_entity_bd320d9b64 is
  signal concat_y_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);

begin
  concat_y_net_x1 <= in_x0;
  out_x0 <= reinterpret1_output_port_net_x3;

  bussify_78f45cc197: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => concat_y_net_x1,
      bus_out => reinterpret1_output_port_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/bus_mult"

entity bus_mult_entity_516ba8171e is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(36 downto 0); 
    a_b: out std_logic_vector(73 downto 0); 
    misco: out std_logic_vector(36 downto 0)
  );
end bus_mult_entity_516ba8171e;

architecture structural of bus_mult_entity_516ba8171e is
  signal ce_1_sg_x190: std_logic;
  signal clk_1_sg_x190: std_logic;
  signal concat_y_net_x2: std_logic_vector(73 downto 0);
  signal concat_y_net_x3: std_logic_vector(35 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(36 downto 0);
  signal reinterpret1_output_port_net_x10: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x8: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);

begin
  concat_y_net_x3 <= a;
  reinterpret2_output_port_net_x3 <= b;
  ce_1_sg_x190 <= ce_1;
  clk_1_sg_x190 <= clk_1;
  reinterpret1_output_port_net_x9 <= misci;
  a_b <= reinterpret1_output_port_net_x10;
  misco <= dmisc_q_net_x2;

  a_b_bussify_49910e5ce2: entity work.a_b_bussify_entity_49910e5ce2
    port map (
      in1 => concat_y_net_x2,
      bus_out => reinterpret1_output_port_net_x10
    );

  a_debus_31614ea202: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret1_output_port_net_x3,
      msb_lsb_out1 => reinterpret1_output_port_net_x6
    );

  b_debus_164c083617: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret1_output_port_net_x8,
      msb_lsb_out1 => reinterpret1_output_port_net_x7
    );

  dmisc: entity work.delay_c24bb045ac
    port map (
      ce => ce_1_sg_x190,
      clk => clk_1_sg_x190,
      clr => '0',
      d => reinterpret1_output_port_net_x9,
      q => dmisc_q_net_x2
    );

  mult1_c19da6e8af: entity work.mult1_entity_c19da6e8af
    port map (
      a => reinterpret1_output_port_net_x6,
      b => reinterpret1_output_port_net_x7,
      ce_1 => ce_1_sg_x190,
      clk_1 => clk_1_sg_x190,
      ab => concat_y_net_x2
    );

  repa_bd320d9b64: entity work.repa_entity_bd320d9b64
    port map (
      in_x0 => concat_y_net_x3,
      out_x0 => reinterpret1_output_port_net_x3
    );

  repb_39aaae31b3: entity work.repa_entity_bd320d9b64
    port map (
      in_x0 => reinterpret2_output_port_net_x3,
      out_x0 => reinterpret1_output_port_net_x8
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/coeff_gen/bit_reverse"

entity bit_reverse_entity_83075a30ba is
  port (
    in_x0: in std_logic_vector(1 downto 0); 
    out_x0: out std_logic_vector(1 downto 0)
  );
end bit_reverse_entity_83075a30ba;

architecture structural of bit_reverse_entity_83075a30ba is
  signal bit0_y_net: std_logic;
  signal bit1_y_net: std_logic;
  signal concat_y_net_x0: std_logic_vector(1 downto 0);
  signal slice_y_net_x0: std_logic_vector(1 downto 0);

begin
  slice_y_net_x0 <= in_x0;
  out_x0 <= concat_y_net_x0;

  bit0: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit0_y_net
    );

  bit1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit1_y_net
    );

  concat: entity work.concat_e6f5ee726b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => bit0_y_net,
      in1(0) => bit1_y_net,
      y => concat_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/coeff_gen/cosin/add_convert0"

entity add_convert0_entity_d2c4c6e53f is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    theta: in std_logic_vector(1 downto 0); 
    add: out std_logic_vector(1 downto 0); 
    negate: out std_logic
  );
end add_convert0_entity_d2c4c6e53f;

architecture structural of add_convert0_entity_d2c4c6e53f is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x0: std_logic_vector(1 downto 0);
  signal ce_1_sg_x191: std_logic;
  signal clk_1_sg_x191: std_logic;
  signal concat_y_net: std_logic_vector(2 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(1 downto 0);
  signal delay13_q_net: std_logic_vector(1 downto 0);
  signal delay14_q_net: std_logic_vector(1 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(2 downto 0);
  signal invert_y_net: std_logic;
  signal lookup_y_net: std_logic;
  signal new_add_y_net: std_logic_vector(1 downto 0);
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x191 <= ce_1;
  clk_1_sg_x191 <= clk_1;
  assert_dout_net_x0 <= theta;
  add <= convert2_dout_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x191,
      clk => clk_1_sg_x191,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  concat: entity work.concat_6160d7387c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => addsub5_s_net,
      in1(0) => lookup_y_net,
      y => concat_y_net
    );

  convert2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 2,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 2,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x191,
      clk => clk_1_sg_x191,
      clr => '0',
      din => delay13_q_net,
      en => "1",
      dout => convert2_dout_net_x0
    );

  delay13: entity work.delay_fcebea29b9
    port map (
      ce => ce_1_sg_x191,
      clk => clk_1_sg_x191,
      clr => '0',
      d => delay14_q_net,
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 2
    )
    port map (
      ce => ce_1_sg_x191,
      clk => clk_1_sg_x191,
      d => new_add_y_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x191,
      clk => clk_1_sg_x191,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_4a9a9a25a3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x0,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  lookup: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 3,
      y_width => 1
    )
    port map (
      x => fluff_y_net,
      y(0) => lookup_y_net
    );

  new_add: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 1,
      x_width => 3,
      y_width => 2
    )
    port map (
      x => concat_y_net,
      y => new_add_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 2,
      x_width => 3,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/coeff_gen/cosin/add_convert1"

entity add_convert1_entity_92ef968a6f is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(1 downto 0); 
    add: out std_logic_vector(1 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    negate: out std_logic
  );
end add_convert1_entity_92ef968a6f;

architecture structural of add_convert1_entity_92ef968a6f is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x1: std_logic_vector(1 downto 0);
  signal ce_1_sg_x192: std_logic;
  signal clk_1_sg_x192: std_logic;
  signal concat_y_net: std_logic_vector(2 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(72 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(1 downto 0);
  signal delay13_q_net: std_logic_vector(1 downto 0);
  signal delay14_q_net: std_logic_vector(1 downto 0);
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(2 downto 0);
  signal invert_y_net: std_logic;
  signal lookup_y_net: std_logic;
  signal new_add_y_net: std_logic_vector(1 downto 0);
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x192 <= ce_1;
  clk_1_sg_x192 <= clk_1;
  concatenate_y_net_x1 <= misci;
  assert_dout_net_x1 <= theta;
  add <= convert2_dout_net_x0;
  misco <= delay1_q_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x192,
      clk => clk_1_sg_x192,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  concat: entity work.concat_6160d7387c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => addsub5_s_net,
      in1(0) => lookup_y_net,
      y => concat_y_net
    );

  convert2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 2,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 2,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x192,
      clk => clk_1_sg_x192,
      clr => '0',
      din => delay13_q_net,
      en => "1",
      dout => convert2_dout_net_x0
    );

  delay1: entity work.delay_4e967fa4b7
    port map (
      ce => ce_1_sg_x192,
      clk => clk_1_sg_x192,
      clr => '0',
      d => concatenate_y_net_x1,
      q => delay1_q_net_x0
    );

  delay13: entity work.delay_fcebea29b9
    port map (
      ce => ce_1_sg_x192,
      clk => clk_1_sg_x192,
      clr => '0',
      d => delay14_q_net,
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 2
    )
    port map (
      ce => ce_1_sg_x192,
      clk => clk_1_sg_x192,
      d => new_add_y_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x192,
      clk => clk_1_sg_x192,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_a7e2bb9e12
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_4a9a9a25a3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x1,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  lookup: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 3,
      y_width => 1
    )
    port map (
      x => fluff_y_net,
      y(0) => lookup_y_net
    );

  new_add: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 1,
      x_width => 3,
      y_width => 2
    )
    port map (
      x => concat_y_net,
      y => new_add_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 2,
      x_width => 3,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/coeff_gen/cosin/invert0"

entity invert0_entity_b1ffbb1c3b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(17 downto 0); 
    negate_x0: in std_logic; 
    out_x0: out std_logic_vector(17 downto 0)
  );
end invert0_entity_b1ffbb1c3b;

architecture structural of invert0_entity_b1ffbb1c3b is
  signal ce_1_sg_x193: std_logic;
  signal clk_1_sg_x193: std_logic;
  signal delay10_q_net_x0: std_logic;
  signal delay20_q_net: std_logic_vector(17 downto 0);
  signal delay21_q_net: std_logic;
  signal lookup_douta_net_x0: std_logic_vector(17 downto 0);
  signal mux_y_net_x0: std_logic_vector(17 downto 0);
  signal negate_op_net: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x193 <= ce_1;
  clk_1_sg_x193 <= clk_1;
  lookup_douta_net_x0 <= in_x0;
  delay10_q_net_x0 <= negate_x0;
  out_x0 <= mux_y_net_x0;

  delay20: entity work.delay_cbdfa55dc3
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      d => lookup_douta_net_x0,
      q => delay20_q_net
    );

  delay21: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      d(0) => delay10_q_net_x0,
      q(0) => delay21_q_net
    );

  mux: entity work.mux_1896e7760c
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      d0 => delay20_q_net,
      d1 => negate_op_net,
      sel(0) => delay21_q_net,
      y => mux_y_net_x0
    );

  negate: entity work.negate_a9c5a8edc5
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      ip => lookup_douta_net_x0,
      op => negate_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/coeff_gen/cosin/invert1"

entity invert1_entity_af1af9b3de is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(17 downto 0); 
    misci: in std_logic_vector(72 downto 0); 
    negate_x0: in std_logic; 
    misco: out std_logic_vector(72 downto 0); 
    out_x0: out std_logic_vector(17 downto 0)
  );
end invert1_entity_af1af9b3de;

architecture structural of invert1_entity_af1af9b3de is
  signal ce_1_sg_x194: std_logic;
  signal clk_1_sg_x194: std_logic;
  signal delay1_q_net_x1: std_logic_vector(72 downto 0);
  signal delay20_q_net: std_logic_vector(17 downto 0);
  signal delay21_q_net: std_logic;
  signal delay8_q_net_x0: std_logic;
  signal delay_q_net_x0: std_logic_vector(72 downto 0);
  signal lookup_doutb_net_x0: std_logic_vector(17 downto 0);
  signal mux_y_net_x0: std_logic_vector(17 downto 0);
  signal negate_op_net: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x194 <= ce_1;
  clk_1_sg_x194 <= clk_1;
  lookup_doutb_net_x0 <= in_x0;
  delay_q_net_x0 <= misci;
  delay8_q_net_x0 <= negate_x0;
  misco <= delay1_q_net_x1;
  out_x0 <= mux_y_net_x0;

  delay1: entity work.delay_4e967fa4b7
    port map (
      ce => ce_1_sg_x194,
      clk => clk_1_sg_x194,
      clr => '0',
      d => delay_q_net_x0,
      q => delay1_q_net_x1
    );

  delay20: entity work.delay_cbdfa55dc3
    port map (
      ce => ce_1_sg_x194,
      clk => clk_1_sg_x194,
      clr => '0',
      d => lookup_doutb_net_x0,
      q => delay20_q_net
    );

  delay21: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x194,
      clk => clk_1_sg_x194,
      clr => '0',
      d(0) => delay8_q_net_x0,
      q(0) => delay21_q_net
    );

  mux: entity work.mux_1896e7760c
    port map (
      ce => ce_1_sg_x194,
      clk => clk_1_sg_x194,
      clr => '0',
      d0 => delay20_q_net,
      d1 => negate_op_net,
      sel(0) => delay21_q_net,
      y => mux_y_net_x0
    );

  negate: entity work.negate_a9c5a8edc5
    port map (
      ce => ce_1_sg_x194,
      clk => clk_1_sg_x194,
      clr => '0',
      ip => lookup_doutb_net_x0,
      op => negate_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/coeff_gen/cosin"

entity cosin_entity_80132246cb is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(1 downto 0); 
    cos: out std_logic_vector(17 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    sin: out std_logic_vector(17 downto 0)
  );
end cosin_entity_80132246cb;

architecture structural of cosin_entity_80132246cb is
  signal assert_dout_net_x1: std_logic_vector(1 downto 0);
  signal ce_1_sg_x195: std_logic;
  signal clk_1_sg_x195: std_logic;
  signal concat_y_net_x1: std_logic_vector(1 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(72 downto 0);
  signal constant2_op_net: std_logic;
  signal constant_op_net: std_logic_vector(17 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(1 downto 0);
  signal convert2_dout_net_x1: std_logic_vector(1 downto 0);
  signal delay10_q_net_x0: std_logic;
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay1_q_net_x2: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal delay2_q_net_x1: std_logic;
  signal delay8_q_net_x0: std_logic;
  signal delay_q_net_x0: std_logic_vector(72 downto 0);
  signal lookup_douta_net_x0: std_logic_vector(17 downto 0);
  signal lookup_doutb_net_x0: std_logic_vector(17 downto 0);
  signal mux_y_net_x2: std_logic_vector(17 downto 0);
  signal mux_y_net_x3: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x195 <= ce_1;
  clk_1_sg_x195 <= clk_1;
  concatenate_y_net_x2 <= misci;
  concat_y_net_x1 <= theta;
  cos <= mux_y_net_x2;
  misco <= delay1_q_net_x2;
  sin <= mux_y_net_x3;

  add_convert0_d2c4c6e53f: entity work.add_convert0_entity_d2c4c6e53f
    port map (
      ce_1 => ce_1_sg_x195,
      clk_1 => clk_1_sg_x195,
      theta => assert_dout_net_x1,
      add => convert2_dout_net_x0,
      negate => delay2_q_net_x0
    );

  add_convert1_92ef968a6f: entity work.add_convert1_entity_92ef968a6f
    port map (
      ce_1 => ce_1_sg_x195,
      clk_1 => clk_1_sg_x195,
      misci => concatenate_y_net_x2,
      theta => assert_dout_net_x1,
      add => convert2_dout_net_x1,
      misco => delay1_q_net_x0,
      negate => delay2_q_net_x1
    );

  assert_x0: entity work.xlpassthrough
    generic map (
      din_width => 2,
      dout_width => 2
    )
    port map (
      din => concat_y_net_x1,
      dout => assert_dout_net_x1
    );

  constant2: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant_x0: entity work.constant_95b0f967bc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  delay: entity work.delay_7097453b2c
    port map (
      ce => ce_1_sg_x195,
      clk => clk_1_sg_x195,
      clr => '0',
      d => delay1_q_net_x0,
      q => delay_q_net_x0
    );

  delay10: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x195,
      clk => clk_1_sg_x195,
      clr => '0',
      d(0) => delay2_q_net_x0,
      q(0) => delay10_q_net_x0
    );

  delay8: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x195,
      clk => clk_1_sg_x195,
      clr => '0',
      d(0) => delay2_q_net_x1,
      q(0) => delay8_q_net_x0
    );

  invert0_b1ffbb1c3b: entity work.invert0_entity_b1ffbb1c3b
    port map (
      ce_1 => ce_1_sg_x195,
      clk_1 => clk_1_sg_x195,
      in_x0 => lookup_douta_net_x0,
      negate_x0 => delay10_q_net_x0,
      out_x0 => mux_y_net_x2
    );

  invert1_af1af9b3de: entity work.invert1_entity_af1af9b3de
    port map (
      ce_1 => ce_1_sg_x195,
      clk_1 => clk_1_sg_x195,
      in_x0 => lookup_doutb_net_x0,
      misci => delay_q_net_x0,
      negate_x0 => delay8_q_net_x0,
      misco => delay1_q_net_x2,
      out_x0 => mux_y_net_x3
    );

  lookup: entity work.xldpram_dist_window_and_fft_test_v4
    generic map (
      addr_width => 2,
      c_address_width => 4,
      c_width => 18,
      core_name0 => "dmg_72_61c575268fb396d0",
      latency => 2
    )
    port map (
      a_ce => ce_1_sg_x195,
      a_clk => clk_1_sg_x195,
      addra => convert2_dout_net_x0,
      addrb => convert2_dout_net_x1,
      b_ce => ce_1_sg_x195,
      b_clk => clk_1_sg_x195,
      dina => constant_op_net,
      ena => "1",
      enb => "1",
      wea(0) => constant2_op_net,
      douta => lookup_douta_net_x0,
      doutb => lookup_doutb_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/coeff_gen/ri_to_c"

entity ri_to_c_entity_bee9343a9a is
  port (
    im: in std_logic_vector(17 downto 0); 
    re: in std_logic_vector(17 downto 0); 
    c: out std_logic_vector(35 downto 0)
  );
end ri_to_c_entity_bee9343a9a;

architecture structural of ri_to_c_entity_bee9343a9a is
  signal concat_y_net_x4: std_logic_vector(35 downto 0);
  signal force_im_output_port_net: std_logic_vector(17 downto 0);
  signal force_re_output_port_net: std_logic_vector(17 downto 0);
  signal mux_y_net_x4: std_logic_vector(17 downto 0);
  signal mux_y_net_x5: std_logic_vector(17 downto 0);

begin
  mux_y_net_x5 <= im;
  mux_y_net_x4 <= re;
  c <= concat_y_net_x4;

  concat: entity work.concat_b198bd62b0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x4
    );

  force_im: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux_y_net_x5,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux_y_net_x4,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle/coeff_gen"

entity coeff_gen_entity_e2244a71ac is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    rst: in std_logic; 
    misco: out std_logic_vector(72 downto 0); 
    w: out std_logic_vector(35 downto 0)
  );
end coeff_gen_entity_e2244a71ac;

architecture structural of coeff_gen_entity_e2244a71ac is
  signal ce_1_sg_x196: std_logic;
  signal clk_1_sg_x196: std_logic;
  signal concat_y_net_x1: std_logic_vector(1 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal mux_y_net_x1: std_logic;
  signal mux_y_net_x4: std_logic_vector(17 downto 0);
  signal mux_y_net_x5: std_logic_vector(17 downto 0);
  signal slice_y_net_x0: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x196 <= ce_1;
  clk_1_sg_x196 <= clk_1;
  concatenate_y_net_x3 <= misci;
  mux_y_net_x1 <= rst;
  misco <= delay1_q_net_x3;
  w <= concat_y_net_x5;

  bit_reverse_83075a30ba: entity work.bit_reverse_entity_83075a30ba
    port map (
      in_x0 => slice_y_net_x0,
      out_x0 => concat_y_net_x1
    );

  cosin_80132246cb: entity work.cosin_entity_80132246cb
    port map (
      ce_1 => ce_1_sg_x196,
      clk_1 => clk_1_sg_x196,
      misci => concatenate_y_net_x3,
      theta => concat_y_net_x1,
      cos => mux_y_net_x4,
      misco => delay1_q_net_x3,
      sin => mux_y_net_x5
    );

  counter: entity work.counter_11ccef49a2
    port map (
      ce => ce_1_sg_x196,
      clk => clk_1_sg_x196,
      clr => '0',
      rst(0) => mux_y_net_x1,
      op => counter_op_net
    );

  ri_to_c_bee9343a9a: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => mux_y_net_x5,
      re => mux_y_net_x4,
      c => concat_y_net_x5
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 7,
      x_width => 8,
      y_width => 2
    )
    port map (
      x => counter_op_net,
      y => slice_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct/twiddle"

entity twiddle_entity_3d85e5872d is
  port (
    ai: in std_logic_vector(35 downto 0); 
    bi: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ao: out std_logic_vector(35 downto 0); 
    bwo: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end twiddle_entity_3d85e5872d;

architecture structural of twiddle_entity_3d85e5872d is
  signal ce_1_sg_x197: std_logic;
  signal clk_1_sg_x197: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(37 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x3: std_logic_vector(36 downto 0);
  signal dmux0_q_net_x1: std_logic_vector(35 downto 0);
  signal mux_y_net_x2: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x2 <= ai;
  dmux0_q_net_x1 <= bi;
  ce_1_sg_x197 <= ce_1;
  clk_1_sg_x197 <= clk_1;
  mux_y_net_x2 <= sync_in;
  ao <= reinterpret1_output_port_net_x11;
  bwo <= concatenate_y_net_x7;
  sync_out <= slice2_y_net_x1;

  bus_convert_8995348ed7: entity work.bus_convert_entity_8995348ed7
    port map (
      ce_1 => ce_1_sg_x197,
      clk_1 => clk_1_sg_x197,
      din => reinterpret1_output_port_net_x10,
      misci => dmisc_q_net_x2,
      dout => concatenate_y_net_x7,
      misco => dmisc_q_net_x3
    );

  bus_create_bca4476356: entity work.bus_create_entity_bca4476356
    port map (
      in1 => dmux0_q_net_x1,
      in2 => mux_y_net_x2,
      in3 => reinterpret1_output_port_net_x2,
      bus_out => concatenate_y_net_x3
    );

  bus_expand1_94af2caf5e: entity work.bus_expand1_entity_94af2caf5e
    port map (
      bus_in => dmisc_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x11,
      msb_out2 => slice2_y_net_x1
    );

  bus_expand_0c73098dab: entity work.bus_expand_entity_0c73098dab
    port map (
      bus_in => delay1_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x9,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  bus_mult_516ba8171e: entity work.bus_mult_entity_516ba8171e
    port map (
      a => concat_y_net_x5,
      b => reinterpret2_output_port_net_x3,
      ce_1 => ce_1_sg_x197,
      clk_1 => clk_1_sg_x197,
      misci => reinterpret1_output_port_net_x9,
      a_b => reinterpret1_output_port_net_x10,
      misco => dmisc_q_net_x2
    );

  coeff_gen_e2244a71ac: entity work.coeff_gen_entity_e2244a71ac
    port map (
      ce_1 => ce_1_sg_x197,
      clk_1 => clk_1_sg_x197,
      misci => concatenate_y_net_x3,
      rst => mux_y_net_x2,
      misco => delay1_q_net_x3,
      w => concat_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/butterfly_direct"

entity butterfly_direct_entity_180ee69db7 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(35 downto 0); 
    a_bw_x0: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end butterfly_direct_entity_180ee69db7;

architecture structural of butterfly_direct_entity_180ee69db7 is
  signal ce_1_sg_x198: std_logic;
  signal clk_1_sg_x198: std_logic;
  signal concat_y_net_x3: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x11: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(83 downto 0);
  signal delay0_q_net_x0: std_logic;
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal mux_y_net_x3: std_logic;
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x3 <= a;
  dmux0_q_net_x2 <= b;
  ce_1_sg_x198 <= ce_1;
  clk_1_sg_x198 <= clk_1;
  slice0_y_net_x1 <= shift;
  mux_y_net_x3 <= sync_in;
  a_bw <= reinterpret1_output_port_net_x4;
  a_bw_x0 <= reinterpret2_output_port_net_x1;
  sync_out <= delay0_q_net_x0;

  bus_add_b1cdda5af7: entity work.bus_add_entity_b1cdda5af7
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x198,
      clk_1 => clk_1_sg_x198,
      dout => concatenate_y_net_x3
    );

  bus_convert_b950f53ae4: entity work.bus_convert_entity_b950f53ae4
    port map (
      ce_1 => ce_1_sg_x198,
      clk_1 => clk_1_sg_x198,
      din => concatenate_y_net_x9,
      dout => concatenate_y_net_x4
    );

  bus_expand_b1cca4c51a: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x4,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  bus_norm0_e7ca085468: entity work.bus_norm0_entity_e7ca085468
    port map (
      ce_1 => ce_1_sg_x198,
      clk_1 => clk_1_sg_x198,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x5
    );

  bus_norm1_bd510a87ea: entity work.bus_norm1_entity_bd510a87ea
    port map (
      ce_1 => ce_1_sg_x198,
      clk_1 => clk_1_sg_x198,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x6
    );

  bus_scale_25e603273f: entity work.bus_scale_entity_25e603273f
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_9893acc382: entity work.bus_sub_entity_9893acc382
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x198,
      clk_1 => clk_1_sg_x198,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_cfdc93535e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x3,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  delay0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x198,
      clk => clk_1_sg_x198,
      clr => '0',
      d(0) => slice2_y_net_x1,
      q(0) => delay0_q_net_x0
    );

  mux_83804557c8: entity work.mux_entity_83804557c8
    port map (
      ce_1 => ce_1_sg_x198,
      clk_1 => clk_1_sg_x198,
      d0 => concatenate_y_net_x5,
      d1 => concatenate_y_net_x6,
      sel => concatenate_y_net_x10,
      out_x0 => concatenate_y_net_x9
    );

  shift_replicate_a4c4bbe79a: entity work.shift_replicate_entity_7f26e672bf
    port map (
      ce_1 => ce_1_sg_x198,
      clk_1 => clk_1_sg_x198,
      in_x0 => slice0_y_net_x1,
      out_x0 => concatenate_y_net_x10
    );

  twiddle_3d85e5872d: entity work.twiddle_entity_3d85e5872d
    port map (
      ai => reinterpret1_output_port_net_x3,
      bi => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x198,
      clk_1 => clk_1_sg_x198,
      sync_in => mux_y_net_x3,
      ao => reinterpret1_output_port_net_x11,
      bwo => concatenate_y_net_x11,
      sync_out => slice2_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/delay0"

entity delay0_entity_260d9065e3 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end delay0_entity_260d9065e3;

architecture structural of delay0_entity_260d9065e3 is
  signal ce_1_sg_x199: std_logic;
  signal clk_1_sg_x199: std_logic;
  signal del1_q_net_x0: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x199 <= ce_1;
  clk_1_sg_x199 <= clk_1;
  din2_q_net_x1 <= din;
  dout <= reinterpret1_output_port_net_x2;

  del1: entity work.delay_9b6c7a899e
    port map (
      ce => ce_1_sg_x199,
      clk => clk_1_sg_x199,
      clr => '0',
      d => reinterpret1_output_port_net_x0,
      q => del1_q_net_x0
    );

  din_expand_c893176367: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => din2_q_net_x1,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  dout_compress_ebd394fdea: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => del1_q_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3/sync_delay"

entity sync_delay_entity_d1e2c0c90c is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_entity_d1e2c0c90c;

architecture structural of sync_delay_entity_d1e2c0c90c is
  signal ce_1_sg_x201: std_logic;
  signal clk_1_sg_x201: std_logic;
  signal constant1_op_net: std_logic_vector(6 downto 0);
  signal constant2_op_net: std_logic_vector(6 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(6 downto 0);
  signal counter_op_net: std_logic_vector(6 downto 0);
  signal dsync1_q_net_x0: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x4: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x201 <= ce_1;
  clk_1_sg_x201 <= clk_1;
  dsync1_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x4;

  constant1: entity work.constant_7244cd602b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_7b07120b87
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_180df391de
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_82d8714dde
    port map (
      ce => ce_1_sg_x201,
      clk => clk_1_sg_x201,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical_y_net,
      load(0) => dsync1_q_net_x0,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x4
    );

  relational: entity work.relational_9a3978c602
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_23065a6aa3
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_3"

entity fft_stage_3_entity_c0581b89be is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    out1: out std_logic_vector(35 downto 0); 
    out2: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_stage_3_entity_c0581b89be;

architecture structural of fft_stage_3_entity_c0581b89be is
  signal ce_1_sg_x202: std_logic;
  signal clk_1_sg_x202: std_logic;
  signal counter_op_net: std_logic_vector(6 downto 0);
  signal delay0_q_net_x4: std_logic;
  signal delay0_q_net_x5: std_logic;
  signal delay11_q_net_x2: std_logic_vector(10 downto 0);
  signal din0_q_net: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal dmux1_q_net_x1: std_logic_vector(35 downto 0);
  signal dsync0_q_net: std_logic;
  signal dsync1_q_net_x0: std_logic;
  signal mux0_y_net: std_logic_vector(35 downto 0);
  signal mux1_y_net: std_logic_vector(35 downto 0);
  signal mux_y_net_x4: std_logic;
  signal reinterpret1_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x13: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x6: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice1_y_net: std_logic;

begin
  ce_1_sg_x202 <= ce_1;
  clk_1_sg_x202 <= clk_1;
  reinterpret2_output_port_net_x5 <= in1;
  reinterpret1_output_port_net_x12 <= in2;
  delay11_q_net_x2 <= shift;
  delay0_q_net_x4 <= sync;
  out1 <= reinterpret2_output_port_net_x6;
  out2 <= reinterpret1_output_port_net_x13;
  sync_out <= delay0_q_net_x5;

  butterfly_direct_180ee69db7: entity work.butterfly_direct_entity_180ee69db7
    port map (
      a => reinterpret1_output_port_net_x5,
      b => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x202,
      clk_1 => clk_1_sg_x202,
      shift => slice0_y_net_x1,
      sync_in => mux_y_net_x4,
      a_bw => reinterpret1_output_port_net_x13,
      a_bw_x0 => reinterpret2_output_port_net_x6,
      sync_out => delay0_q_net_x5
    );

  counter: entity work.counter_e63924e4e7
    port map (
      ce => ce_1_sg_x202,
      clk => clk_1_sg_x202,
      clr => '0',
      rst(0) => dsync0_q_net,
      op => counter_op_net
    );

  delay0_260d9065e3: entity work.delay0_entity_260d9065e3
    port map (
      ce_1 => ce_1_sg_x202,
      clk_1 => clk_1_sg_x202,
      din => din2_q_net_x1,
      dout => reinterpret1_output_port_net_x2
    );

  delay1_84f7e82fc6: entity work.delay0_entity_260d9065e3
    port map (
      ce_1 => ce_1_sg_x202,
      clk_1 => clk_1_sg_x202,
      din => dmux1_q_net_x1,
      dout => reinterpret1_output_port_net_x5
    );

  din0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret2_output_port_net_x5,
      q => din0_q_net
    );

  din2: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret1_output_port_net_x12,
      q => din2_q_net_x1
    );

  dmux0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux0_y_net,
      q => dmux0_q_net_x2
    );

  dmux1: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux1_y_net,
      q => dmux1_q_net_x1
    );

  dsync0: entity work.delay_0341f7be44
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d(0) => delay0_q_net_x4,
      q(0) => dsync0_q_net
    );

  dsync1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x202,
      clk => clk_1_sg_x202,
      clr => '0',
      d(0) => dsync0_q_net,
      q(0) => dsync1_q_net_x0
    );

  mux0: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x202,
      clk => clk_1_sg_x202,
      clr => '0',
      d0 => reinterpret1_output_port_net_x2,
      d1 => din0_q_net,
      sel(0) => slice1_y_net,
      y => mux0_y_net
    );

  mux1: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x202,
      clk => clk_1_sg_x202,
      clr => '0',
      d0 => din0_q_net,
      d1 => reinterpret1_output_port_net_x2,
      sel(0) => slice1_y_net,
      y => mux1_y_net
    );

  slice0: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 11,
      y_width => 1
    )
    port map (
      x => delay11_q_net_x2,
      y(0) => slice0_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 6,
      x_width => 7,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice1_y_net
    );

  sync_delay_d1e2c0c90c: entity work.sync_delay_entity_d1e2c0c90c
    port map (
      ce_1 => ce_1_sg_x202,
      clk_1 => clk_1_sg_x202,
      in_x0 => dsync1_q_net_x0,
      out_x0 => mux_y_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_4/butterfly_direct/twiddle/coeff_gen/bit_reverse"

entity bit_reverse_entity_b769e88a7b is
  port (
    in_x0: in std_logic_vector(2 downto 0); 
    out_x0: out std_logic_vector(2 downto 0)
  );
end bit_reverse_entity_b769e88a7b;

architecture structural of bit_reverse_entity_b769e88a7b is
  signal bit0_y_net: std_logic;
  signal bit1_y_net: std_logic;
  signal bit2_y_net: std_logic;
  signal concat_y_net_x0: std_logic_vector(2 downto 0);
  signal slice_y_net_x0: std_logic_vector(2 downto 0);

begin
  slice_y_net_x0 <= in_x0;
  out_x0 <= concat_y_net_x0;

  bit0: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 3,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit0_y_net
    );

  bit1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 3,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit1_y_net
    );

  bit2: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 3,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit2_y_net
    );

  concat: entity work.concat_452c4d3410
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => bit0_y_net,
      in1(0) => bit1_y_net,
      in2(0) => bit2_y_net,
      y => concat_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_4/butterfly_direct/twiddle/coeff_gen/cosin/add_convert0"

entity add_convert0_entity_fb90dc6902 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    theta: in std_logic_vector(2 downto 0); 
    add: out std_logic_vector(2 downto 0); 
    negate: out std_logic
  );
end add_convert0_entity_fb90dc6902;

architecture structural of add_convert0_entity_fb90dc6902 is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x0: std_logic_vector(2 downto 0);
  signal ce_1_sg_x229: std_logic;
  signal clk_1_sg_x229: std_logic;
  signal concat_y_net: std_logic_vector(3 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(2 downto 0);
  signal delay13_q_net: std_logic_vector(2 downto 0);
  signal delay14_q_net: std_logic_vector(2 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(3 downto 0);
  signal invert_y_net: std_logic;
  signal lookup_y_net: std_logic_vector(1 downto 0);
  signal new_add_y_net: std_logic_vector(2 downto 0);
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x229 <= ce_1;
  clk_1_sg_x229 <= clk_1;
  assert_dout_net_x0 <= theta;
  add <= convert2_dout_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x229,
      clk => clk_1_sg_x229,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  concat: entity work.concat_bd20dd351d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => addsub5_s_net,
      in1 => lookup_y_net,
      y => concat_y_net
    );

  convert2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 3,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 3,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x229,
      clk => clk_1_sg_x229,
      clr => '0',
      din => delay13_q_net,
      en => "1",
      dout => convert2_dout_net_x0
    );

  delay13: entity work.delay_6edcd04662
    port map (
      ce => ce_1_sg_x229,
      clk => clk_1_sg_x229,
      clr => '0',
      d => delay14_q_net,
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 3
    )
    port map (
      ce => ce_1_sg_x229,
      clk => clk_1_sg_x229,
      d => new_add_y_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x229,
      clk => clk_1_sg_x229,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_949f038a6d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x0,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  lookup: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 1,
      x_width => 4,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => lookup_y_net
    );

  new_add: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 2,
      x_width => 4,
      y_width => 3
    )
    port map (
      x => concat_y_net,
      y => new_add_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 3,
      x_width => 4,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_4/butterfly_direct/twiddle/coeff_gen/cosin/add_convert1"

entity add_convert1_entity_911bdff28e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(2 downto 0); 
    add: out std_logic_vector(2 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    negate: out std_logic
  );
end add_convert1_entity_911bdff28e;

architecture structural of add_convert1_entity_911bdff28e is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x1: std_logic_vector(2 downto 0);
  signal ce_1_sg_x230: std_logic;
  signal clk_1_sg_x230: std_logic;
  signal concat_y_net: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(72 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(2 downto 0);
  signal delay13_q_net: std_logic_vector(2 downto 0);
  signal delay14_q_net: std_logic_vector(2 downto 0);
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(3 downto 0);
  signal invert_y_net: std_logic;
  signal lookup_y_net: std_logic_vector(1 downto 0);
  signal new_add_y_net: std_logic_vector(2 downto 0);
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x230 <= ce_1;
  clk_1_sg_x230 <= clk_1;
  concatenate_y_net_x1 <= misci;
  assert_dout_net_x1 <= theta;
  add <= convert2_dout_net_x0;
  misco <= delay1_q_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x230,
      clk => clk_1_sg_x230,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  concat: entity work.concat_bd20dd351d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => addsub5_s_net,
      in1 => lookup_y_net,
      y => concat_y_net
    );

  convert2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 3,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 3,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x230,
      clk => clk_1_sg_x230,
      clr => '0',
      din => delay13_q_net,
      en => "1",
      dout => convert2_dout_net_x0
    );

  delay1: entity work.delay_4e967fa4b7
    port map (
      ce => ce_1_sg_x230,
      clk => clk_1_sg_x230,
      clr => '0',
      d => concatenate_y_net_x1,
      q => delay1_q_net_x0
    );

  delay13: entity work.delay_6edcd04662
    port map (
      ce => ce_1_sg_x230,
      clk => clk_1_sg_x230,
      clr => '0',
      d => delay14_q_net,
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 3
    )
    port map (
      ce => ce_1_sg_x230,
      clk => clk_1_sg_x230,
      d => new_add_y_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x230,
      clk => clk_1_sg_x230,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_a7e2bb9e12
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_949f038a6d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x1,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  lookup: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 1,
      x_width => 4,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => lookup_y_net
    );

  new_add: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 2,
      x_width => 4,
      y_width => 3
    )
    port map (
      x => concat_y_net,
      y => new_add_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 3,
      x_width => 4,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_4/butterfly_direct/twiddle/coeff_gen/cosin"

entity cosin_entity_94bc1bbca6 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(2 downto 0); 
    cos: out std_logic_vector(17 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    sin: out std_logic_vector(17 downto 0)
  );
end cosin_entity_94bc1bbca6;

architecture structural of cosin_entity_94bc1bbca6 is
  signal assert_dout_net_x1: std_logic_vector(2 downto 0);
  signal ce_1_sg_x233: std_logic;
  signal clk_1_sg_x233: std_logic;
  signal concat_y_net_x1: std_logic_vector(2 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(72 downto 0);
  signal constant2_op_net: std_logic;
  signal constant_op_net: std_logic_vector(17 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(2 downto 0);
  signal convert2_dout_net_x1: std_logic_vector(2 downto 0);
  signal delay10_q_net_x0: std_logic;
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay1_q_net_x2: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal delay2_q_net_x1: std_logic;
  signal delay8_q_net_x0: std_logic;
  signal delay_q_net_x0: std_logic_vector(72 downto 0);
  signal lookup_douta_net_x0: std_logic_vector(17 downto 0);
  signal lookup_doutb_net_x0: std_logic_vector(17 downto 0);
  signal mux_y_net_x2: std_logic_vector(17 downto 0);
  signal mux_y_net_x3: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x233 <= ce_1;
  clk_1_sg_x233 <= clk_1;
  concatenate_y_net_x2 <= misci;
  concat_y_net_x1 <= theta;
  cos <= mux_y_net_x2;
  misco <= delay1_q_net_x2;
  sin <= mux_y_net_x3;

  add_convert0_fb90dc6902: entity work.add_convert0_entity_fb90dc6902
    port map (
      ce_1 => ce_1_sg_x233,
      clk_1 => clk_1_sg_x233,
      theta => assert_dout_net_x1,
      add => convert2_dout_net_x0,
      negate => delay2_q_net_x0
    );

  add_convert1_911bdff28e: entity work.add_convert1_entity_911bdff28e
    port map (
      ce_1 => ce_1_sg_x233,
      clk_1 => clk_1_sg_x233,
      misci => concatenate_y_net_x2,
      theta => assert_dout_net_x1,
      add => convert2_dout_net_x1,
      misco => delay1_q_net_x0,
      negate => delay2_q_net_x1
    );

  assert_x0: entity work.xlpassthrough
    generic map (
      din_width => 3,
      dout_width => 3
    )
    port map (
      din => concat_y_net_x1,
      dout => assert_dout_net_x1
    );

  constant2: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant_x0: entity work.constant_95b0f967bc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  delay: entity work.delay_7097453b2c
    port map (
      ce => ce_1_sg_x233,
      clk => clk_1_sg_x233,
      clr => '0',
      d => delay1_q_net_x0,
      q => delay_q_net_x0
    );

  delay10: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x233,
      clk => clk_1_sg_x233,
      clr => '0',
      d(0) => delay2_q_net_x0,
      q(0) => delay10_q_net_x0
    );

  delay8: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x233,
      clk => clk_1_sg_x233,
      clr => '0',
      d(0) => delay2_q_net_x1,
      q(0) => delay8_q_net_x0
    );

  invert0_cae1a3c18d: entity work.invert0_entity_b1ffbb1c3b
    port map (
      ce_1 => ce_1_sg_x233,
      clk_1 => clk_1_sg_x233,
      in_x0 => lookup_douta_net_x0,
      negate_x0 => delay10_q_net_x0,
      out_x0 => mux_y_net_x2
    );

  invert1_b70413debf: entity work.invert1_entity_af1af9b3de
    port map (
      ce_1 => ce_1_sg_x233,
      clk_1 => clk_1_sg_x233,
      in_x0 => lookup_doutb_net_x0,
      misci => delay_q_net_x0,
      negate_x0 => delay8_q_net_x0,
      misco => delay1_q_net_x2,
      out_x0 => mux_y_net_x3
    );

  lookup: entity work.xldpram_dist_window_and_fft_test_v4
    generic map (
      addr_width => 3,
      c_address_width => 4,
      c_width => 18,
      core_name0 => "dmg_72_3edbd32a5305b92d",
      latency => 2
    )
    port map (
      a_ce => ce_1_sg_x233,
      a_clk => clk_1_sg_x233,
      addra => convert2_dout_net_x0,
      addrb => convert2_dout_net_x1,
      b_ce => ce_1_sg_x233,
      b_clk => clk_1_sg_x233,
      dina => constant_op_net,
      ena => "1",
      enb => "1",
      wea(0) => constant2_op_net,
      douta => lookup_douta_net_x0,
      doutb => lookup_doutb_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_4/butterfly_direct/twiddle/coeff_gen"

entity coeff_gen_entity_6d96bea0c6 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    rst: in std_logic; 
    misco: out std_logic_vector(72 downto 0); 
    w: out std_logic_vector(35 downto 0)
  );
end coeff_gen_entity_6d96bea0c6;

architecture structural of coeff_gen_entity_6d96bea0c6 is
  signal ce_1_sg_x234: std_logic;
  signal clk_1_sg_x234: std_logic;
  signal concat_y_net_x1: std_logic_vector(2 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal mux_y_net_x1: std_logic;
  signal mux_y_net_x4: std_logic_vector(17 downto 0);
  signal mux_y_net_x5: std_logic_vector(17 downto 0);
  signal slice_y_net_x0: std_logic_vector(2 downto 0);

begin
  ce_1_sg_x234 <= ce_1;
  clk_1_sg_x234 <= clk_1;
  concatenate_y_net_x3 <= misci;
  mux_y_net_x1 <= rst;
  misco <= delay1_q_net_x3;
  w <= concat_y_net_x5;

  bit_reverse_b769e88a7b: entity work.bit_reverse_entity_b769e88a7b
    port map (
      in_x0 => slice_y_net_x0,
      out_x0 => concat_y_net_x1
    );

  cosin_94bc1bbca6: entity work.cosin_entity_94bc1bbca6
    port map (
      ce_1 => ce_1_sg_x234,
      clk_1 => clk_1_sg_x234,
      misci => concatenate_y_net_x3,
      theta => concat_y_net_x1,
      cos => mux_y_net_x4,
      misco => delay1_q_net_x3,
      sin => mux_y_net_x5
    );

  counter: entity work.counter_11ccef49a2
    port map (
      ce => ce_1_sg_x234,
      clk => clk_1_sg_x234,
      clr => '0',
      rst(0) => mux_y_net_x1,
      op => counter_op_net
    );

  ri_to_c_0235a12bf4: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => mux_y_net_x5,
      re => mux_y_net_x4,
      c => concat_y_net_x5
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 5,
      new_msb => 7,
      x_width => 8,
      y_width => 3
    )
    port map (
      x => counter_op_net,
      y => slice_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_4/butterfly_direct/twiddle"

entity twiddle_entity_6b9ef71698 is
  port (
    ai: in std_logic_vector(35 downto 0); 
    bi: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ao: out std_logic_vector(35 downto 0); 
    bwo: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end twiddle_entity_6b9ef71698;

architecture structural of twiddle_entity_6b9ef71698 is
  signal ce_1_sg_x235: std_logic;
  signal clk_1_sg_x235: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(37 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x3: std_logic_vector(36 downto 0);
  signal dmux0_q_net_x1: std_logic_vector(35 downto 0);
  signal mux_y_net_x2: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x2 <= ai;
  dmux0_q_net_x1 <= bi;
  ce_1_sg_x235 <= ce_1;
  clk_1_sg_x235 <= clk_1;
  mux_y_net_x2 <= sync_in;
  ao <= reinterpret1_output_port_net_x11;
  bwo <= concatenate_y_net_x7;
  sync_out <= slice2_y_net_x1;

  bus_convert_28505417e7: entity work.bus_convert_entity_8995348ed7
    port map (
      ce_1 => ce_1_sg_x235,
      clk_1 => clk_1_sg_x235,
      din => reinterpret1_output_port_net_x10,
      misci => dmisc_q_net_x2,
      dout => concatenate_y_net_x7,
      misco => dmisc_q_net_x3
    );

  bus_create_8400c7a423: entity work.bus_create_entity_bca4476356
    port map (
      in1 => dmux0_q_net_x1,
      in2 => mux_y_net_x2,
      in3 => reinterpret1_output_port_net_x2,
      bus_out => concatenate_y_net_x3
    );

  bus_expand1_de8db6089b: entity work.bus_expand1_entity_94af2caf5e
    port map (
      bus_in => dmisc_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x11,
      msb_out2 => slice2_y_net_x1
    );

  bus_expand_f120739005: entity work.bus_expand_entity_0c73098dab
    port map (
      bus_in => delay1_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x9,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  bus_mult_e374419a6e: entity work.bus_mult_entity_516ba8171e
    port map (
      a => concat_y_net_x5,
      b => reinterpret2_output_port_net_x3,
      ce_1 => ce_1_sg_x235,
      clk_1 => clk_1_sg_x235,
      misci => reinterpret1_output_port_net_x9,
      a_b => reinterpret1_output_port_net_x10,
      misco => dmisc_q_net_x2
    );

  coeff_gen_6d96bea0c6: entity work.coeff_gen_entity_6d96bea0c6
    port map (
      ce_1 => ce_1_sg_x235,
      clk_1 => clk_1_sg_x235,
      misci => concatenate_y_net_x3,
      rst => mux_y_net_x2,
      misco => delay1_q_net_x3,
      w => concat_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_4/butterfly_direct"

entity butterfly_direct_entity_f24af96afb is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(35 downto 0); 
    a_bw_x0: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end butterfly_direct_entity_f24af96afb;

architecture structural of butterfly_direct_entity_f24af96afb is
  signal ce_1_sg_x236: std_logic;
  signal clk_1_sg_x236: std_logic;
  signal concat_y_net_x3: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x11: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(83 downto 0);
  signal delay0_q_net_x0: std_logic;
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal mux_y_net_x3: std_logic;
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x3 <= a;
  dmux0_q_net_x2 <= b;
  ce_1_sg_x236 <= ce_1;
  clk_1_sg_x236 <= clk_1;
  slice0_y_net_x1 <= shift;
  mux_y_net_x3 <= sync_in;
  a_bw <= reinterpret1_output_port_net_x4;
  a_bw_x0 <= reinterpret2_output_port_net_x1;
  sync_out <= delay0_q_net_x0;

  bus_add_9dd2da6837: entity work.bus_add_entity_b1cdda5af7
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x236,
      clk_1 => clk_1_sg_x236,
      dout => concatenate_y_net_x3
    );

  bus_convert_ce966497f8: entity work.bus_convert_entity_b950f53ae4
    port map (
      ce_1 => ce_1_sg_x236,
      clk_1 => clk_1_sg_x236,
      din => concatenate_y_net_x9,
      dout => concatenate_y_net_x4
    );

  bus_expand_15c32ee8c0: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x4,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  bus_norm0_1ae04b19db: entity work.bus_norm0_entity_e7ca085468
    port map (
      ce_1 => ce_1_sg_x236,
      clk_1 => clk_1_sg_x236,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x5
    );

  bus_norm1_31ba8594f2: entity work.bus_norm1_entity_bd510a87ea
    port map (
      ce_1 => ce_1_sg_x236,
      clk_1 => clk_1_sg_x236,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x6
    );

  bus_scale_cbf068a06b: entity work.bus_scale_entity_25e603273f
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_fc68d7eb65: entity work.bus_sub_entity_9893acc382
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x236,
      clk_1 => clk_1_sg_x236,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_cfdc93535e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x3,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  delay0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x236,
      clk => clk_1_sg_x236,
      clr => '0',
      d(0) => slice2_y_net_x1,
      q(0) => delay0_q_net_x0
    );

  mux_aea84e612d: entity work.mux_entity_83804557c8
    port map (
      ce_1 => ce_1_sg_x236,
      clk_1 => clk_1_sg_x236,
      d0 => concatenate_y_net_x5,
      d1 => concatenate_y_net_x6,
      sel => concatenate_y_net_x10,
      out_x0 => concatenate_y_net_x9
    );

  shift_replicate_54e45f1621: entity work.shift_replicate_entity_7f26e672bf
    port map (
      ce_1 => ce_1_sg_x236,
      clk_1 => clk_1_sg_x236,
      in_x0 => slice0_y_net_x1,
      out_x0 => concatenate_y_net_x10
    );

  twiddle_6b9ef71698: entity work.twiddle_entity_6b9ef71698
    port map (
      ai => reinterpret1_output_port_net_x3,
      bi => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x236,
      clk_1 => clk_1_sg_x236,
      sync_in => mux_y_net_x3,
      ao => reinterpret1_output_port_net_x11,
      bwo => concatenate_y_net_x11,
      sync_out => slice2_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_4/delay0"

entity delay0_entity_fcdaa5c35b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end delay0_entity_fcdaa5c35b;

architecture structural of delay0_entity_fcdaa5c35b is
  signal ce_1_sg_x237: std_logic;
  signal clk_1_sg_x237: std_logic;
  signal del1_q_net_x0: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x237 <= ce_1;
  clk_1_sg_x237 <= clk_1;
  din2_q_net_x1 <= din;
  dout <= reinterpret1_output_port_net_x2;

  del1: entity work.delay_895e998e80
    port map (
      ce => ce_1_sg_x237,
      clk => clk_1_sg_x237,
      clr => '0',
      d => reinterpret1_output_port_net_x0,
      q => del1_q_net_x0
    );

  din_expand_ce4706e547: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => din2_q_net_x1,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  dout_compress_5ebd066295: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => del1_q_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_4/sync_delay"

entity sync_delay_entity_485cd9cd31 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_entity_485cd9cd31;

architecture structural of sync_delay_entity_485cd9cd31 is
  signal ce_1_sg_x239: std_logic;
  signal clk_1_sg_x239: std_logic;
  signal constant1_op_net: std_logic_vector(5 downto 0);
  signal constant2_op_net: std_logic_vector(5 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(5 downto 0);
  signal counter_op_net: std_logic_vector(5 downto 0);
  signal dsync1_q_net_x0: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x4: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x239 <= ce_1;
  clk_1_sg_x239 <= clk_1;
  dsync1_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x4;

  constant1: entity work.constant_7ea0f2fff7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_961b61f8a1
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_a267c870be
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_9686286f74
    port map (
      ce => ce_1_sg_x239,
      clk => clk_1_sg_x239,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical_y_net,
      load(0) => dsync1_q_net_x0,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x4
    );

  relational: entity work.relational_931d61fb72
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_fe487ce1c7
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_4"

entity fft_stage_4_entity_a2df2ada34 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    out1: out std_logic_vector(35 downto 0); 
    out2: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_stage_4_entity_a2df2ada34;

architecture structural of fft_stage_4_entity_a2df2ada34 is
  signal ce_1_sg_x240: std_logic;
  signal clk_1_sg_x240: std_logic;
  signal counter_op_net: std_logic_vector(5 downto 0);
  signal delay0_q_net_x1: std_logic;
  signal delay0_q_net_x6: std_logic;
  signal delay11_q_net_x3: std_logic_vector(10 downto 0);
  signal din0_q_net: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal dmux1_q_net_x1: std_logic_vector(35 downto 0);
  signal dsync0_q_net: std_logic;
  signal dsync1_q_net_x0: std_logic;
  signal mux0_y_net: std_logic_vector(35 downto 0);
  signal mux1_y_net: std_logic_vector(35 downto 0);
  signal mux_y_net_x4: std_logic;
  signal reinterpret1_output_port_net_x14: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x7: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice1_y_net: std_logic;

begin
  ce_1_sg_x240 <= ce_1;
  clk_1_sg_x240 <= clk_1;
  reinterpret2_output_port_net_x7 <= in1;
  reinterpret1_output_port_net_x14 <= in2;
  delay11_q_net_x3 <= shift;
  delay0_q_net_x6 <= sync;
  out1 <= reinterpret2_output_port_net_x2;
  out2 <= reinterpret1_output_port_net_x6;
  sync_out <= delay0_q_net_x1;

  butterfly_direct_f24af96afb: entity work.butterfly_direct_entity_f24af96afb
    port map (
      a => reinterpret1_output_port_net_x5,
      b => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x240,
      clk_1 => clk_1_sg_x240,
      shift => slice0_y_net_x1,
      sync_in => mux_y_net_x4,
      a_bw => reinterpret1_output_port_net_x6,
      a_bw_x0 => reinterpret2_output_port_net_x2,
      sync_out => delay0_q_net_x1
    );

  counter: entity work.counter_7888581f80
    port map (
      ce => ce_1_sg_x240,
      clk => clk_1_sg_x240,
      clr => '0',
      rst(0) => dsync0_q_net,
      op => counter_op_net
    );

  delay0_fcdaa5c35b: entity work.delay0_entity_fcdaa5c35b
    port map (
      ce_1 => ce_1_sg_x240,
      clk_1 => clk_1_sg_x240,
      din => din2_q_net_x1,
      dout => reinterpret1_output_port_net_x2
    );

  delay1_46a4843068: entity work.delay0_entity_fcdaa5c35b
    port map (
      ce_1 => ce_1_sg_x240,
      clk_1 => clk_1_sg_x240,
      din => dmux1_q_net_x1,
      dout => reinterpret1_output_port_net_x5
    );

  din0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret2_output_port_net_x7,
      q => din0_q_net
    );

  din2: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret1_output_port_net_x14,
      q => din2_q_net_x1
    );

  dmux0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux0_y_net,
      q => dmux0_q_net_x2
    );

  dmux1: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux1_y_net,
      q => dmux1_q_net_x1
    );

  dsync0: entity work.delay_0341f7be44
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d(0) => delay0_q_net_x6,
      q(0) => dsync0_q_net
    );

  dsync1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x240,
      clk => clk_1_sg_x240,
      clr => '0',
      d(0) => dsync0_q_net,
      q(0) => dsync1_q_net_x0
    );

  mux0: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x240,
      clk => clk_1_sg_x240,
      clr => '0',
      d0 => reinterpret1_output_port_net_x2,
      d1 => din0_q_net,
      sel(0) => slice1_y_net,
      y => mux0_y_net
    );

  mux1: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x240,
      clk => clk_1_sg_x240,
      clr => '0',
      d0 => din0_q_net,
      d1 => reinterpret1_output_port_net_x2,
      sel(0) => slice1_y_net,
      y => mux1_y_net
    );

  slice0: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 11,
      y_width => 1
    )
    port map (
      x => delay11_q_net_x3,
      y(0) => slice0_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 5,
      new_msb => 5,
      x_width => 6,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice1_y_net
    );

  sync_delay_485cd9cd31: entity work.sync_delay_entity_485cd9cd31
    port map (
      ce_1 => ce_1_sg_x240,
      clk_1 => clk_1_sg_x240,
      in_x0 => dsync1_q_net_x0,
      out_x0 => mux_y_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_5/butterfly_direct/twiddle/coeff_gen/bit_reverse"

entity bit_reverse_entity_7b1038368f is
  port (
    in_x0: in std_logic_vector(3 downto 0); 
    out_x0: out std_logic_vector(3 downto 0)
  );
end bit_reverse_entity_7b1038368f;

architecture structural of bit_reverse_entity_7b1038368f is
  signal bit0_y_net: std_logic;
  signal bit1_y_net: std_logic;
  signal bit2_y_net: std_logic;
  signal bit3_y_net: std_logic;
  signal concat_y_net_x0: std_logic_vector(3 downto 0);
  signal slice_y_net_x0: std_logic_vector(3 downto 0);

begin
  slice_y_net_x0 <= in_x0;
  out_x0 <= concat_y_net_x0;

  bit0: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit0_y_net
    );

  bit1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit1_y_net
    );

  bit2: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit2_y_net
    );

  bit3: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit3_y_net
    );

  concat: entity work.concat_a0c7cd7a34
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => bit0_y_net,
      in1(0) => bit1_y_net,
      in2(0) => bit2_y_net,
      in3(0) => bit3_y_net,
      y => concat_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_5/butterfly_direct/twiddle/coeff_gen/cosin/add_convert0"

entity add_convert0_entity_42f0096abc is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    theta: in std_logic_vector(3 downto 0); 
    add: out std_logic_vector(3 downto 0); 
    negate: out std_logic
  );
end add_convert0_entity_42f0096abc;

architecture structural of add_convert0_entity_42f0096abc is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x0: std_logic_vector(3 downto 0);
  signal ce_1_sg_x267: std_logic;
  signal clk_1_sg_x267: std_logic;
  signal concat_y_net: std_logic_vector(4 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(3 downto 0);
  signal delay13_q_net: std_logic_vector(3 downto 0);
  signal delay14_q_net: std_logic_vector(3 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(4 downto 0);
  signal invert_y_net: std_logic;
  signal lookup_y_net: std_logic_vector(2 downto 0);
  signal new_add_y_net: std_logic_vector(3 downto 0);
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x267 <= ce_1;
  clk_1_sg_x267 <= clk_1;
  assert_dout_net_x0 <= theta;
  add <= convert2_dout_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x267,
      clk => clk_1_sg_x267,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  concat: entity work.concat_8f12c32de0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => addsub5_s_net,
      in1 => lookup_y_net,
      y => concat_y_net
    );

  convert2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 4,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 4,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x267,
      clk => clk_1_sg_x267,
      clr => '0',
      din => delay13_q_net,
      en => "1",
      dout => convert2_dout_net_x0
    );

  delay13: entity work.delay_4f82bd00e5
    port map (
      ce => ce_1_sg_x267,
      clk => clk_1_sg_x267,
      clr => '0',
      d => delay14_q_net,
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 4
    )
    port map (
      ce => ce_1_sg_x267,
      clk => clk_1_sg_x267,
      d => new_add_y_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x267,
      clk => clk_1_sg_x267,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_cf540617d5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x0,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  lookup: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 2,
      x_width => 5,
      y_width => 3
    )
    port map (
      x => fluff_y_net,
      y => lookup_y_net
    );

  new_add: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 3,
      x_width => 5,
      y_width => 4
    )
    port map (
      x => concat_y_net,
      y => new_add_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 4,
      x_width => 5,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_5/butterfly_direct/twiddle/coeff_gen/cosin/add_convert1"

entity add_convert1_entity_44de86632a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(3 downto 0); 
    add: out std_logic_vector(3 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    negate: out std_logic
  );
end add_convert1_entity_44de86632a;

architecture structural of add_convert1_entity_44de86632a is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x1: std_logic_vector(3 downto 0);
  signal ce_1_sg_x268: std_logic;
  signal clk_1_sg_x268: std_logic;
  signal concat_y_net: std_logic_vector(4 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(72 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(3 downto 0);
  signal delay13_q_net: std_logic_vector(3 downto 0);
  signal delay14_q_net: std_logic_vector(3 downto 0);
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(4 downto 0);
  signal invert_y_net: std_logic;
  signal lookup_y_net: std_logic_vector(2 downto 0);
  signal new_add_y_net: std_logic_vector(3 downto 0);
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x268 <= ce_1;
  clk_1_sg_x268 <= clk_1;
  concatenate_y_net_x1 <= misci;
  assert_dout_net_x1 <= theta;
  add <= convert2_dout_net_x0;
  misco <= delay1_q_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x268,
      clk => clk_1_sg_x268,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  concat: entity work.concat_8f12c32de0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => addsub5_s_net,
      in1 => lookup_y_net,
      y => concat_y_net
    );

  convert2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 4,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 4,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x268,
      clk => clk_1_sg_x268,
      clr => '0',
      din => delay13_q_net,
      en => "1",
      dout => convert2_dout_net_x0
    );

  delay1: entity work.delay_4e967fa4b7
    port map (
      ce => ce_1_sg_x268,
      clk => clk_1_sg_x268,
      clr => '0',
      d => concatenate_y_net_x1,
      q => delay1_q_net_x0
    );

  delay13: entity work.delay_4f82bd00e5
    port map (
      ce => ce_1_sg_x268,
      clk => clk_1_sg_x268,
      clr => '0',
      d => delay14_q_net,
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 4
    )
    port map (
      ce => ce_1_sg_x268,
      clk => clk_1_sg_x268,
      d => new_add_y_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x268,
      clk => clk_1_sg_x268,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_a7e2bb9e12
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_cf540617d5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x1,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  lookup: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 2,
      x_width => 5,
      y_width => 3
    )
    port map (
      x => fluff_y_net,
      y => lookup_y_net
    );

  new_add: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 3,
      x_width => 5,
      y_width => 4
    )
    port map (
      x => concat_y_net,
      y => new_add_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 4,
      x_width => 5,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_5/butterfly_direct/twiddle/coeff_gen/cosin"

entity cosin_entity_6408c1a8ec is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(3 downto 0); 
    cos: out std_logic_vector(17 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    sin: out std_logic_vector(17 downto 0)
  );
end cosin_entity_6408c1a8ec;

architecture structural of cosin_entity_6408c1a8ec is
  signal assert_dout_net_x1: std_logic_vector(3 downto 0);
  signal ce_1_sg_x271: std_logic;
  signal clk_1_sg_x271: std_logic;
  signal concat_y_net_x1: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(72 downto 0);
  signal constant2_op_net: std_logic;
  signal constant_op_net: std_logic_vector(17 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(3 downto 0);
  signal convert2_dout_net_x1: std_logic_vector(3 downto 0);
  signal delay10_q_net_x0: std_logic;
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay1_q_net_x2: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal delay2_q_net_x1: std_logic;
  signal delay8_q_net_x0: std_logic;
  signal delay_q_net_x0: std_logic_vector(72 downto 0);
  signal lookup_douta_net_x0: std_logic_vector(17 downto 0);
  signal lookup_doutb_net_x0: std_logic_vector(17 downto 0);
  signal mux_y_net_x2: std_logic_vector(17 downto 0);
  signal mux_y_net_x3: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x271 <= ce_1;
  clk_1_sg_x271 <= clk_1;
  concatenate_y_net_x2 <= misci;
  concat_y_net_x1 <= theta;
  cos <= mux_y_net_x2;
  misco <= delay1_q_net_x2;
  sin <= mux_y_net_x3;

  add_convert0_42f0096abc: entity work.add_convert0_entity_42f0096abc
    port map (
      ce_1 => ce_1_sg_x271,
      clk_1 => clk_1_sg_x271,
      theta => assert_dout_net_x1,
      add => convert2_dout_net_x0,
      negate => delay2_q_net_x0
    );

  add_convert1_44de86632a: entity work.add_convert1_entity_44de86632a
    port map (
      ce_1 => ce_1_sg_x271,
      clk_1 => clk_1_sg_x271,
      misci => concatenate_y_net_x2,
      theta => assert_dout_net_x1,
      add => convert2_dout_net_x1,
      misco => delay1_q_net_x0,
      negate => delay2_q_net_x1
    );

  assert_x0: entity work.xlpassthrough
    generic map (
      din_width => 4,
      dout_width => 4
    )
    port map (
      din => concat_y_net_x1,
      dout => assert_dout_net_x1
    );

  constant2: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant_x0: entity work.constant_95b0f967bc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  delay: entity work.delay_7097453b2c
    port map (
      ce => ce_1_sg_x271,
      clk => clk_1_sg_x271,
      clr => '0',
      d => delay1_q_net_x0,
      q => delay_q_net_x0
    );

  delay10: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x271,
      clk => clk_1_sg_x271,
      clr => '0',
      d(0) => delay2_q_net_x0,
      q(0) => delay10_q_net_x0
    );

  delay8: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x271,
      clk => clk_1_sg_x271,
      clr => '0',
      d(0) => delay2_q_net_x1,
      q(0) => delay8_q_net_x0
    );

  invert0_f764b7d4d8: entity work.invert0_entity_b1ffbb1c3b
    port map (
      ce_1 => ce_1_sg_x271,
      clk_1 => clk_1_sg_x271,
      in_x0 => lookup_douta_net_x0,
      negate_x0 => delay10_q_net_x0,
      out_x0 => mux_y_net_x2
    );

  invert1_2a934f9986: entity work.invert1_entity_af1af9b3de
    port map (
      ce_1 => ce_1_sg_x271,
      clk_1 => clk_1_sg_x271,
      in_x0 => lookup_doutb_net_x0,
      misci => delay_q_net_x0,
      negate_x0 => delay8_q_net_x0,
      misco => delay1_q_net_x2,
      out_x0 => mux_y_net_x3
    );

  lookup: entity work.xldpram_dist_window_and_fft_test_v4
    generic map (
      addr_width => 4,
      c_address_width => 4,
      c_width => 18,
      core_name0 => "dmg_72_28098a4ce465921e",
      latency => 2
    )
    port map (
      a_ce => ce_1_sg_x271,
      a_clk => clk_1_sg_x271,
      addra => convert2_dout_net_x0,
      addrb => convert2_dout_net_x1,
      b_ce => ce_1_sg_x271,
      b_clk => clk_1_sg_x271,
      dina => constant_op_net,
      ena => "1",
      enb => "1",
      wea(0) => constant2_op_net,
      douta => lookup_douta_net_x0,
      doutb => lookup_doutb_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_5/butterfly_direct/twiddle/coeff_gen"

entity coeff_gen_entity_81f5cc5f96 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    rst: in std_logic; 
    misco: out std_logic_vector(72 downto 0); 
    w: out std_logic_vector(35 downto 0)
  );
end coeff_gen_entity_81f5cc5f96;

architecture structural of coeff_gen_entity_81f5cc5f96 is
  signal ce_1_sg_x272: std_logic;
  signal clk_1_sg_x272: std_logic;
  signal concat_y_net_x1: std_logic_vector(3 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal mux_y_net_x1: std_logic;
  signal mux_y_net_x4: std_logic_vector(17 downto 0);
  signal mux_y_net_x5: std_logic_vector(17 downto 0);
  signal slice_y_net_x0: std_logic_vector(3 downto 0);

begin
  ce_1_sg_x272 <= ce_1;
  clk_1_sg_x272 <= clk_1;
  concatenate_y_net_x3 <= misci;
  mux_y_net_x1 <= rst;
  misco <= delay1_q_net_x3;
  w <= concat_y_net_x5;

  bit_reverse_7b1038368f: entity work.bit_reverse_entity_7b1038368f
    port map (
      in_x0 => slice_y_net_x0,
      out_x0 => concat_y_net_x1
    );

  cosin_6408c1a8ec: entity work.cosin_entity_6408c1a8ec
    port map (
      ce_1 => ce_1_sg_x272,
      clk_1 => clk_1_sg_x272,
      misci => concatenate_y_net_x3,
      theta => concat_y_net_x1,
      cos => mux_y_net_x4,
      misco => delay1_q_net_x3,
      sin => mux_y_net_x5
    );

  counter: entity work.counter_11ccef49a2
    port map (
      ce => ce_1_sg_x272,
      clk => clk_1_sg_x272,
      clr => '0',
      rst(0) => mux_y_net_x1,
      op => counter_op_net
    );

  ri_to_c_7bdd612084: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => mux_y_net_x5,
      re => mux_y_net_x4,
      c => concat_y_net_x5
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 7,
      x_width => 8,
      y_width => 4
    )
    port map (
      x => counter_op_net,
      y => slice_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_5/butterfly_direct/twiddle"

entity twiddle_entity_2b0105065d is
  port (
    ai: in std_logic_vector(35 downto 0); 
    bi: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ao: out std_logic_vector(35 downto 0); 
    bwo: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end twiddle_entity_2b0105065d;

architecture structural of twiddle_entity_2b0105065d is
  signal ce_1_sg_x273: std_logic;
  signal clk_1_sg_x273: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(37 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x3: std_logic_vector(36 downto 0);
  signal dmux0_q_net_x1: std_logic_vector(35 downto 0);
  signal mux_y_net_x2: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x2 <= ai;
  dmux0_q_net_x1 <= bi;
  ce_1_sg_x273 <= ce_1;
  clk_1_sg_x273 <= clk_1;
  mux_y_net_x2 <= sync_in;
  ao <= reinterpret1_output_port_net_x11;
  bwo <= concatenate_y_net_x7;
  sync_out <= slice2_y_net_x1;

  bus_convert_03146e1f0c: entity work.bus_convert_entity_8995348ed7
    port map (
      ce_1 => ce_1_sg_x273,
      clk_1 => clk_1_sg_x273,
      din => reinterpret1_output_port_net_x10,
      misci => dmisc_q_net_x2,
      dout => concatenate_y_net_x7,
      misco => dmisc_q_net_x3
    );

  bus_create_150ec960aa: entity work.bus_create_entity_bca4476356
    port map (
      in1 => dmux0_q_net_x1,
      in2 => mux_y_net_x2,
      in3 => reinterpret1_output_port_net_x2,
      bus_out => concatenate_y_net_x3
    );

  bus_expand1_ea28d5885a: entity work.bus_expand1_entity_94af2caf5e
    port map (
      bus_in => dmisc_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x11,
      msb_out2 => slice2_y_net_x1
    );

  bus_expand_dd2375b7a3: entity work.bus_expand_entity_0c73098dab
    port map (
      bus_in => delay1_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x9,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  bus_mult_f4f993185c: entity work.bus_mult_entity_516ba8171e
    port map (
      a => concat_y_net_x5,
      b => reinterpret2_output_port_net_x3,
      ce_1 => ce_1_sg_x273,
      clk_1 => clk_1_sg_x273,
      misci => reinterpret1_output_port_net_x9,
      a_b => reinterpret1_output_port_net_x10,
      misco => dmisc_q_net_x2
    );

  coeff_gen_81f5cc5f96: entity work.coeff_gen_entity_81f5cc5f96
    port map (
      ce_1 => ce_1_sg_x273,
      clk_1 => clk_1_sg_x273,
      misci => concatenate_y_net_x3,
      rst => mux_y_net_x2,
      misco => delay1_q_net_x3,
      w => concat_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_5/butterfly_direct"

entity butterfly_direct_entity_1e090309de is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(35 downto 0); 
    a_bw_x0: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end butterfly_direct_entity_1e090309de;

architecture structural of butterfly_direct_entity_1e090309de is
  signal ce_1_sg_x274: std_logic;
  signal clk_1_sg_x274: std_logic;
  signal concat_y_net_x3: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x11: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(83 downto 0);
  signal delay0_q_net_x0: std_logic;
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal mux_y_net_x3: std_logic;
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x3 <= a;
  dmux0_q_net_x2 <= b;
  ce_1_sg_x274 <= ce_1;
  clk_1_sg_x274 <= clk_1;
  slice0_y_net_x1 <= shift;
  mux_y_net_x3 <= sync_in;
  a_bw <= reinterpret1_output_port_net_x4;
  a_bw_x0 <= reinterpret2_output_port_net_x1;
  sync_out <= delay0_q_net_x0;

  bus_add_11e62fedb9: entity work.bus_add_entity_b1cdda5af7
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x274,
      clk_1 => clk_1_sg_x274,
      dout => concatenate_y_net_x3
    );

  bus_convert_ef59e0fcc1: entity work.bus_convert_entity_b950f53ae4
    port map (
      ce_1 => ce_1_sg_x274,
      clk_1 => clk_1_sg_x274,
      din => concatenate_y_net_x9,
      dout => concatenate_y_net_x4
    );

  bus_expand_28956b96f8: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x4,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  bus_norm0_cb0923389b: entity work.bus_norm0_entity_e7ca085468
    port map (
      ce_1 => ce_1_sg_x274,
      clk_1 => clk_1_sg_x274,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x5
    );

  bus_norm1_fb8e1e1264: entity work.bus_norm1_entity_bd510a87ea
    port map (
      ce_1 => ce_1_sg_x274,
      clk_1 => clk_1_sg_x274,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x6
    );

  bus_scale_344c71d84a: entity work.bus_scale_entity_25e603273f
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_2707b38af0: entity work.bus_sub_entity_9893acc382
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x274,
      clk_1 => clk_1_sg_x274,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_cfdc93535e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x3,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  delay0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x274,
      clk => clk_1_sg_x274,
      clr => '0',
      d(0) => slice2_y_net_x1,
      q(0) => delay0_q_net_x0
    );

  mux_15667c6e01: entity work.mux_entity_83804557c8
    port map (
      ce_1 => ce_1_sg_x274,
      clk_1 => clk_1_sg_x274,
      d0 => concatenate_y_net_x5,
      d1 => concatenate_y_net_x6,
      sel => concatenate_y_net_x10,
      out_x0 => concatenate_y_net_x9
    );

  shift_replicate_5ba95f6b8b: entity work.shift_replicate_entity_7f26e672bf
    port map (
      ce_1 => ce_1_sg_x274,
      clk_1 => clk_1_sg_x274,
      in_x0 => slice0_y_net_x1,
      out_x0 => concatenate_y_net_x10
    );

  twiddle_2b0105065d: entity work.twiddle_entity_2b0105065d
    port map (
      ai => reinterpret1_output_port_net_x3,
      bi => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x274,
      clk_1 => clk_1_sg_x274,
      sync_in => mux_y_net_x3,
      ao => reinterpret1_output_port_net_x11,
      bwo => concatenate_y_net_x11,
      sync_out => slice2_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_5/delay0"

entity delay0_entity_5d022abe3d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end delay0_entity_5d022abe3d;

architecture structural of delay0_entity_5d022abe3d is
  signal ce_1_sg_x275: std_logic;
  signal clk_1_sg_x275: std_logic;
  signal del1_q_net_x0: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x275 <= ce_1;
  clk_1_sg_x275 <= clk_1;
  din2_q_net_x1 <= din;
  dout <= reinterpret1_output_port_net_x2;

  del1: entity work.delay_3a3620b5a6
    port map (
      ce => ce_1_sg_x275,
      clk => clk_1_sg_x275,
      clr => '0',
      d => reinterpret1_output_port_net_x0,
      q => del1_q_net_x0
    );

  din_expand_6a1229de06: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => din2_q_net_x1,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  dout_compress_49c88a9433: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => del1_q_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_5/sync_delay"

entity sync_delay_entity_bc7a9ecf24 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_entity_bc7a9ecf24;

architecture structural of sync_delay_entity_bc7a9ecf24 is
  signal ce_1_sg_x277: std_logic;
  signal clk_1_sg_x277: std_logic;
  signal constant1_op_net: std_logic_vector(4 downto 0);
  signal constant2_op_net: std_logic_vector(4 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(4 downto 0);
  signal counter_op_net: std_logic_vector(4 downto 0);
  signal dsync1_q_net_x0: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x4: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x277 <= ce_1;
  clk_1_sg_x277 <= clk_1;
  dsync1_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x4;

  constant1: entity work.constant_fe72737ca0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_ef0e2e5fc6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_582a3706dd
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_9e5adb68be
    port map (
      ce => ce_1_sg_x277,
      clk => clk_1_sg_x277,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical_y_net,
      load(0) => dsync1_q_net_x0,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x4
    );

  relational: entity work.relational_9ece3c8c4e
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_dc5bc996c9
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_5"

entity fft_stage_5_entity_59ea763c91 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    out1: out std_logic_vector(35 downto 0); 
    out2: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_stage_5_entity_59ea763c91;

architecture structural of fft_stage_5_entity_59ea763c91 is
  signal ce_1_sg_x278: std_logic;
  signal clk_1_sg_x278: std_logic;
  signal counter_op_net: std_logic_vector(4 downto 0);
  signal delay0_q_net_x2: std_logic;
  signal delay0_q_net_x3: std_logic;
  signal delay11_q_net_x4: std_logic_vector(10 downto 0);
  signal din0_q_net: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal dmux1_q_net_x1: std_logic_vector(35 downto 0);
  signal dsync0_q_net: std_logic;
  signal dsync1_q_net_x0: std_logic;
  signal mux0_y_net: std_logic_vector(35 downto 0);
  signal mux1_y_net: std_logic_vector(35 downto 0);
  signal mux_y_net_x4: std_logic;
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x8: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x4: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice1_y_net: std_logic;

begin
  ce_1_sg_x278 <= ce_1;
  clk_1_sg_x278 <= clk_1;
  reinterpret2_output_port_net_x3 <= in1;
  reinterpret1_output_port_net_x7 <= in2;
  delay11_q_net_x4 <= shift;
  delay0_q_net_x2 <= sync;
  out1 <= reinterpret2_output_port_net_x4;
  out2 <= reinterpret1_output_port_net_x8;
  sync_out <= delay0_q_net_x3;

  butterfly_direct_1e090309de: entity work.butterfly_direct_entity_1e090309de
    port map (
      a => reinterpret1_output_port_net_x5,
      b => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x278,
      clk_1 => clk_1_sg_x278,
      shift => slice0_y_net_x1,
      sync_in => mux_y_net_x4,
      a_bw => reinterpret1_output_port_net_x8,
      a_bw_x0 => reinterpret2_output_port_net_x4,
      sync_out => delay0_q_net_x3
    );

  counter: entity work.counter_a2ece21d6a
    port map (
      ce => ce_1_sg_x278,
      clk => clk_1_sg_x278,
      clr => '0',
      rst(0) => dsync0_q_net,
      op => counter_op_net
    );

  delay0_5d022abe3d: entity work.delay0_entity_5d022abe3d
    port map (
      ce_1 => ce_1_sg_x278,
      clk_1 => clk_1_sg_x278,
      din => din2_q_net_x1,
      dout => reinterpret1_output_port_net_x2
    );

  delay1_41274b487c: entity work.delay0_entity_5d022abe3d
    port map (
      ce_1 => ce_1_sg_x278,
      clk_1 => clk_1_sg_x278,
      din => dmux1_q_net_x1,
      dout => reinterpret1_output_port_net_x5
    );

  din0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret2_output_port_net_x3,
      q => din0_q_net
    );

  din2: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret1_output_port_net_x7,
      q => din2_q_net_x1
    );

  dmux0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux0_y_net,
      q => dmux0_q_net_x2
    );

  dmux1: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux1_y_net,
      q => dmux1_q_net_x1
    );

  dsync0: entity work.delay_0341f7be44
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d(0) => delay0_q_net_x2,
      q(0) => dsync0_q_net
    );

  dsync1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x278,
      clk => clk_1_sg_x278,
      clr => '0',
      d(0) => dsync0_q_net,
      q(0) => dsync1_q_net_x0
    );

  mux0: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x278,
      clk => clk_1_sg_x278,
      clr => '0',
      d0 => reinterpret1_output_port_net_x2,
      d1 => din0_q_net,
      sel(0) => slice1_y_net,
      y => mux0_y_net
    );

  mux1: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x278,
      clk => clk_1_sg_x278,
      clr => '0',
      d0 => din0_q_net,
      d1 => reinterpret1_output_port_net_x2,
      sel(0) => slice1_y_net,
      y => mux1_y_net
    );

  slice0: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 4,
      x_width => 11,
      y_width => 1
    )
    port map (
      x => delay11_q_net_x4,
      y(0) => slice0_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 4,
      x_width => 5,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice1_y_net
    );

  sync_delay_bc7a9ecf24: entity work.sync_delay_entity_bc7a9ecf24
    port map (
      ce_1 => ce_1_sg_x278,
      clk_1 => clk_1_sg_x278,
      in_x0 => dsync1_q_net_x0,
      out_x0 => mux_y_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_6/butterfly_direct/twiddle/coeff_gen/bit_reverse"

entity bit_reverse_entity_36ef3e30cb is
  port (
    in_x0: in std_logic_vector(4 downto 0); 
    out_x0: out std_logic_vector(4 downto 0)
  );
end bit_reverse_entity_36ef3e30cb;

architecture structural of bit_reverse_entity_36ef3e30cb is
  signal bit0_y_net: std_logic;
  signal bit1_y_net: std_logic;
  signal bit2_y_net: std_logic;
  signal bit3_y_net: std_logic;
  signal bit4_y_net: std_logic;
  signal concat_y_net_x0: std_logic_vector(4 downto 0);
  signal slice_y_net_x0: std_logic_vector(4 downto 0);

begin
  slice_y_net_x0 <= in_x0;
  out_x0 <= concat_y_net_x0;

  bit0: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 5,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit0_y_net
    );

  bit1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 5,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit1_y_net
    );

  bit2: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 5,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit2_y_net
    );

  bit3: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 5,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit3_y_net
    );

  bit4: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 4,
      x_width => 5,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit4_y_net
    );

  concat: entity work.concat_2b3acb49f4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => bit0_y_net,
      in1(0) => bit1_y_net,
      in2(0) => bit2_y_net,
      in3(0) => bit3_y_net,
      in4(0) => bit4_y_net,
      y => concat_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_6/butterfly_direct/twiddle/coeff_gen/cosin/add_convert0"

entity add_convert0_entity_4384bf9636 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    theta: in std_logic_vector(4 downto 0); 
    add: out std_logic_vector(4 downto 0); 
    negate: out std_logic
  );
end add_convert0_entity_4384bf9636;

architecture structural of add_convert0_entity_4384bf9636 is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x0: std_logic_vector(4 downto 0);
  signal ce_1_sg_x305: std_logic;
  signal clk_1_sg_x305: std_logic;
  signal concat_y_net: std_logic_vector(5 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(4 downto 0);
  signal delay13_q_net: std_logic_vector(4 downto 0);
  signal delay14_q_net: std_logic_vector(4 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(5 downto 0);
  signal invert_y_net: std_logic;
  signal lookup_y_net: std_logic_vector(3 downto 0);
  signal new_add_y_net: std_logic_vector(4 downto 0);
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x305 <= ce_1;
  clk_1_sg_x305 <= clk_1;
  assert_dout_net_x0 <= theta;
  add <= convert2_dout_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x305,
      clk => clk_1_sg_x305,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  concat: entity work.concat_ae3f02567e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => addsub5_s_net,
      in1 => lookup_y_net,
      y => concat_y_net
    );

  convert2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 5,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 5,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x305,
      clk => clk_1_sg_x305,
      clr => '0',
      din => delay13_q_net,
      en => "1",
      dout => convert2_dout_net_x0
    );

  delay13: entity work.delay_38f665f8aa
    port map (
      ce => ce_1_sg_x305,
      clk => clk_1_sg_x305,
      clr => '0',
      d => delay14_q_net,
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 5
    )
    port map (
      ce => ce_1_sg_x305,
      clk => clk_1_sg_x305,
      d => new_add_y_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x305,
      clk => clk_1_sg_x305,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_ac785d9b37
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x0,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  lookup: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 3,
      x_width => 6,
      y_width => 4
    )
    port map (
      x => fluff_y_net,
      y => lookup_y_net
    );

  new_add: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 4,
      x_width => 6,
      y_width => 5
    )
    port map (
      x => concat_y_net,
      y => new_add_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 5,
      x_width => 6,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_6/butterfly_direct/twiddle/coeff_gen/cosin/add_convert1"

entity add_convert1_entity_35e18fd6db is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(4 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    negate: out std_logic
  );
end add_convert1_entity_35e18fd6db;

architecture structural of add_convert1_entity_35e18fd6db is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x1: std_logic_vector(4 downto 0);
  signal ce_1_sg_x306: std_logic;
  signal clk_1_sg_x306: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(72 downto 0);
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(5 downto 0);
  signal invert_y_net: std_logic;
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x306 <= ce_1;
  clk_1_sg_x306 <= clk_1;
  concatenate_y_net_x1 <= misci;
  assert_dout_net_x1 <= theta;
  misco <= delay1_q_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x306,
      clk => clk_1_sg_x306,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  delay1: entity work.delay_4e967fa4b7
    port map (
      ce => ce_1_sg_x306,
      clk => clk_1_sg_x306,
      clr => '0',
      d => concatenate_y_net_x1,
      q => delay1_q_net_x0
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x306,
      clk => clk_1_sg_x306,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_ac785d9b37
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x1,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 5,
      x_width => 6,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_6/butterfly_direct/twiddle/coeff_gen/cosin/c_to_ri"

entity c_to_ri_entity_27418540ef is
  port (
    c: in std_logic_vector(35 downto 0); 
    im: out std_logic_vector(17 downto 0); 
    re: out std_logic_vector(17 downto 0)
  );
end c_to_ri_entity_27418540ef;

architecture structural of c_to_ri_entity_27418540ef is
  signal force_im_output_port_net_x0: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(17 downto 0);
  signal rom_data_net_x0: std_logic_vector(35 downto 0);
  signal slice_im_y_net: std_logic_vector(17 downto 0);
  signal slice_re_y_net: std_logic_vector(17 downto 0);

begin
  rom_data_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => rom_data_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 35,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => rom_data_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_6/butterfly_direct/twiddle/coeff_gen/cosin"

entity cosin_entity_760f324305 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(4 downto 0); 
    cos: out std_logic_vector(17 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    sin: out std_logic_vector(17 downto 0)
  );
end cosin_entity_760f324305;

architecture structural of cosin_entity_760f324305 is
  signal assert_dout_net_x1: std_logic_vector(4 downto 0);
  signal ce_1_sg_x309: std_logic;
  signal clk_1_sg_x309: std_logic;
  signal concat_y_net_x1: std_logic_vector(4 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(72 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(4 downto 0);
  signal delay10_q_net_x0: std_logic;
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay1_q_net_x2: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal delay2_q_net_x1: std_logic;
  signal delay8_q_net_x0: std_logic;
  signal delay_q_net_x0: std_logic_vector(72 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(17 downto 0);
  signal mux_y_net_x2: std_logic_vector(17 downto 0);
  signal mux_y_net_x3: std_logic_vector(17 downto 0);
  signal rom_data_net_x0: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x309 <= ce_1;
  clk_1_sg_x309 <= clk_1;
  concatenate_y_net_x2 <= misci;
  concat_y_net_x1 <= theta;
  cos <= mux_y_net_x2;
  misco <= delay1_q_net_x2;
  sin <= mux_y_net_x3;

  add_convert0_4384bf9636: entity work.add_convert0_entity_4384bf9636
    port map (
      ce_1 => ce_1_sg_x309,
      clk_1 => clk_1_sg_x309,
      theta => assert_dout_net_x1,
      add => convert2_dout_net_x0,
      negate => delay2_q_net_x0
    );

  add_convert1_35e18fd6db: entity work.add_convert1_entity_35e18fd6db
    port map (
      ce_1 => ce_1_sg_x309,
      clk_1 => clk_1_sg_x309,
      misci => concatenate_y_net_x2,
      theta => assert_dout_net_x1,
      misco => delay1_q_net_x0,
      negate => delay2_q_net_x1
    );

  assert_x0: entity work.xlpassthrough
    generic map (
      din_width => 5,
      dout_width => 5
    )
    port map (
      din => concat_y_net_x1,
      dout => assert_dout_net_x1
    );

  c_to_ri_27418540ef: entity work.c_to_ri_entity_27418540ef
    port map (
      c => rom_data_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  delay: entity work.delay_7097453b2c
    port map (
      ce => ce_1_sg_x309,
      clk => clk_1_sg_x309,
      clr => '0',
      d => delay1_q_net_x0,
      q => delay_q_net_x0
    );

  delay10: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x309,
      clk => clk_1_sg_x309,
      clr => '0',
      d(0) => delay2_q_net_x0,
      q(0) => delay10_q_net_x0
    );

  delay8: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x309,
      clk => clk_1_sg_x309,
      clr => '0',
      d(0) => delay2_q_net_x1,
      q(0) => delay8_q_net_x0
    );

  invert0_2e440d68f1: entity work.invert0_entity_b1ffbb1c3b
    port map (
      ce_1 => ce_1_sg_x309,
      clk_1 => clk_1_sg_x309,
      in_x0 => force_re_output_port_net_x1,
      negate_x0 => delay10_q_net_x0,
      out_x0 => mux_y_net_x2
    );

  invert1_8de49418a8: entity work.invert1_entity_af1af9b3de
    port map (
      ce_1 => ce_1_sg_x309,
      clk_1 => clk_1_sg_x309,
      in_x0 => force_im_output_port_net_x1,
      misci => delay_q_net_x0,
      negate_x0 => delay8_q_net_x0,
      misco => delay1_q_net_x2,
      out_x0 => mux_y_net_x3
    );

  rom: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 5,
      c_width => 36,
      core_name0 => "bmg_72_a6d704d36eb848a5",
      latency => 1
    )
    port map (
      addr => convert2_dout_net_x0,
      ce => ce_1_sg_x309,
      clk => clk_1_sg_x309,
      en => "1",
      rst => "0",
      data => rom_data_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_6/butterfly_direct/twiddle/coeff_gen"

entity coeff_gen_entity_057102c93a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    rst: in std_logic; 
    misco: out std_logic_vector(72 downto 0); 
    w: out std_logic_vector(35 downto 0)
  );
end coeff_gen_entity_057102c93a;

architecture structural of coeff_gen_entity_057102c93a is
  signal ce_1_sg_x310: std_logic;
  signal clk_1_sg_x310: std_logic;
  signal concat_y_net_x1: std_logic_vector(4 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal mux_y_net_x1: std_logic;
  signal mux_y_net_x4: std_logic_vector(17 downto 0);
  signal mux_y_net_x5: std_logic_vector(17 downto 0);
  signal slice_y_net_x0: std_logic_vector(4 downto 0);

begin
  ce_1_sg_x310 <= ce_1;
  clk_1_sg_x310 <= clk_1;
  concatenate_y_net_x3 <= misci;
  mux_y_net_x1 <= rst;
  misco <= delay1_q_net_x3;
  w <= concat_y_net_x5;

  bit_reverse_36ef3e30cb: entity work.bit_reverse_entity_36ef3e30cb
    port map (
      in_x0 => slice_y_net_x0,
      out_x0 => concat_y_net_x1
    );

  cosin_760f324305: entity work.cosin_entity_760f324305
    port map (
      ce_1 => ce_1_sg_x310,
      clk_1 => clk_1_sg_x310,
      misci => concatenate_y_net_x3,
      theta => concat_y_net_x1,
      cos => mux_y_net_x4,
      misco => delay1_q_net_x3,
      sin => mux_y_net_x5
    );

  counter: entity work.counter_11ccef49a2
    port map (
      ce => ce_1_sg_x310,
      clk => clk_1_sg_x310,
      clr => '0',
      rst(0) => mux_y_net_x1,
      op => counter_op_net
    );

  ri_to_c_bbbff0cb0a: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => mux_y_net_x5,
      re => mux_y_net_x4,
      c => concat_y_net_x5
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 7,
      x_width => 8,
      y_width => 5
    )
    port map (
      x => counter_op_net,
      y => slice_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_6/butterfly_direct/twiddle"

entity twiddle_entity_dc0873997e is
  port (
    ai: in std_logic_vector(35 downto 0); 
    bi: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ao: out std_logic_vector(35 downto 0); 
    bwo: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end twiddle_entity_dc0873997e;

architecture structural of twiddle_entity_dc0873997e is
  signal ce_1_sg_x311: std_logic;
  signal clk_1_sg_x311: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(37 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x3: std_logic_vector(36 downto 0);
  signal dmux0_q_net_x1: std_logic_vector(35 downto 0);
  signal mux_y_net_x2: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x2 <= ai;
  dmux0_q_net_x1 <= bi;
  ce_1_sg_x311 <= ce_1;
  clk_1_sg_x311 <= clk_1;
  mux_y_net_x2 <= sync_in;
  ao <= reinterpret1_output_port_net_x11;
  bwo <= concatenate_y_net_x7;
  sync_out <= slice2_y_net_x1;

  bus_convert_9d23a49da5: entity work.bus_convert_entity_8995348ed7
    port map (
      ce_1 => ce_1_sg_x311,
      clk_1 => clk_1_sg_x311,
      din => reinterpret1_output_port_net_x10,
      misci => dmisc_q_net_x2,
      dout => concatenate_y_net_x7,
      misco => dmisc_q_net_x3
    );

  bus_create_9429e3ed42: entity work.bus_create_entity_bca4476356
    port map (
      in1 => dmux0_q_net_x1,
      in2 => mux_y_net_x2,
      in3 => reinterpret1_output_port_net_x2,
      bus_out => concatenate_y_net_x3
    );

  bus_expand1_ac8c1db053: entity work.bus_expand1_entity_94af2caf5e
    port map (
      bus_in => dmisc_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x11,
      msb_out2 => slice2_y_net_x1
    );

  bus_expand_8ef3f5ea23: entity work.bus_expand_entity_0c73098dab
    port map (
      bus_in => delay1_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x9,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  bus_mult_714cae3340: entity work.bus_mult_entity_516ba8171e
    port map (
      a => concat_y_net_x5,
      b => reinterpret2_output_port_net_x3,
      ce_1 => ce_1_sg_x311,
      clk_1 => clk_1_sg_x311,
      misci => reinterpret1_output_port_net_x9,
      a_b => reinterpret1_output_port_net_x10,
      misco => dmisc_q_net_x2
    );

  coeff_gen_057102c93a: entity work.coeff_gen_entity_057102c93a
    port map (
      ce_1 => ce_1_sg_x311,
      clk_1 => clk_1_sg_x311,
      misci => concatenate_y_net_x3,
      rst => mux_y_net_x2,
      misco => delay1_q_net_x3,
      w => concat_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_6/butterfly_direct"

entity butterfly_direct_entity_bfd65c4e7e is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(35 downto 0); 
    a_bw_x0: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end butterfly_direct_entity_bfd65c4e7e;

architecture structural of butterfly_direct_entity_bfd65c4e7e is
  signal ce_1_sg_x312: std_logic;
  signal clk_1_sg_x312: std_logic;
  signal concat_y_net_x3: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x11: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(83 downto 0);
  signal delay0_q_net_x0: std_logic;
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal mux_y_net_x3: std_logic;
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x3 <= a;
  dmux0_q_net_x2 <= b;
  ce_1_sg_x312 <= ce_1;
  clk_1_sg_x312 <= clk_1;
  slice0_y_net_x1 <= shift;
  mux_y_net_x3 <= sync_in;
  a_bw <= reinterpret1_output_port_net_x4;
  a_bw_x0 <= reinterpret2_output_port_net_x1;
  sync_out <= delay0_q_net_x0;

  bus_add_01cce605c6: entity work.bus_add_entity_b1cdda5af7
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x312,
      clk_1 => clk_1_sg_x312,
      dout => concatenate_y_net_x3
    );

  bus_convert_b5cd07b2c7: entity work.bus_convert_entity_b950f53ae4
    port map (
      ce_1 => ce_1_sg_x312,
      clk_1 => clk_1_sg_x312,
      din => concatenate_y_net_x9,
      dout => concatenate_y_net_x4
    );

  bus_expand_5a746f256d: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x4,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  bus_norm0_52154a7e5f: entity work.bus_norm0_entity_e7ca085468
    port map (
      ce_1 => ce_1_sg_x312,
      clk_1 => clk_1_sg_x312,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x5
    );

  bus_norm1_98151e83b5: entity work.bus_norm1_entity_bd510a87ea
    port map (
      ce_1 => ce_1_sg_x312,
      clk_1 => clk_1_sg_x312,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x6
    );

  bus_scale_e49d055cf8: entity work.bus_scale_entity_25e603273f
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_74b931da82: entity work.bus_sub_entity_9893acc382
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x312,
      clk_1 => clk_1_sg_x312,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_cfdc93535e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x3,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  delay0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x312,
      clk => clk_1_sg_x312,
      clr => '0',
      d(0) => slice2_y_net_x1,
      q(0) => delay0_q_net_x0
    );

  mux_fb6a855b7a: entity work.mux_entity_83804557c8
    port map (
      ce_1 => ce_1_sg_x312,
      clk_1 => clk_1_sg_x312,
      d0 => concatenate_y_net_x5,
      d1 => concatenate_y_net_x6,
      sel => concatenate_y_net_x10,
      out_x0 => concatenate_y_net_x9
    );

  shift_replicate_7dbd17b250: entity work.shift_replicate_entity_7f26e672bf
    port map (
      ce_1 => ce_1_sg_x312,
      clk_1 => clk_1_sg_x312,
      in_x0 => slice0_y_net_x1,
      out_x0 => concatenate_y_net_x10
    );

  twiddle_dc0873997e: entity work.twiddle_entity_dc0873997e
    port map (
      ai => reinterpret1_output_port_net_x3,
      bi => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x312,
      clk_1 => clk_1_sg_x312,
      sync_in => mux_y_net_x3,
      ao => reinterpret1_output_port_net_x11,
      bwo => concatenate_y_net_x11,
      sync_out => slice2_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_6/delay0"

entity delay0_entity_5ec300e21a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end delay0_entity_5ec300e21a;

architecture structural of delay0_entity_5ec300e21a is
  signal ce_1_sg_x313: std_logic;
  signal clk_1_sg_x313: std_logic;
  signal del1_q_net_x0: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x313 <= ce_1;
  clk_1_sg_x313 <= clk_1;
  din2_q_net_x1 <= din;
  dout <= reinterpret1_output_port_net_x2;

  del1: entity work.delay_faa52967c8
    port map (
      ce => ce_1_sg_x313,
      clk => clk_1_sg_x313,
      clr => '0',
      d => reinterpret1_output_port_net_x0,
      q => del1_q_net_x0
    );

  din_expand_e8c1a2ef63: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => din2_q_net_x1,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  dout_compress_6c3df1c514: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => del1_q_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_6/sync_delay"

entity sync_delay_entity_febbdffcb7 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_entity_febbdffcb7;

architecture structural of sync_delay_entity_febbdffcb7 is
  signal ce_1_sg_x315: std_logic;
  signal clk_1_sg_x315: std_logic;
  signal constant1_op_net: std_logic_vector(3 downto 0);
  signal constant2_op_net: std_logic_vector(3 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(3 downto 0);
  signal counter_op_net: std_logic_vector(3 downto 0);
  signal dsync1_q_net_x0: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x4: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x315 <= ce_1;
  clk_1_sg_x315 <= clk_1;
  dsync1_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x4;

  constant1: entity work.constant_4c449dd556
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_145086465d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_67ad97ca70
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_230536be32
    port map (
      ce => ce_1_sg_x315,
      clk => clk_1_sg_x315,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical_y_net,
      load(0) => dsync1_q_net_x0,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x4
    );

  relational: entity work.relational_4d3cfceaf4
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_d930162434
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_6"

entity fft_stage_6_entity_d40c47c187 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    out1: out std_logic_vector(35 downto 0); 
    out2: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_stage_6_entity_d40c47c187;

architecture structural of fft_stage_6_entity_d40c47c187 is
  signal ce_1_sg_x316: std_logic;
  signal clk_1_sg_x316: std_logic;
  signal counter_op_net: std_logic_vector(3 downto 0);
  signal delay0_q_net_x4: std_logic;
  signal delay0_q_net_x5: std_logic;
  signal delay11_q_net_x5: std_logic_vector(10 downto 0);
  signal din0_q_net: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal dmux1_q_net_x1: std_logic_vector(35 downto 0);
  signal dsync0_q_net: std_logic;
  signal dsync1_q_net_x0: std_logic;
  signal mux0_y_net: std_logic_vector(35 downto 0);
  signal mux1_y_net: std_logic_vector(35 downto 0);
  signal mux_y_net_x4: std_logic;
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x6: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice1_y_net: std_logic;

begin
  ce_1_sg_x316 <= ce_1;
  clk_1_sg_x316 <= clk_1;
  reinterpret2_output_port_net_x5 <= in1;
  reinterpret1_output_port_net_x9 <= in2;
  delay11_q_net_x5 <= shift;
  delay0_q_net_x4 <= sync;
  out1 <= reinterpret2_output_port_net_x6;
  out2 <= reinterpret1_output_port_net_x6;
  sync_out <= delay0_q_net_x5;

  butterfly_direct_bfd65c4e7e: entity work.butterfly_direct_entity_bfd65c4e7e
    port map (
      a => reinterpret1_output_port_net_x5,
      b => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x316,
      clk_1 => clk_1_sg_x316,
      shift => slice0_y_net_x1,
      sync_in => mux_y_net_x4,
      a_bw => reinterpret1_output_port_net_x6,
      a_bw_x0 => reinterpret2_output_port_net_x6,
      sync_out => delay0_q_net_x5
    );

  counter: entity work.counter_6068817c97
    port map (
      ce => ce_1_sg_x316,
      clk => clk_1_sg_x316,
      clr => '0',
      rst(0) => dsync0_q_net,
      op => counter_op_net
    );

  delay0_5ec300e21a: entity work.delay0_entity_5ec300e21a
    port map (
      ce_1 => ce_1_sg_x316,
      clk_1 => clk_1_sg_x316,
      din => din2_q_net_x1,
      dout => reinterpret1_output_port_net_x2
    );

  delay1_e58f894f9a: entity work.delay0_entity_5ec300e21a
    port map (
      ce_1 => ce_1_sg_x316,
      clk_1 => clk_1_sg_x316,
      din => dmux1_q_net_x1,
      dout => reinterpret1_output_port_net_x5
    );

  din0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret2_output_port_net_x5,
      q => din0_q_net
    );

  din2: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret1_output_port_net_x9,
      q => din2_q_net_x1
    );

  dmux0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux0_y_net,
      q => dmux0_q_net_x2
    );

  dmux1: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux1_y_net,
      q => dmux1_q_net_x1
    );

  dsync0: entity work.delay_0341f7be44
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d(0) => delay0_q_net_x4,
      q(0) => dsync0_q_net
    );

  dsync1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x316,
      clk => clk_1_sg_x316,
      clr => '0',
      d(0) => dsync0_q_net,
      q(0) => dsync1_q_net_x0
    );

  mux0: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x316,
      clk => clk_1_sg_x316,
      clr => '0',
      d0 => reinterpret1_output_port_net_x2,
      d1 => din0_q_net,
      sel(0) => slice1_y_net,
      y => mux0_y_net
    );

  mux1: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x316,
      clk => clk_1_sg_x316,
      clr => '0',
      d0 => din0_q_net,
      d1 => reinterpret1_output_port_net_x2,
      sel(0) => slice1_y_net,
      y => mux1_y_net
    );

  slice0: entity work.xlslice
    generic map (
      new_lsb => 5,
      new_msb => 5,
      x_width => 11,
      y_width => 1
    )
    port map (
      x => delay11_q_net_x5,
      y(0) => slice0_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice1_y_net
    );

  sync_delay_febbdffcb7: entity work.sync_delay_entity_febbdffcb7
    port map (
      ce_1 => ce_1_sg_x316,
      clk_1 => clk_1_sg_x316,
      in_x0 => dsync1_q_net_x0,
      out_x0 => mux_y_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_7/butterfly_direct/twiddle/coeff_gen/bit_reverse"

entity bit_reverse_entity_6ad8391260 is
  port (
    in_x0: in std_logic_vector(5 downto 0); 
    out_x0: out std_logic_vector(5 downto 0)
  );
end bit_reverse_entity_6ad8391260;

architecture structural of bit_reverse_entity_6ad8391260 is
  signal bit0_y_net: std_logic;
  signal bit1_y_net: std_logic;
  signal bit2_y_net: std_logic;
  signal bit3_y_net: std_logic;
  signal bit4_y_net: std_logic;
  signal bit5_y_net: std_logic;
  signal concat_y_net_x0: std_logic_vector(5 downto 0);
  signal slice_y_net_x0: std_logic_vector(5 downto 0);

begin
  slice_y_net_x0 <= in_x0;
  out_x0 <= concat_y_net_x0;

  bit0: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 6,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit0_y_net
    );

  bit1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 6,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit1_y_net
    );

  bit2: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 6,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit2_y_net
    );

  bit3: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 6,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit3_y_net
    );

  bit4: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 4,
      x_width => 6,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit4_y_net
    );

  bit5: entity work.xlslice
    generic map (
      new_lsb => 5,
      new_msb => 5,
      x_width => 6,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit5_y_net
    );

  concat: entity work.concat_2dc093ca7a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => bit0_y_net,
      in1(0) => bit1_y_net,
      in2(0) => bit2_y_net,
      in3(0) => bit3_y_net,
      in4(0) => bit4_y_net,
      in5(0) => bit5_y_net,
      y => concat_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_7/butterfly_direct/twiddle/coeff_gen/cosin/add_convert0"

entity add_convert0_entity_89c7c7abb2 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    theta: in std_logic_vector(5 downto 0); 
    add: out std_logic_vector(5 downto 0); 
    negate: out std_logic
  );
end add_convert0_entity_89c7c7abb2;

architecture structural of add_convert0_entity_89c7c7abb2 is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x0: std_logic_vector(5 downto 0);
  signal ce_1_sg_x343: std_logic;
  signal clk_1_sg_x343: std_logic;
  signal concat_y_net: std_logic_vector(6 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(5 downto 0);
  signal delay13_q_net: std_logic_vector(5 downto 0);
  signal delay14_q_net: std_logic_vector(5 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(6 downto 0);
  signal invert_y_net: std_logic;
  signal lookup_y_net: std_logic_vector(4 downto 0);
  signal new_add_y_net: std_logic_vector(5 downto 0);
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x343 <= ce_1;
  clk_1_sg_x343 <= clk_1;
  assert_dout_net_x0 <= theta;
  add <= convert2_dout_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x343,
      clk => clk_1_sg_x343,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  concat: entity work.concat_75261c7c53
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => addsub5_s_net,
      in1 => lookup_y_net,
      y => concat_y_net
    );

  convert2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 6,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 6,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x343,
      clk => clk_1_sg_x343,
      clr => '0',
      din => delay13_q_net,
      en => "1",
      dout => convert2_dout_net_x0
    );

  delay13: entity work.delay_da3bb0b159
    port map (
      ce => ce_1_sg_x343,
      clk => clk_1_sg_x343,
      clr => '0',
      d => delay14_q_net,
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 6
    )
    port map (
      ce => ce_1_sg_x343,
      clk => clk_1_sg_x343,
      d => new_add_y_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x343,
      clk => clk_1_sg_x343,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_c6a9b6687e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x0,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  lookup: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 4,
      x_width => 7,
      y_width => 5
    )
    port map (
      x => fluff_y_net,
      y => lookup_y_net
    );

  new_add: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 5,
      x_width => 7,
      y_width => 6
    )
    port map (
      x => concat_y_net,
      y => new_add_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 5,
      new_msb => 6,
      x_width => 7,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_7/butterfly_direct/twiddle/coeff_gen/cosin/add_convert1"

entity add_convert1_entity_dc54f0c200 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(5 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    negate: out std_logic
  );
end add_convert1_entity_dc54f0c200;

architecture structural of add_convert1_entity_dc54f0c200 is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x1: std_logic_vector(5 downto 0);
  signal ce_1_sg_x344: std_logic;
  signal clk_1_sg_x344: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(72 downto 0);
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(6 downto 0);
  signal invert_y_net: std_logic;
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x344 <= ce_1;
  clk_1_sg_x344 <= clk_1;
  concatenate_y_net_x1 <= misci;
  assert_dout_net_x1 <= theta;
  misco <= delay1_q_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x344,
      clk => clk_1_sg_x344,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  delay1: entity work.delay_4e967fa4b7
    port map (
      ce => ce_1_sg_x344,
      clk => clk_1_sg_x344,
      clr => '0',
      d => concatenate_y_net_x1,
      q => delay1_q_net_x0
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x344,
      clk => clk_1_sg_x344,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_c6a9b6687e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x1,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 5,
      new_msb => 6,
      x_width => 7,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_7/butterfly_direct/twiddle/coeff_gen/cosin"

entity cosin_entity_f904571ae6 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(5 downto 0); 
    cos: out std_logic_vector(17 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    sin: out std_logic_vector(17 downto 0)
  );
end cosin_entity_f904571ae6;

architecture structural of cosin_entity_f904571ae6 is
  signal assert_dout_net_x1: std_logic_vector(5 downto 0);
  signal ce_1_sg_x347: std_logic;
  signal clk_1_sg_x347: std_logic;
  signal concat_y_net_x1: std_logic_vector(5 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(72 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(5 downto 0);
  signal delay10_q_net_x0: std_logic;
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay1_q_net_x2: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal delay2_q_net_x1: std_logic;
  signal delay8_q_net_x0: std_logic;
  signal delay_q_net_x0: std_logic_vector(72 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(17 downto 0);
  signal mux_y_net_x2: std_logic_vector(17 downto 0);
  signal mux_y_net_x3: std_logic_vector(17 downto 0);
  signal rom_data_net_x0: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x347 <= ce_1;
  clk_1_sg_x347 <= clk_1;
  concatenate_y_net_x2 <= misci;
  concat_y_net_x1 <= theta;
  cos <= mux_y_net_x2;
  misco <= delay1_q_net_x2;
  sin <= mux_y_net_x3;

  add_convert0_89c7c7abb2: entity work.add_convert0_entity_89c7c7abb2
    port map (
      ce_1 => ce_1_sg_x347,
      clk_1 => clk_1_sg_x347,
      theta => assert_dout_net_x1,
      add => convert2_dout_net_x0,
      negate => delay2_q_net_x0
    );

  add_convert1_dc54f0c200: entity work.add_convert1_entity_dc54f0c200
    port map (
      ce_1 => ce_1_sg_x347,
      clk_1 => clk_1_sg_x347,
      misci => concatenate_y_net_x2,
      theta => assert_dout_net_x1,
      misco => delay1_q_net_x0,
      negate => delay2_q_net_x1
    );

  assert_x0: entity work.xlpassthrough
    generic map (
      din_width => 6,
      dout_width => 6
    )
    port map (
      din => concat_y_net_x1,
      dout => assert_dout_net_x1
    );

  c_to_ri_fab80da1c7: entity work.c_to_ri_entity_27418540ef
    port map (
      c => rom_data_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  delay: entity work.delay_7097453b2c
    port map (
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      d => delay1_q_net_x0,
      q => delay_q_net_x0
    );

  delay10: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      d(0) => delay2_q_net_x0,
      q(0) => delay10_q_net_x0
    );

  delay8: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      d(0) => delay2_q_net_x1,
      q(0) => delay8_q_net_x0
    );

  invert0_0dc4d745b1: entity work.invert0_entity_b1ffbb1c3b
    port map (
      ce_1 => ce_1_sg_x347,
      clk_1 => clk_1_sg_x347,
      in_x0 => force_re_output_port_net_x1,
      negate_x0 => delay10_q_net_x0,
      out_x0 => mux_y_net_x2
    );

  invert1_3eeb6d72df: entity work.invert1_entity_af1af9b3de
    port map (
      ce_1 => ce_1_sg_x347,
      clk_1 => clk_1_sg_x347,
      in_x0 => force_im_output_port_net_x1,
      misci => delay_q_net_x0,
      negate_x0 => delay8_q_net_x0,
      misco => delay1_q_net_x2,
      out_x0 => mux_y_net_x3
    );

  rom: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 6,
      c_width => 36,
      core_name0 => "bmg_72_b3a5d690118dc305",
      latency => 1
    )
    port map (
      addr => convert2_dout_net_x0,
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      en => "1",
      rst => "0",
      data => rom_data_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_7/butterfly_direct/twiddle/coeff_gen"

entity coeff_gen_entity_0bae10a195 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    rst: in std_logic; 
    misco: out std_logic_vector(72 downto 0); 
    w: out std_logic_vector(35 downto 0)
  );
end coeff_gen_entity_0bae10a195;

architecture structural of coeff_gen_entity_0bae10a195 is
  signal ce_1_sg_x348: std_logic;
  signal clk_1_sg_x348: std_logic;
  signal concat_y_net_x1: std_logic_vector(5 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal mux_y_net_x1: std_logic;
  signal mux_y_net_x4: std_logic_vector(17 downto 0);
  signal mux_y_net_x5: std_logic_vector(17 downto 0);
  signal slice_y_net_x0: std_logic_vector(5 downto 0);

begin
  ce_1_sg_x348 <= ce_1;
  clk_1_sg_x348 <= clk_1;
  concatenate_y_net_x3 <= misci;
  mux_y_net_x1 <= rst;
  misco <= delay1_q_net_x3;
  w <= concat_y_net_x5;

  bit_reverse_6ad8391260: entity work.bit_reverse_entity_6ad8391260
    port map (
      in_x0 => slice_y_net_x0,
      out_x0 => concat_y_net_x1
    );

  cosin_f904571ae6: entity work.cosin_entity_f904571ae6
    port map (
      ce_1 => ce_1_sg_x348,
      clk_1 => clk_1_sg_x348,
      misci => concatenate_y_net_x3,
      theta => concat_y_net_x1,
      cos => mux_y_net_x4,
      misco => delay1_q_net_x3,
      sin => mux_y_net_x5
    );

  counter: entity work.counter_11ccef49a2
    port map (
      ce => ce_1_sg_x348,
      clk => clk_1_sg_x348,
      clr => '0',
      rst(0) => mux_y_net_x1,
      op => counter_op_net
    );

  ri_to_c_f3affca60c: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => mux_y_net_x5,
      re => mux_y_net_x4,
      c => concat_y_net_x5
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 7,
      x_width => 8,
      y_width => 6
    )
    port map (
      x => counter_op_net,
      y => slice_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_7/butterfly_direct/twiddle"

entity twiddle_entity_420b4158b4 is
  port (
    ai: in std_logic_vector(35 downto 0); 
    bi: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ao: out std_logic_vector(35 downto 0); 
    bwo: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end twiddle_entity_420b4158b4;

architecture structural of twiddle_entity_420b4158b4 is
  signal ce_1_sg_x349: std_logic;
  signal clk_1_sg_x349: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(37 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x3: std_logic_vector(36 downto 0);
  signal dmux0_q_net_x1: std_logic_vector(35 downto 0);
  signal mux_y_net_x2: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x2 <= ai;
  dmux0_q_net_x1 <= bi;
  ce_1_sg_x349 <= ce_1;
  clk_1_sg_x349 <= clk_1;
  mux_y_net_x2 <= sync_in;
  ao <= reinterpret1_output_port_net_x11;
  bwo <= concatenate_y_net_x7;
  sync_out <= slice2_y_net_x1;

  bus_convert_476e71a261: entity work.bus_convert_entity_8995348ed7
    port map (
      ce_1 => ce_1_sg_x349,
      clk_1 => clk_1_sg_x349,
      din => reinterpret1_output_port_net_x10,
      misci => dmisc_q_net_x2,
      dout => concatenate_y_net_x7,
      misco => dmisc_q_net_x3
    );

  bus_create_d0eae4f599: entity work.bus_create_entity_bca4476356
    port map (
      in1 => dmux0_q_net_x1,
      in2 => mux_y_net_x2,
      in3 => reinterpret1_output_port_net_x2,
      bus_out => concatenate_y_net_x3
    );

  bus_expand1_9f84027286: entity work.bus_expand1_entity_94af2caf5e
    port map (
      bus_in => dmisc_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x11,
      msb_out2 => slice2_y_net_x1
    );

  bus_expand_a3222c68d4: entity work.bus_expand_entity_0c73098dab
    port map (
      bus_in => delay1_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x9,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  bus_mult_0afcefb3dd: entity work.bus_mult_entity_516ba8171e
    port map (
      a => concat_y_net_x5,
      b => reinterpret2_output_port_net_x3,
      ce_1 => ce_1_sg_x349,
      clk_1 => clk_1_sg_x349,
      misci => reinterpret1_output_port_net_x9,
      a_b => reinterpret1_output_port_net_x10,
      misco => dmisc_q_net_x2
    );

  coeff_gen_0bae10a195: entity work.coeff_gen_entity_0bae10a195
    port map (
      ce_1 => ce_1_sg_x349,
      clk_1 => clk_1_sg_x349,
      misci => concatenate_y_net_x3,
      rst => mux_y_net_x2,
      misco => delay1_q_net_x3,
      w => concat_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_7/butterfly_direct"

entity butterfly_direct_entity_f9c91ad558 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(35 downto 0); 
    a_bw_x0: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end butterfly_direct_entity_f9c91ad558;

architecture structural of butterfly_direct_entity_f9c91ad558 is
  signal ce_1_sg_x350: std_logic;
  signal clk_1_sg_x350: std_logic;
  signal concat_y_net_x3: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x11: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(83 downto 0);
  signal delay0_q_net_x0: std_logic;
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal mux_y_net_x3: std_logic;
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x3 <= a;
  dmux0_q_net_x2 <= b;
  ce_1_sg_x350 <= ce_1;
  clk_1_sg_x350 <= clk_1;
  slice0_y_net_x1 <= shift;
  mux_y_net_x3 <= sync_in;
  a_bw <= reinterpret1_output_port_net_x4;
  a_bw_x0 <= reinterpret2_output_port_net_x1;
  sync_out <= delay0_q_net_x0;

  bus_add_8f44f99b82: entity work.bus_add_entity_b1cdda5af7
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x350,
      clk_1 => clk_1_sg_x350,
      dout => concatenate_y_net_x3
    );

  bus_convert_c72f6ef626: entity work.bus_convert_entity_b950f53ae4
    port map (
      ce_1 => ce_1_sg_x350,
      clk_1 => clk_1_sg_x350,
      din => concatenate_y_net_x9,
      dout => concatenate_y_net_x4
    );

  bus_expand_3d9f271875: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x4,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  bus_norm0_952e8e4b33: entity work.bus_norm0_entity_e7ca085468
    port map (
      ce_1 => ce_1_sg_x350,
      clk_1 => clk_1_sg_x350,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x5
    );

  bus_norm1_cee3736229: entity work.bus_norm1_entity_bd510a87ea
    port map (
      ce_1 => ce_1_sg_x350,
      clk_1 => clk_1_sg_x350,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x6
    );

  bus_scale_ed5393f567: entity work.bus_scale_entity_25e603273f
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_c3b68f44cf: entity work.bus_sub_entity_9893acc382
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x350,
      clk_1 => clk_1_sg_x350,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_cfdc93535e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x3,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  delay0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x350,
      clk => clk_1_sg_x350,
      clr => '0',
      d(0) => slice2_y_net_x1,
      q(0) => delay0_q_net_x0
    );

  mux_2fc429dded: entity work.mux_entity_83804557c8
    port map (
      ce_1 => ce_1_sg_x350,
      clk_1 => clk_1_sg_x350,
      d0 => concatenate_y_net_x5,
      d1 => concatenate_y_net_x6,
      sel => concatenate_y_net_x10,
      out_x0 => concatenate_y_net_x9
    );

  shift_replicate_aee00b267f: entity work.shift_replicate_entity_7f26e672bf
    port map (
      ce_1 => ce_1_sg_x350,
      clk_1 => clk_1_sg_x350,
      in_x0 => slice0_y_net_x1,
      out_x0 => concatenate_y_net_x10
    );

  twiddle_420b4158b4: entity work.twiddle_entity_420b4158b4
    port map (
      ai => reinterpret1_output_port_net_x3,
      bi => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x350,
      clk_1 => clk_1_sg_x350,
      sync_in => mux_y_net_x3,
      ao => reinterpret1_output_port_net_x11,
      bwo => concatenate_y_net_x11,
      sync_out => slice2_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_7/delay0"

entity delay0_entity_5ee21295de is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end delay0_entity_5ee21295de;

architecture structural of delay0_entity_5ee21295de is
  signal ce_1_sg_x351: std_logic;
  signal clk_1_sg_x351: std_logic;
  signal del1_q_net_x0: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x351 <= ce_1;
  clk_1_sg_x351 <= clk_1;
  din2_q_net_x1 <= din;
  dout <= reinterpret1_output_port_net_x2;

  del1: entity work.delay_bdaf6c9e55
    port map (
      ce => ce_1_sg_x351,
      clk => clk_1_sg_x351,
      clr => '0',
      d => reinterpret1_output_port_net_x0,
      q => del1_q_net_x0
    );

  din_expand_f110a0c0aa: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => din2_q_net_x1,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  dout_compress_c122d6f6f1: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => del1_q_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_7/sync_delay"

entity sync_delay_entity_9207f22fac is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_entity_9207f22fac;

architecture structural of sync_delay_entity_9207f22fac is
  signal ce_1_sg_x353: std_logic;
  signal clk_1_sg_x353: std_logic;
  signal constant1_op_net: std_logic_vector(2 downto 0);
  signal constant2_op_net: std_logic_vector(2 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(2 downto 0);
  signal counter_op_net: std_logic_vector(2 downto 0);
  signal dsync1_q_net_x0: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x4: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x353 <= ce_1;
  clk_1_sg_x353 <= clk_1;
  dsync1_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x4;

  constant1: entity work.constant_822933f89b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_469094441c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_a1c496ea88
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_ed7367cb5c
    port map (
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical_y_net,
      load(0) => dsync1_q_net_x0,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x4
    );

  relational: entity work.relational_8fc7f5539b
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_47b317dab6
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_7"

entity fft_stage_7_entity_6fa5bc8de3 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    out1: out std_logic_vector(35 downto 0); 
    out2: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_stage_7_entity_6fa5bc8de3;

architecture structural of fft_stage_7_entity_6fa5bc8de3 is
  signal ce_1_sg_x354: std_logic;
  signal clk_1_sg_x354: std_logic;
  signal counter_op_net: std_logic_vector(2 downto 0);
  signal delay0_q_net_x1: std_logic;
  signal delay0_q_net_x6: std_logic;
  signal delay11_q_net_x6: std_logic_vector(10 downto 0);
  signal din0_q_net: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal dmux1_q_net_x1: std_logic_vector(35 downto 0);
  signal dsync0_q_net: std_logic;
  signal dsync1_q_net_x0: std_logic;
  signal mux0_y_net: std_logic_vector(35 downto 0);
  signal mux1_y_net: std_logic_vector(35 downto 0);
  signal mux_y_net_x4: std_logic;
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x8: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x7: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice1_y_net: std_logic;

begin
  ce_1_sg_x354 <= ce_1;
  clk_1_sg_x354 <= clk_1;
  reinterpret2_output_port_net_x7 <= in1;
  reinterpret1_output_port_net_x7 <= in2;
  delay11_q_net_x6 <= shift;
  delay0_q_net_x6 <= sync;
  out1 <= reinterpret2_output_port_net_x2;
  out2 <= reinterpret1_output_port_net_x8;
  sync_out <= delay0_q_net_x1;

  butterfly_direct_f9c91ad558: entity work.butterfly_direct_entity_f9c91ad558
    port map (
      a => reinterpret1_output_port_net_x5,
      b => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x354,
      clk_1 => clk_1_sg_x354,
      shift => slice0_y_net_x1,
      sync_in => mux_y_net_x4,
      a_bw => reinterpret1_output_port_net_x8,
      a_bw_x0 => reinterpret2_output_port_net_x2,
      sync_out => delay0_q_net_x1
    );

  counter: entity work.counter_191d4874ab
    port map (
      ce => ce_1_sg_x354,
      clk => clk_1_sg_x354,
      clr => '0',
      rst(0) => dsync0_q_net,
      op => counter_op_net
    );

  delay0_5ee21295de: entity work.delay0_entity_5ee21295de
    port map (
      ce_1 => ce_1_sg_x354,
      clk_1 => clk_1_sg_x354,
      din => din2_q_net_x1,
      dout => reinterpret1_output_port_net_x2
    );

  delay1_fa12864598: entity work.delay0_entity_5ee21295de
    port map (
      ce_1 => ce_1_sg_x354,
      clk_1 => clk_1_sg_x354,
      din => dmux1_q_net_x1,
      dout => reinterpret1_output_port_net_x5
    );

  din0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret2_output_port_net_x7,
      q => din0_q_net
    );

  din2: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret1_output_port_net_x7,
      q => din2_q_net_x1
    );

  dmux0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux0_y_net,
      q => dmux0_q_net_x2
    );

  dmux1: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux1_y_net,
      q => dmux1_q_net_x1
    );

  dsync0: entity work.delay_0341f7be44
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d(0) => delay0_q_net_x6,
      q(0) => dsync0_q_net
    );

  dsync1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x354,
      clk => clk_1_sg_x354,
      clr => '0',
      d(0) => dsync0_q_net,
      q(0) => dsync1_q_net_x0
    );

  mux0: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x354,
      clk => clk_1_sg_x354,
      clr => '0',
      d0 => reinterpret1_output_port_net_x2,
      d1 => din0_q_net,
      sel(0) => slice1_y_net,
      y => mux0_y_net
    );

  mux1: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x354,
      clk => clk_1_sg_x354,
      clr => '0',
      d0 => din0_q_net,
      d1 => reinterpret1_output_port_net_x2,
      sel(0) => slice1_y_net,
      y => mux1_y_net
    );

  slice0: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 6,
      x_width => 11,
      y_width => 1
    )
    port map (
      x => delay11_q_net_x6,
      y(0) => slice0_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 3,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice1_y_net
    );

  sync_delay_9207f22fac: entity work.sync_delay_entity_9207f22fac
    port map (
      ce_1 => ce_1_sg_x354,
      clk_1 => clk_1_sg_x354,
      in_x0 => dsync1_q_net_x0,
      out_x0 => mux_y_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_8/butterfly_direct/twiddle/coeff_gen/bit_reverse"

entity bit_reverse_entity_1223b50beb is
  port (
    in_x0: in std_logic_vector(6 downto 0); 
    out_x0: out std_logic_vector(6 downto 0)
  );
end bit_reverse_entity_1223b50beb;

architecture structural of bit_reverse_entity_1223b50beb is
  signal bit0_y_net: std_logic;
  signal bit1_y_net: std_logic;
  signal bit2_y_net: std_logic;
  signal bit3_y_net: std_logic;
  signal bit4_y_net: std_logic;
  signal bit5_y_net: std_logic;
  signal bit6_y_net: std_logic;
  signal concat_y_net_x0: std_logic_vector(6 downto 0);
  signal slice_y_net_x0: std_logic_vector(6 downto 0);

begin
  slice_y_net_x0 <= in_x0;
  out_x0 <= concat_y_net_x0;

  bit0: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 7,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit0_y_net
    );

  bit1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 7,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit1_y_net
    );

  bit2: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 7,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit2_y_net
    );

  bit3: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 7,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit3_y_net
    );

  bit4: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 4,
      x_width => 7,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit4_y_net
    );

  bit5: entity work.xlslice
    generic map (
      new_lsb => 5,
      new_msb => 5,
      x_width => 7,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit5_y_net
    );

  bit6: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 6,
      x_width => 7,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit6_y_net
    );

  concat: entity work.concat_eb5f1ca7f9
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => bit0_y_net,
      in1(0) => bit1_y_net,
      in2(0) => bit2_y_net,
      in3(0) => bit3_y_net,
      in4(0) => bit4_y_net,
      in5(0) => bit5_y_net,
      in6(0) => bit6_y_net,
      y => concat_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_8/butterfly_direct/twiddle/coeff_gen/cosin/add_convert0"

entity add_convert0_entity_b11716b29d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    theta: in std_logic_vector(6 downto 0); 
    add: out std_logic_vector(6 downto 0); 
    negate: out std_logic
  );
end add_convert0_entity_b11716b29d;

architecture structural of add_convert0_entity_b11716b29d is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x0: std_logic_vector(6 downto 0);
  signal ce_1_sg_x381: std_logic;
  signal clk_1_sg_x381: std_logic;
  signal concat_y_net: std_logic_vector(7 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(6 downto 0);
  signal delay13_q_net: std_logic_vector(6 downto 0);
  signal delay14_q_net: std_logic_vector(6 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(7 downto 0);
  signal invert_y_net: std_logic;
  signal lookup_y_net: std_logic_vector(5 downto 0);
  signal new_add_y_net: std_logic_vector(6 downto 0);
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x381 <= ce_1;
  clk_1_sg_x381 <= clk_1;
  assert_dout_net_x0 <= theta;
  add <= convert2_dout_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x381,
      clk => clk_1_sg_x381,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  concat: entity work.concat_dc245eb1d2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => addsub5_s_net,
      in1 => lookup_y_net,
      y => concat_y_net
    );

  convert2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 7,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 7,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x381,
      clk => clk_1_sg_x381,
      clr => '0',
      din => delay13_q_net,
      en => "1",
      dout => convert2_dout_net_x0
    );

  delay13: entity work.delay_8a9e828e57
    port map (
      ce => ce_1_sg_x381,
      clk => clk_1_sg_x381,
      clr => '0',
      d => delay14_q_net,
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 7
    )
    port map (
      ce => ce_1_sg_x381,
      clk => clk_1_sg_x381,
      d => new_add_y_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x381,
      clk => clk_1_sg_x381,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_83e473517e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x0,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  lookup: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 5,
      x_width => 8,
      y_width => 6
    )
    port map (
      x => fluff_y_net,
      y => lookup_y_net
    );

  new_add: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 6,
      x_width => 8,
      y_width => 7
    )
    port map (
      x => concat_y_net,
      y => new_add_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 7,
      x_width => 8,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_8/butterfly_direct/twiddle/coeff_gen/cosin/add_convert1"

entity add_convert1_entity_131567fb44 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(6 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    negate: out std_logic
  );
end add_convert1_entity_131567fb44;

architecture structural of add_convert1_entity_131567fb44 is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x1: std_logic_vector(6 downto 0);
  signal ce_1_sg_x382: std_logic;
  signal clk_1_sg_x382: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(72 downto 0);
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(7 downto 0);
  signal invert_y_net: std_logic;
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x382 <= ce_1;
  clk_1_sg_x382 <= clk_1;
  concatenate_y_net_x1 <= misci;
  assert_dout_net_x1 <= theta;
  misco <= delay1_q_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x382,
      clk => clk_1_sg_x382,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  delay1: entity work.delay_4e967fa4b7
    port map (
      ce => ce_1_sg_x382,
      clk => clk_1_sg_x382,
      clr => '0',
      d => concatenate_y_net_x1,
      q => delay1_q_net_x0
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x382,
      clk => clk_1_sg_x382,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_83e473517e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x1,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 7,
      x_width => 8,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_8/butterfly_direct/twiddle/coeff_gen/cosin"

entity cosin_entity_0283122a71 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(6 downto 0); 
    cos: out std_logic_vector(17 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    sin: out std_logic_vector(17 downto 0)
  );
end cosin_entity_0283122a71;

architecture structural of cosin_entity_0283122a71 is
  signal assert_dout_net_x1: std_logic_vector(6 downto 0);
  signal ce_1_sg_x385: std_logic;
  signal clk_1_sg_x385: std_logic;
  signal concat_y_net_x1: std_logic_vector(6 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(72 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(6 downto 0);
  signal delay10_q_net_x0: std_logic;
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay1_q_net_x2: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal delay2_q_net_x1: std_logic;
  signal delay8_q_net_x0: std_logic;
  signal delay_q_net_x0: std_logic_vector(72 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(17 downto 0);
  signal mux_y_net_x2: std_logic_vector(17 downto 0);
  signal mux_y_net_x3: std_logic_vector(17 downto 0);
  signal rom_data_net_x0: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x385 <= ce_1;
  clk_1_sg_x385 <= clk_1;
  concatenate_y_net_x2 <= misci;
  concat_y_net_x1 <= theta;
  cos <= mux_y_net_x2;
  misco <= delay1_q_net_x2;
  sin <= mux_y_net_x3;

  add_convert0_b11716b29d: entity work.add_convert0_entity_b11716b29d
    port map (
      ce_1 => ce_1_sg_x385,
      clk_1 => clk_1_sg_x385,
      theta => assert_dout_net_x1,
      add => convert2_dout_net_x0,
      negate => delay2_q_net_x0
    );

  add_convert1_131567fb44: entity work.add_convert1_entity_131567fb44
    port map (
      ce_1 => ce_1_sg_x385,
      clk_1 => clk_1_sg_x385,
      misci => concatenate_y_net_x2,
      theta => assert_dout_net_x1,
      misco => delay1_q_net_x0,
      negate => delay2_q_net_x1
    );

  assert_x0: entity work.xlpassthrough
    generic map (
      din_width => 7,
      dout_width => 7
    )
    port map (
      din => concat_y_net_x1,
      dout => assert_dout_net_x1
    );

  c_to_ri_36d0642a06: entity work.c_to_ri_entity_27418540ef
    port map (
      c => rom_data_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  delay: entity work.delay_7097453b2c
    port map (
      ce => ce_1_sg_x385,
      clk => clk_1_sg_x385,
      clr => '0',
      d => delay1_q_net_x0,
      q => delay_q_net_x0
    );

  delay10: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x385,
      clk => clk_1_sg_x385,
      clr => '0',
      d(0) => delay2_q_net_x0,
      q(0) => delay10_q_net_x0
    );

  delay8: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x385,
      clk => clk_1_sg_x385,
      clr => '0',
      d(0) => delay2_q_net_x1,
      q(0) => delay8_q_net_x0
    );

  invert0_93c7b04254: entity work.invert0_entity_b1ffbb1c3b
    port map (
      ce_1 => ce_1_sg_x385,
      clk_1 => clk_1_sg_x385,
      in_x0 => force_re_output_port_net_x1,
      negate_x0 => delay10_q_net_x0,
      out_x0 => mux_y_net_x2
    );

  invert1_b909072560: entity work.invert1_entity_af1af9b3de
    port map (
      ce_1 => ce_1_sg_x385,
      clk_1 => clk_1_sg_x385,
      in_x0 => force_im_output_port_net_x1,
      misci => delay_q_net_x0,
      negate_x0 => delay8_q_net_x0,
      misco => delay1_q_net_x2,
      out_x0 => mux_y_net_x3
    );

  rom: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 7,
      c_width => 36,
      core_name0 => "bmg_72_8e2f9d152d14263e",
      latency => 1
    )
    port map (
      addr => convert2_dout_net_x0,
      ce => ce_1_sg_x385,
      clk => clk_1_sg_x385,
      en => "1",
      rst => "0",
      data => rom_data_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_8/butterfly_direct/twiddle/coeff_gen"

entity coeff_gen_entity_8adbac56fc is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    rst: in std_logic; 
    misco: out std_logic_vector(72 downto 0); 
    w: out std_logic_vector(35 downto 0)
  );
end coeff_gen_entity_8adbac56fc;

architecture structural of coeff_gen_entity_8adbac56fc is
  signal ce_1_sg_x386: std_logic;
  signal clk_1_sg_x386: std_logic;
  signal concat_y_net_x1: std_logic_vector(6 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal mux_y_net_x1: std_logic;
  signal mux_y_net_x4: std_logic_vector(17 downto 0);
  signal mux_y_net_x5: std_logic_vector(17 downto 0);
  signal slice_y_net_x0: std_logic_vector(6 downto 0);

begin
  ce_1_sg_x386 <= ce_1;
  clk_1_sg_x386 <= clk_1;
  concatenate_y_net_x3 <= misci;
  mux_y_net_x1 <= rst;
  misco <= delay1_q_net_x3;
  w <= concat_y_net_x5;

  bit_reverse_1223b50beb: entity work.bit_reverse_entity_1223b50beb
    port map (
      in_x0 => slice_y_net_x0,
      out_x0 => concat_y_net_x1
    );

  cosin_0283122a71: entity work.cosin_entity_0283122a71
    port map (
      ce_1 => ce_1_sg_x386,
      clk_1 => clk_1_sg_x386,
      misci => concatenate_y_net_x3,
      theta => concat_y_net_x1,
      cos => mux_y_net_x4,
      misco => delay1_q_net_x3,
      sin => mux_y_net_x5
    );

  counter: entity work.counter_11ccef49a2
    port map (
      ce => ce_1_sg_x386,
      clk => clk_1_sg_x386,
      clr => '0',
      rst(0) => mux_y_net_x1,
      op => counter_op_net
    );

  ri_to_c_0a0c737652: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => mux_y_net_x5,
      re => mux_y_net_x4,
      c => concat_y_net_x5
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 7,
      x_width => 8,
      y_width => 7
    )
    port map (
      x => counter_op_net,
      y => slice_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_8/butterfly_direct/twiddle"

entity twiddle_entity_7018a27052 is
  port (
    ai: in std_logic_vector(35 downto 0); 
    bi: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ao: out std_logic_vector(35 downto 0); 
    bwo: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end twiddle_entity_7018a27052;

architecture structural of twiddle_entity_7018a27052 is
  signal ce_1_sg_x387: std_logic;
  signal clk_1_sg_x387: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(37 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x3: std_logic_vector(36 downto 0);
  signal dmux0_q_net_x1: std_logic_vector(35 downto 0);
  signal mux_y_net_x2: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x2 <= ai;
  dmux0_q_net_x1 <= bi;
  ce_1_sg_x387 <= ce_1;
  clk_1_sg_x387 <= clk_1;
  mux_y_net_x2 <= sync_in;
  ao <= reinterpret1_output_port_net_x11;
  bwo <= concatenate_y_net_x7;
  sync_out <= slice2_y_net_x1;

  bus_convert_8e69f16dae: entity work.bus_convert_entity_8995348ed7
    port map (
      ce_1 => ce_1_sg_x387,
      clk_1 => clk_1_sg_x387,
      din => reinterpret1_output_port_net_x10,
      misci => dmisc_q_net_x2,
      dout => concatenate_y_net_x7,
      misco => dmisc_q_net_x3
    );

  bus_create_fcd53b6fab: entity work.bus_create_entity_bca4476356
    port map (
      in1 => dmux0_q_net_x1,
      in2 => mux_y_net_x2,
      in3 => reinterpret1_output_port_net_x2,
      bus_out => concatenate_y_net_x3
    );

  bus_expand1_d586347445: entity work.bus_expand1_entity_94af2caf5e
    port map (
      bus_in => dmisc_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x11,
      msb_out2 => slice2_y_net_x1
    );

  bus_expand_40ff898f2c: entity work.bus_expand_entity_0c73098dab
    port map (
      bus_in => delay1_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x9,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  bus_mult_01f7407dfb: entity work.bus_mult_entity_516ba8171e
    port map (
      a => concat_y_net_x5,
      b => reinterpret2_output_port_net_x3,
      ce_1 => ce_1_sg_x387,
      clk_1 => clk_1_sg_x387,
      misci => reinterpret1_output_port_net_x9,
      a_b => reinterpret1_output_port_net_x10,
      misco => dmisc_q_net_x2
    );

  coeff_gen_8adbac56fc: entity work.coeff_gen_entity_8adbac56fc
    port map (
      ce_1 => ce_1_sg_x387,
      clk_1 => clk_1_sg_x387,
      misci => concatenate_y_net_x3,
      rst => mux_y_net_x2,
      misco => delay1_q_net_x3,
      w => concat_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_8/butterfly_direct"

entity butterfly_direct_entity_62660c0fbf is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(35 downto 0); 
    a_bw_x0: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end butterfly_direct_entity_62660c0fbf;

architecture structural of butterfly_direct_entity_62660c0fbf is
  signal ce_1_sg_x388: std_logic;
  signal clk_1_sg_x388: std_logic;
  signal concat_y_net_x3: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x11: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(83 downto 0);
  signal delay0_q_net_x0: std_logic;
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal mux_y_net_x3: std_logic;
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x3 <= a;
  dmux0_q_net_x2 <= b;
  ce_1_sg_x388 <= ce_1;
  clk_1_sg_x388 <= clk_1;
  slice0_y_net_x1 <= shift;
  mux_y_net_x3 <= sync_in;
  a_bw <= reinterpret1_output_port_net_x4;
  a_bw_x0 <= reinterpret2_output_port_net_x1;
  sync_out <= delay0_q_net_x0;

  bus_add_3baf0e7256: entity work.bus_add_entity_b1cdda5af7
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x388,
      clk_1 => clk_1_sg_x388,
      dout => concatenate_y_net_x3
    );

  bus_convert_c3ce3ed2cb: entity work.bus_convert_entity_b950f53ae4
    port map (
      ce_1 => ce_1_sg_x388,
      clk_1 => clk_1_sg_x388,
      din => concatenate_y_net_x9,
      dout => concatenate_y_net_x4
    );

  bus_expand_61eccaa70e: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x4,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  bus_norm0_70b0269802: entity work.bus_norm0_entity_e7ca085468
    port map (
      ce_1 => ce_1_sg_x388,
      clk_1 => clk_1_sg_x388,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x5
    );

  bus_norm1_542a00e3eb: entity work.bus_norm1_entity_bd510a87ea
    port map (
      ce_1 => ce_1_sg_x388,
      clk_1 => clk_1_sg_x388,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x6
    );

  bus_scale_410e9a825e: entity work.bus_scale_entity_25e603273f
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_4894622320: entity work.bus_sub_entity_9893acc382
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x388,
      clk_1 => clk_1_sg_x388,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_cfdc93535e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x3,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  delay0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x388,
      clk => clk_1_sg_x388,
      clr => '0',
      d(0) => slice2_y_net_x1,
      q(0) => delay0_q_net_x0
    );

  mux_137f5f9bca: entity work.mux_entity_83804557c8
    port map (
      ce_1 => ce_1_sg_x388,
      clk_1 => clk_1_sg_x388,
      d0 => concatenate_y_net_x5,
      d1 => concatenate_y_net_x6,
      sel => concatenate_y_net_x10,
      out_x0 => concatenate_y_net_x9
    );

  shift_replicate_63a8eb8c08: entity work.shift_replicate_entity_7f26e672bf
    port map (
      ce_1 => ce_1_sg_x388,
      clk_1 => clk_1_sg_x388,
      in_x0 => slice0_y_net_x1,
      out_x0 => concatenate_y_net_x10
    );

  twiddle_7018a27052: entity work.twiddle_entity_7018a27052
    port map (
      ai => reinterpret1_output_port_net_x3,
      bi => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x388,
      clk_1 => clk_1_sg_x388,
      sync_in => mux_y_net_x3,
      ao => reinterpret1_output_port_net_x11,
      bwo => concatenate_y_net_x11,
      sync_out => slice2_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_8/delay0"

entity delay0_entity_2aa9fed91b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end delay0_entity_2aa9fed91b;

architecture structural of delay0_entity_2aa9fed91b is
  signal ce_1_sg_x389: std_logic;
  signal clk_1_sg_x389: std_logic;
  signal del1_q_net_x0: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x389 <= ce_1;
  clk_1_sg_x389 <= clk_1;
  din2_q_net_x1 <= din;
  dout <= reinterpret1_output_port_net_x2;

  del1: entity work.delay_38898c80c0
    port map (
      ce => ce_1_sg_x389,
      clk => clk_1_sg_x389,
      clr => '0',
      d => reinterpret1_output_port_net_x0,
      q => del1_q_net_x0
    );

  din_expand_9f3bc29cdb: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => din2_q_net_x1,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  dout_compress_86d9ce7e58: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => del1_q_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_8/sync_delay"

entity sync_delay_entity_85f1f75c0b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_entity_85f1f75c0b;

architecture structural of sync_delay_entity_85f1f75c0b is
  signal ce_1_sg_x391: std_logic;
  signal clk_1_sg_x391: std_logic;
  signal constant1_op_net: std_logic_vector(1 downto 0);
  signal constant2_op_net: std_logic_vector(1 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(1 downto 0);
  signal counter_op_net: std_logic_vector(1 downto 0);
  signal dsync1_q_net_x0: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x4: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x391 <= ce_1;
  clk_1_sg_x391 <= clk_1;
  dsync1_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x4;

  constant1: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_e8ddc079e9
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_a7e2bb9e12
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_e095645f0c
    port map (
      ce => ce_1_sg_x391,
      clk => clk_1_sg_x391,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical_y_net,
      load(0) => dsync1_q_net_x0,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x4
    );

  relational: entity work.relational_5f1eb17108
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_f9928864ea
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_8"

entity fft_stage_8_entity_5893958c25 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    out1: out std_logic_vector(35 downto 0); 
    out2: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_stage_8_entity_5893958c25;

architecture structural of fft_stage_8_entity_5893958c25 is
  signal ce_1_sg_x392: std_logic;
  signal clk_1_sg_x392: std_logic;
  signal counter_op_net: std_logic_vector(1 downto 0);
  signal delay0_q_net_x2: std_logic;
  signal delay0_q_net_x3: std_logic;
  signal delay11_q_net_x7: std_logic_vector(10 downto 0);
  signal din0_q_net: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal dmux1_q_net_x1: std_logic_vector(35 downto 0);
  signal dsync0_q_net: std_logic;
  signal dsync1_q_net_x0: std_logic;
  signal mux0_y_net: std_logic_vector(35 downto 0);
  signal mux1_y_net: std_logic_vector(35 downto 0);
  signal mux_y_net_x4: std_logic;
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x4: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice1_y_net: std_logic;

begin
  ce_1_sg_x392 <= ce_1;
  clk_1_sg_x392 <= clk_1;
  reinterpret2_output_port_net_x3 <= in1;
  reinterpret1_output_port_net_x9 <= in2;
  delay11_q_net_x7 <= shift;
  delay0_q_net_x2 <= sync;
  out1 <= reinterpret2_output_port_net_x4;
  out2 <= reinterpret1_output_port_net_x6;
  sync_out <= delay0_q_net_x3;

  butterfly_direct_62660c0fbf: entity work.butterfly_direct_entity_62660c0fbf
    port map (
      a => reinterpret1_output_port_net_x5,
      b => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x392,
      clk_1 => clk_1_sg_x392,
      shift => slice0_y_net_x1,
      sync_in => mux_y_net_x4,
      a_bw => reinterpret1_output_port_net_x6,
      a_bw_x0 => reinterpret2_output_port_net_x4,
      sync_out => delay0_q_net_x3
    );

  counter: entity work.counter_107ada62c3
    port map (
      ce => ce_1_sg_x392,
      clk => clk_1_sg_x392,
      clr => '0',
      rst(0) => dsync0_q_net,
      op => counter_op_net
    );

  delay0_2aa9fed91b: entity work.delay0_entity_2aa9fed91b
    port map (
      ce_1 => ce_1_sg_x392,
      clk_1 => clk_1_sg_x392,
      din => din2_q_net_x1,
      dout => reinterpret1_output_port_net_x2
    );

  delay1_6a48744088: entity work.delay0_entity_2aa9fed91b
    port map (
      ce_1 => ce_1_sg_x392,
      clk_1 => clk_1_sg_x392,
      din => dmux1_q_net_x1,
      dout => reinterpret1_output_port_net_x5
    );

  din0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret2_output_port_net_x3,
      q => din0_q_net
    );

  din2: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret1_output_port_net_x9,
      q => din2_q_net_x1
    );

  dmux0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux0_y_net,
      q => dmux0_q_net_x2
    );

  dmux1: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux1_y_net,
      q => dmux1_q_net_x1
    );

  dsync0: entity work.delay_0341f7be44
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d(0) => delay0_q_net_x2,
      q(0) => dsync0_q_net
    );

  dsync1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x392,
      clk => clk_1_sg_x392,
      clr => '0',
      d(0) => dsync0_q_net,
      q(0) => dsync1_q_net_x0
    );

  mux0: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x392,
      clk => clk_1_sg_x392,
      clr => '0',
      d0 => reinterpret1_output_port_net_x2,
      d1 => din0_q_net,
      sel(0) => slice1_y_net,
      y => mux0_y_net
    );

  mux1: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x392,
      clk => clk_1_sg_x392,
      clr => '0',
      d0 => din0_q_net,
      d1 => reinterpret1_output_port_net_x2,
      sel(0) => slice1_y_net,
      y => mux1_y_net
    );

  slice0: entity work.xlslice
    generic map (
      new_lsb => 7,
      new_msb => 7,
      x_width => 11,
      y_width => 1
    )
    port map (
      x => delay11_q_net_x7,
      y(0) => slice0_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => slice1_y_net
    );

  sync_delay_85f1f75c0b: entity work.sync_delay_entity_85f1f75c0b
    port map (
      ce_1 => ce_1_sg_x392,
      clk_1 => clk_1_sg_x392,
      in_x0 => dsync1_q_net_x0,
      out_x0 => mux_y_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_9/butterfly_direct/twiddle/coeff_gen/bit_reverse"

entity bit_reverse_entity_e512f97cab is
  port (
    in_x0: in std_logic_vector(7 downto 0); 
    out_x0: out std_logic_vector(7 downto 0)
  );
end bit_reverse_entity_e512f97cab;

architecture structural of bit_reverse_entity_e512f97cab is
  signal bit0_y_net: std_logic;
  signal bit1_y_net: std_logic;
  signal bit2_y_net: std_logic;
  signal bit3_y_net: std_logic;
  signal bit4_y_net: std_logic;
  signal bit5_y_net: std_logic;
  signal bit6_y_net: std_logic;
  signal bit7_y_net: std_logic;
  signal concat_y_net_x0: std_logic_vector(7 downto 0);
  signal slice_y_net_x0: std_logic_vector(7 downto 0);

begin
  slice_y_net_x0 <= in_x0;
  out_x0 <= concat_y_net_x0;

  bit0: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit0_y_net
    );

  bit1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit1_y_net
    );

  bit2: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit2_y_net
    );

  bit3: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit3_y_net
    );

  bit4: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 4,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit4_y_net
    );

  bit5: entity work.xlslice
    generic map (
      new_lsb => 5,
      new_msb => 5,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit5_y_net
    );

  bit6: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 6,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit6_y_net
    );

  bit7: entity work.xlslice
    generic map (
      new_lsb => 7,
      new_msb => 7,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => bit7_y_net
    );

  concat: entity work.concat_7673b9b993
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => bit0_y_net,
      in1(0) => bit1_y_net,
      in2(0) => bit2_y_net,
      in3(0) => bit3_y_net,
      in4(0) => bit4_y_net,
      in5(0) => bit5_y_net,
      in6(0) => bit6_y_net,
      in7(0) => bit7_y_net,
      y => concat_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_9/butterfly_direct/twiddle/coeff_gen/cosin/add_convert0"

entity add_convert0_entity_26cf05a4b9 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    theta: in std_logic_vector(7 downto 0); 
    add: out std_logic_vector(7 downto 0); 
    negate: out std_logic
  );
end add_convert0_entity_26cf05a4b9;

architecture structural of add_convert0_entity_26cf05a4b9 is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x0: std_logic_vector(7 downto 0);
  signal ce_1_sg_x419: std_logic;
  signal clk_1_sg_x419: std_logic;
  signal concat_y_net: std_logic_vector(8 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(7 downto 0);
  signal delay13_q_net: std_logic_vector(7 downto 0);
  signal delay14_q_net: std_logic_vector(7 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(8 downto 0);
  signal invert_y_net: std_logic;
  signal lookup_y_net: std_logic_vector(6 downto 0);
  signal new_add_y_net: std_logic_vector(7 downto 0);
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x419 <= ce_1;
  clk_1_sg_x419 <= clk_1;
  assert_dout_net_x0 <= theta;
  add <= convert2_dout_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x419,
      clk => clk_1_sg_x419,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  concat: entity work.concat_f62149b02a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => addsub5_s_net,
      in1 => lookup_y_net,
      y => concat_y_net
    );

  convert2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 8,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 8,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x419,
      clk => clk_1_sg_x419,
      clr => '0',
      din => delay13_q_net,
      en => "1",
      dout => convert2_dout_net_x0
    );

  delay13: entity work.delay_23f848c85b
    port map (
      ce => ce_1_sg_x419,
      clk => clk_1_sg_x419,
      clr => '0',
      d => delay14_q_net,
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x419,
      clk => clk_1_sg_x419,
      d => new_add_y_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x419,
      clk => clk_1_sg_x419,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_1ece14600f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x0,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  lookup: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 6,
      x_width => 9,
      y_width => 7
    )
    port map (
      x => fluff_y_net,
      y => lookup_y_net
    );

  new_add: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 9,
      y_width => 8
    )
    port map (
      x => concat_y_net,
      y => new_add_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 7,
      new_msb => 8,
      x_width => 9,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_9/butterfly_direct/twiddle/coeff_gen/cosin/add_convert1"

entity add_convert1_entity_e084da0df7 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(7 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    negate: out std_logic
  );
end add_convert1_entity_e084da0df7;

architecture structural of add_convert1_entity_e084da0df7 is
  signal addsub5_s_net: std_logic_vector(1 downto 0);
  signal assert_dout_net_x1: std_logic_vector(7 downto 0);
  signal ce_1_sg_x420: std_logic;
  signal clk_1_sg_x420: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(72 downto 0);
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal direction_offset_op_net: std_logic_vector(1 downto 0);
  signal fluff_y_net: std_logic_vector(8 downto 0);
  signal invert_y_net: std_logic;
  signal pad_op_net: std_logic;
  signal quadrant_y_net: std_logic_vector(1 downto 0);

begin
  ce_1_sg_x420 <= ce_1;
  clk_1_sg_x420 <= clk_1;
  concatenate_y_net_x1 <= misci;
  assert_dout_net_x1 <= theta;
  misco <= delay1_q_net_x0;
  negate <= delay2_q_net_x0;

  addsub5: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 2,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 2,
      c_has_c_out => 0,
      c_latency => 0,
      c_output_width => 3,
      core_name0 => "addsb_11_0_6a49eeb869ee9525",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 3,
      latency => 0,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 2
    )
    port map (
      a => direction_offset_op_net,
      b => quadrant_y_net,
      ce => ce_1_sg_x420,
      clk => clk_1_sg_x420,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  delay1: entity work.delay_4e967fa4b7
    port map (
      ce => ce_1_sg_x420,
      clk => clk_1_sg_x420,
      clr => '0',
      d => concatenate_y_net_x1,
      q => delay1_q_net_x0
    );

  delay2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x420,
      clk => clk_1_sg_x420,
      clr => '0',
      d(0) => invert_y_net,
      q(0) => delay2_q_net_x0
    );

  direction_offset: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => direction_offset_op_net
    );

  fluff: entity work.concat_1ece14600f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => pad_op_net,
      in1 => assert_dout_net_x1,
      y => fluff_y_net
    );

  invert: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => addsub5_s_net,
      y(0) => invert_y_net
    );

  pad: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => pad_op_net
    );

  quadrant: entity work.xlslice
    generic map (
      new_lsb => 7,
      new_msb => 8,
      x_width => 9,
      y_width => 2
    )
    port map (
      x => fluff_y_net,
      y => quadrant_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_9/butterfly_direct/twiddle/coeff_gen/cosin"

entity cosin_entity_603fb9966d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    theta: in std_logic_vector(7 downto 0); 
    cos: out std_logic_vector(17 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    sin: out std_logic_vector(17 downto 0)
  );
end cosin_entity_603fb9966d;

architecture structural of cosin_entity_603fb9966d is
  signal assert_dout_net_x1: std_logic_vector(7 downto 0);
  signal ce_1_sg_x423: std_logic;
  signal clk_1_sg_x423: std_logic;
  signal concat_y_net_x1: std_logic_vector(7 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(72 downto 0);
  signal convert2_dout_net_x0: std_logic_vector(7 downto 0);
  signal delay10_q_net_x0: std_logic;
  signal delay1_q_net_x0: std_logic_vector(72 downto 0);
  signal delay1_q_net_x2: std_logic_vector(72 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal delay2_q_net_x1: std_logic;
  signal delay8_q_net_x0: std_logic;
  signal delay_q_net_x0: std_logic_vector(72 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(17 downto 0);
  signal mux_y_net_x2: std_logic_vector(17 downto 0);
  signal mux_y_net_x3: std_logic_vector(17 downto 0);
  signal rom_data_net_x0: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x423 <= ce_1;
  clk_1_sg_x423 <= clk_1;
  concatenate_y_net_x2 <= misci;
  concat_y_net_x1 <= theta;
  cos <= mux_y_net_x2;
  misco <= delay1_q_net_x2;
  sin <= mux_y_net_x3;

  add_convert0_26cf05a4b9: entity work.add_convert0_entity_26cf05a4b9
    port map (
      ce_1 => ce_1_sg_x423,
      clk_1 => clk_1_sg_x423,
      theta => assert_dout_net_x1,
      add => convert2_dout_net_x0,
      negate => delay2_q_net_x0
    );

  add_convert1_e084da0df7: entity work.add_convert1_entity_e084da0df7
    port map (
      ce_1 => ce_1_sg_x423,
      clk_1 => clk_1_sg_x423,
      misci => concatenate_y_net_x2,
      theta => assert_dout_net_x1,
      misco => delay1_q_net_x0,
      negate => delay2_q_net_x1
    );

  assert_x0: entity work.xlpassthrough
    generic map (
      din_width => 8,
      dout_width => 8
    )
    port map (
      din => concat_y_net_x1,
      dout => assert_dout_net_x1
    );

  c_to_ri_cb233b8152: entity work.c_to_ri_entity_27418540ef
    port map (
      c => rom_data_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  delay: entity work.delay_7097453b2c
    port map (
      ce => ce_1_sg_x423,
      clk => clk_1_sg_x423,
      clr => '0',
      d => delay1_q_net_x0,
      q => delay_q_net_x0
    );

  delay10: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x423,
      clk => clk_1_sg_x423,
      clr => '0',
      d(0) => delay2_q_net_x0,
      q(0) => delay10_q_net_x0
    );

  delay8: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x423,
      clk => clk_1_sg_x423,
      clr => '0',
      d(0) => delay2_q_net_x1,
      q(0) => delay8_q_net_x0
    );

  invert0_f8df5572fa: entity work.invert0_entity_b1ffbb1c3b
    port map (
      ce_1 => ce_1_sg_x423,
      clk_1 => clk_1_sg_x423,
      in_x0 => force_re_output_port_net_x1,
      negate_x0 => delay10_q_net_x0,
      out_x0 => mux_y_net_x2
    );

  invert1_110774c3f9: entity work.invert1_entity_af1af9b3de
    port map (
      ce_1 => ce_1_sg_x423,
      clk_1 => clk_1_sg_x423,
      in_x0 => force_im_output_port_net_x1,
      misci => delay_q_net_x0,
      negate_x0 => delay8_q_net_x0,
      misco => delay1_q_net_x2,
      out_x0 => mux_y_net_x3
    );

  rom: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 8,
      c_width => 36,
      core_name0 => "bmg_72_3f3c61289e7ba7ea",
      latency => 1
    )
    port map (
      addr => convert2_dout_net_x0,
      ce => ce_1_sg_x423,
      clk => clk_1_sg_x423,
      en => "1",
      rst => "0",
      data => rom_data_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_9/butterfly_direct/twiddle/coeff_gen"

entity coeff_gen_entity_934757690e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    rst: in std_logic; 
    misco: out std_logic_vector(72 downto 0); 
    w: out std_logic_vector(35 downto 0)
  );
end coeff_gen_entity_934757690e;

architecture structural of coeff_gen_entity_934757690e is
  signal ce_1_sg_x424: std_logic;
  signal clk_1_sg_x424: std_logic;
  signal concat_y_net_x1: std_logic_vector(7 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal mux_y_net_x1: std_logic;
  signal mux_y_net_x4: std_logic_vector(17 downto 0);
  signal mux_y_net_x5: std_logic_vector(17 downto 0);
  signal slice_y_net_x0: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x424 <= ce_1;
  clk_1_sg_x424 <= clk_1;
  concatenate_y_net_x3 <= misci;
  mux_y_net_x1 <= rst;
  misco <= delay1_q_net_x3;
  w <= concat_y_net_x5;

  bit_reverse_e512f97cab: entity work.bit_reverse_entity_e512f97cab
    port map (
      in_x0 => slice_y_net_x0,
      out_x0 => concat_y_net_x1
    );

  cosin_603fb9966d: entity work.cosin_entity_603fb9966d
    port map (
      ce_1 => ce_1_sg_x424,
      clk_1 => clk_1_sg_x424,
      misci => concatenate_y_net_x3,
      theta => concat_y_net_x1,
      cos => mux_y_net_x4,
      misco => delay1_q_net_x3,
      sin => mux_y_net_x5
    );

  counter: entity work.counter_11ccef49a2
    port map (
      ce => ce_1_sg_x424,
      clk => clk_1_sg_x424,
      clr => '0',
      rst(0) => mux_y_net_x1,
      op => counter_op_net
    );

  ri_to_c_d1f4d98758: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => mux_y_net_x5,
      re => mux_y_net_x4,
      c => concat_y_net_x5
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 8,
      y_width => 8
    )
    port map (
      x => counter_op_net,
      y => slice_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_9/butterfly_direct/twiddle"

entity twiddle_entity_31b045e282 is
  port (
    ai: in std_logic_vector(35 downto 0); 
    bi: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ao: out std_logic_vector(35 downto 0); 
    bwo: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end twiddle_entity_31b045e282;

architecture structural of twiddle_entity_31b045e282 is
  signal ce_1_sg_x425: std_logic;
  signal clk_1_sg_x425: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(72 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(37 downto 0);
  signal delay1_q_net_x3: std_logic_vector(72 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x3: std_logic_vector(36 downto 0);
  signal dmux0_q_net_x1: std_logic_vector(35 downto 0);
  signal mux_y_net_x2: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x2 <= ai;
  dmux0_q_net_x1 <= bi;
  ce_1_sg_x425 <= ce_1;
  clk_1_sg_x425 <= clk_1;
  mux_y_net_x2 <= sync_in;
  ao <= reinterpret1_output_port_net_x11;
  bwo <= concatenate_y_net_x7;
  sync_out <= slice2_y_net_x1;

  bus_convert_d7acbc69a6: entity work.bus_convert_entity_8995348ed7
    port map (
      ce_1 => ce_1_sg_x425,
      clk_1 => clk_1_sg_x425,
      din => reinterpret1_output_port_net_x10,
      misci => dmisc_q_net_x2,
      dout => concatenate_y_net_x7,
      misco => dmisc_q_net_x3
    );

  bus_create_dc82985dc2: entity work.bus_create_entity_bca4476356
    port map (
      in1 => dmux0_q_net_x1,
      in2 => mux_y_net_x2,
      in3 => reinterpret1_output_port_net_x2,
      bus_out => concatenate_y_net_x3
    );

  bus_expand1_a847baa1de: entity work.bus_expand1_entity_94af2caf5e
    port map (
      bus_in => dmisc_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x11,
      msb_out2 => slice2_y_net_x1
    );

  bus_expand_39c4bba4ad: entity work.bus_expand_entity_0c73098dab
    port map (
      bus_in => delay1_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x9,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  bus_mult_ec224906ec: entity work.bus_mult_entity_516ba8171e
    port map (
      a => concat_y_net_x5,
      b => reinterpret2_output_port_net_x3,
      ce_1 => ce_1_sg_x425,
      clk_1 => clk_1_sg_x425,
      misci => reinterpret1_output_port_net_x9,
      a_b => reinterpret1_output_port_net_x10,
      misco => dmisc_q_net_x2
    );

  coeff_gen_934757690e: entity work.coeff_gen_entity_934757690e
    port map (
      ce_1 => ce_1_sg_x425,
      clk_1 => clk_1_sg_x425,
      misci => concatenate_y_net_x3,
      rst => mux_y_net_x2,
      misco => delay1_q_net_x3,
      w => concat_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_9/butterfly_direct"

entity butterfly_direct_entity_886de93ba2 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(35 downto 0); 
    a_bw_x0: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end butterfly_direct_entity_886de93ba2;

architecture structural of butterfly_direct_entity_886de93ba2 is
  signal ce_1_sg_x426: std_logic;
  signal clk_1_sg_x426: std_logic;
  signal concat_y_net_x3: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x11: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(83 downto 0);
  signal delay0_q_net_x3: std_logic;
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal mux_y_net_x3: std_logic;
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x22: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret1_output_port_net_x3 <= a;
  dmux0_q_net_x2 <= b;
  ce_1_sg_x426 <= ce_1;
  clk_1_sg_x426 <= clk_1;
  slice0_y_net_x1 <= shift;
  mux_y_net_x3 <= sync_in;
  a_bw <= reinterpret1_output_port_net_x22;
  a_bw_x0 <= reinterpret2_output_port_net_x3;
  sync_out <= delay0_q_net_x3;

  bus_add_8783b6d5ac: entity work.bus_add_entity_b1cdda5af7
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x426,
      clk_1 => clk_1_sg_x426,
      dout => concatenate_y_net_x3
    );

  bus_convert_4550559f14: entity work.bus_convert_entity_b950f53ae4
    port map (
      ce_1 => ce_1_sg_x426,
      clk_1 => clk_1_sg_x426,
      din => concatenate_y_net_x9,
      dout => concatenate_y_net_x4
    );

  bus_expand_30922cc1e3: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x22,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  bus_norm0_e102926a88: entity work.bus_norm0_entity_e7ca085468
    port map (
      ce_1 => ce_1_sg_x426,
      clk_1 => clk_1_sg_x426,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x5
    );

  bus_norm1_a4c010b3be: entity work.bus_norm1_entity_bd510a87ea
    port map (
      ce_1 => ce_1_sg_x426,
      clk_1 => clk_1_sg_x426,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x6
    );

  bus_scale_271bccef7a: entity work.bus_scale_entity_25e603273f
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_06f25da58a: entity work.bus_sub_entity_9893acc382
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x426,
      clk_1 => clk_1_sg_x426,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_cfdc93535e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x3,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  delay0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x426,
      clk => clk_1_sg_x426,
      clr => '0',
      d(0) => slice2_y_net_x1,
      q(0) => delay0_q_net_x3
    );

  mux_6b544c1c45: entity work.mux_entity_83804557c8
    port map (
      ce_1 => ce_1_sg_x426,
      clk_1 => clk_1_sg_x426,
      d0 => concatenate_y_net_x5,
      d1 => concatenate_y_net_x6,
      sel => concatenate_y_net_x10,
      out_x0 => concatenate_y_net_x9
    );

  shift_replicate_99d64bed7f: entity work.shift_replicate_entity_7f26e672bf
    port map (
      ce_1 => ce_1_sg_x426,
      clk_1 => clk_1_sg_x426,
      in_x0 => slice0_y_net_x1,
      out_x0 => concatenate_y_net_x10
    );

  twiddle_31b045e282: entity work.twiddle_entity_31b045e282
    port map (
      ai => reinterpret1_output_port_net_x3,
      bi => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x426,
      clk_1 => clk_1_sg_x426,
      sync_in => mux_y_net_x3,
      ao => reinterpret1_output_port_net_x11,
      bwo => concatenate_y_net_x11,
      sync_out => slice2_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_9/delay0"

entity delay0_entity_1a9067bbbd is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end delay0_entity_1a9067bbbd;

architecture structural of delay0_entity_1a9067bbbd is
  signal ce_1_sg_x427: std_logic;
  signal clk_1_sg_x427: std_logic;
  signal del1_q_net_x0: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x427 <= ce_1;
  clk_1_sg_x427 <= clk_1;
  din2_q_net_x1 <= din;
  dout <= reinterpret1_output_port_net_x2;

  del1: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x427,
      clk => clk_1_sg_x427,
      clr => '0',
      d => reinterpret1_output_port_net_x0,
      q => del1_q_net_x0
    );

  din_expand_523b3ddf7c: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => din2_q_net_x1,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  dout_compress_5e093210e8: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => del1_q_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_9/sync_delay"

entity sync_delay_entity_03e3a77bfa is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_entity_03e3a77bfa;

architecture structural of sync_delay_entity_03e3a77bfa is
  signal ce_1_sg_x429: std_logic;
  signal clk_1_sg_x429: std_logic;
  signal constant1_op_net: std_logic_vector(1 downto 0);
  signal constant2_op_net: std_logic_vector(1 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(1 downto 0);
  signal counter_op_net: std_logic_vector(1 downto 0);
  signal dsync1_q_net_x0: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x4: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x429 <= ce_1;
  clk_1_sg_x429 <= clk_1;
  dsync1_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x4;

  constant1: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_a7e2bb9e12
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_a7e2bb9e12
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_e095645f0c
    port map (
      ce => ce_1_sg_x429,
      clk => clk_1_sg_x429,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical_y_net,
      load(0) => dsync1_q_net_x0,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => dsync1_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x4
    );

  relational: entity work.relational_5f1eb17108
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_f9928864ea
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core/fft_stage_9"

entity fft_stage_9_entity_ba3a650d43 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    out1: out std_logic_vector(35 downto 0); 
    out2: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_stage_9_entity_ba3a650d43;

architecture structural of fft_stage_9_entity_ba3a650d43 is
  signal ce_1_sg_x430: std_logic;
  signal clk_1_sg_x430: std_logic;
  signal counter_op_net: std_logic;
  signal delay0_q_net_x5: std_logic;
  signal delay0_q_net_x6: std_logic;
  signal delay11_q_net_x8: std_logic_vector(10 downto 0);
  signal din0_q_net: std_logic_vector(35 downto 0);
  signal din2_q_net_x1: std_logic_vector(35 downto 0);
  signal dmux0_q_net_x2: std_logic_vector(35 downto 0);
  signal dmux1_q_net_x1: std_logic_vector(35 downto 0);
  signal dsync0_q_net: std_logic;
  signal dsync1_q_net_x0: std_logic;
  signal mux0_y_net: std_logic_vector(35 downto 0);
  signal mux1_y_net: std_logic_vector(35 downto 0);
  signal mux_y_net_x4: std_logic;
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x23: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x6: std_logic_vector(35 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice1_y_net: std_logic;

begin
  ce_1_sg_x430 <= ce_1;
  clk_1_sg_x430 <= clk_1;
  reinterpret2_output_port_net_x5 <= in1;
  reinterpret1_output_port_net_x7 <= in2;
  delay11_q_net_x8 <= shift;
  delay0_q_net_x5 <= sync;
  out1 <= reinterpret2_output_port_net_x6;
  out2 <= reinterpret1_output_port_net_x23;
  sync_out <= delay0_q_net_x6;

  butterfly_direct_886de93ba2: entity work.butterfly_direct_entity_886de93ba2
    port map (
      a => reinterpret1_output_port_net_x5,
      b => dmux0_q_net_x2,
      ce_1 => ce_1_sg_x430,
      clk_1 => clk_1_sg_x430,
      shift => slice0_y_net_x1,
      sync_in => mux_y_net_x4,
      a_bw => reinterpret1_output_port_net_x23,
      a_bw_x0 => reinterpret2_output_port_net_x6,
      sync_out => delay0_q_net_x6
    );

  counter: entity work.counter_223a0f3237
    port map (
      ce => ce_1_sg_x430,
      clk => clk_1_sg_x430,
      clr => '0',
      rst(0) => dsync0_q_net,
      op(0) => counter_op_net
    );

  delay0_1a9067bbbd: entity work.delay0_entity_1a9067bbbd
    port map (
      ce_1 => ce_1_sg_x430,
      clk_1 => clk_1_sg_x430,
      din => din2_q_net_x1,
      dout => reinterpret1_output_port_net_x2
    );

  delay1_a038b6b4ad: entity work.delay0_entity_1a9067bbbd
    port map (
      ce_1 => ce_1_sg_x430,
      clk_1 => clk_1_sg_x430,
      din => dmux1_q_net_x1,
      dout => reinterpret1_output_port_net_x5
    );

  din0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret2_output_port_net_x5,
      q => din0_q_net
    );

  din2: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reinterpret1_output_port_net_x7,
      q => din2_q_net_x1
    );

  dmux0: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux0_y_net,
      q => dmux0_q_net_x2
    );

  dmux1: entity work.delay_0c0a0420a6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => mux1_y_net,
      q => dmux1_q_net_x1
    );

  dsync0: entity work.delay_0341f7be44
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d(0) => delay0_q_net_x5,
      q(0) => dsync0_q_net
    );

  dsync1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x430,
      clk => clk_1_sg_x430,
      clr => '0',
      d(0) => dsync0_q_net,
      q(0) => dsync1_q_net_x0
    );

  mux0: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x430,
      clk => clk_1_sg_x430,
      clr => '0',
      d0 => reinterpret1_output_port_net_x2,
      d1 => din0_q_net,
      sel(0) => slice1_y_net,
      y => mux0_y_net
    );

  mux1: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x430,
      clk => clk_1_sg_x430,
      clr => '0',
      d0 => din0_q_net,
      d1 => reinterpret1_output_port_net_x2,
      sel(0) => slice1_y_net,
      y => mux1_y_net
    );

  slice0: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 11,
      y_width => 1
    )
    port map (
      x => delay11_q_net_x8,
      y(0) => slice0_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => counter_op_net,
      y(0) => slice1_y_net
    );

  sync_delay_03e3a77bfa: entity work.sync_delay_entity_03e3a77bfa
    port map (
      ce_1 => ce_1_sg_x430,
      clk_1 => clk_1_sg_x430,
      in_x0 => dsync1_q_net_x0,
      out_x0 => mux_y_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x/biplex_core"

entity biplex_core_entity_7d6e890ad3 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pol1: in std_logic_vector(35 downto 0); 
    pol2: in std_logic_vector(35 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    out1: out std_logic_vector(35 downto 0); 
    out2: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end biplex_core_entity_7d6e890ad3;

architecture structural of biplex_core_entity_7d6e890ad3 is
  signal ce_1_sg_x431: std_logic;
  signal clk_1_sg_x431: std_logic;
  signal delay0_q_net_x11: std_logic;
  signal delay0_q_net_x2: std_logic;
  signal delay0_q_net_x3: std_logic;
  signal delay0_q_net_x4: std_logic;
  signal delay0_q_net_x5: std_logic;
  signal delay0_q_net_x6: std_logic;
  signal delay0_q_net_x7: std_logic;
  signal delay0_q_net_x8: std_logic;
  signal delay0_q_net_x9: std_logic;
  signal delay10_q_net_x1: std_logic;
  signal delay11_q_net_x9: std_logic_vector(10 downto 0);
  signal reinterpret1_output_port_net_x10: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x14: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x15: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x16: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x17: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x18: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x24: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x10: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x7: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x8: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x9: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x431 <= ce_1;
  clk_1_sg_x431 <= clk_1;
  reinterpret1_output_port_net_x18 <= pol1;
  reinterpret1_output_port_net_x11 <= pol2;
  delay11_q_net_x9 <= shift;
  delay10_q_net_x1 <= sync;
  out1 <= reinterpret2_output_port_net_x12;
  out2 <= reinterpret1_output_port_net_x24;
  sync_out <= delay0_q_net_x11;

  fft_stage_1_034856f8b2: entity work.fft_stage_1_entity_034856f8b2
    port map (
      ce_1 => ce_1_sg_x431,
      clk_1 => clk_1_sg_x431,
      in1 => reinterpret1_output_port_net_x18,
      in2 => reinterpret1_output_port_net_x11,
      shift => delay11_q_net_x9,
      sync => delay10_q_net_x1,
      out1 => reinterpret2_output_port_net_x3,
      out2 => reinterpret1_output_port_net_x10,
      sync_out => delay0_q_net_x2
    );

  fft_stage_2_4375fddaf7: entity work.fft_stage_2_entity_4375fddaf7
    port map (
      ce_1 => ce_1_sg_x431,
      clk_1 => clk_1_sg_x431,
      in1 => reinterpret2_output_port_net_x3,
      in2 => reinterpret1_output_port_net_x10,
      shift => delay11_q_net_x9,
      sync => delay0_q_net_x2,
      out1 => reinterpret2_output_port_net_x5,
      out2 => reinterpret1_output_port_net_x12,
      sync_out => delay0_q_net_x4
    );

  fft_stage_3_c0581b89be: entity work.fft_stage_3_entity_c0581b89be
    port map (
      ce_1 => ce_1_sg_x431,
      clk_1 => clk_1_sg_x431,
      in1 => reinterpret2_output_port_net_x5,
      in2 => reinterpret1_output_port_net_x12,
      shift => delay11_q_net_x9,
      sync => delay0_q_net_x4,
      out1 => reinterpret2_output_port_net_x7,
      out2 => reinterpret1_output_port_net_x14,
      sync_out => delay0_q_net_x6
    );

  fft_stage_4_a2df2ada34: entity work.fft_stage_4_entity_a2df2ada34
    port map (
      ce_1 => ce_1_sg_x431,
      clk_1 => clk_1_sg_x431,
      in1 => reinterpret2_output_port_net_x7,
      in2 => reinterpret1_output_port_net_x14,
      shift => delay11_q_net_x9,
      sync => delay0_q_net_x6,
      out1 => reinterpret2_output_port_net_x4,
      out2 => reinterpret1_output_port_net_x7,
      sync_out => delay0_q_net_x3
    );

  fft_stage_5_59ea763c91: entity work.fft_stage_5_entity_59ea763c91
    port map (
      ce_1 => ce_1_sg_x431,
      clk_1 => clk_1_sg_x431,
      in1 => reinterpret2_output_port_net_x4,
      in2 => reinterpret1_output_port_net_x7,
      shift => delay11_q_net_x9,
      sync => delay0_q_net_x3,
      out1 => reinterpret2_output_port_net_x6,
      out2 => reinterpret1_output_port_net_x9,
      sync_out => delay0_q_net_x5
    );

  fft_stage_6_d40c47c187: entity work.fft_stage_6_entity_d40c47c187
    port map (
      ce_1 => ce_1_sg_x431,
      clk_1 => clk_1_sg_x431,
      in1 => reinterpret2_output_port_net_x6,
      in2 => reinterpret1_output_port_net_x9,
      shift => delay11_q_net_x9,
      sync => delay0_q_net_x5,
      out1 => reinterpret2_output_port_net_x8,
      out2 => reinterpret1_output_port_net_x15,
      sync_out => delay0_q_net_x7
    );

  fft_stage_7_6fa5bc8de3: entity work.fft_stage_7_entity_6fa5bc8de3
    port map (
      ce_1 => ce_1_sg_x431,
      clk_1 => clk_1_sg_x431,
      in1 => reinterpret2_output_port_net_x8,
      in2 => reinterpret1_output_port_net_x15,
      shift => delay11_q_net_x9,
      sync => delay0_q_net_x7,
      out1 => reinterpret2_output_port_net_x9,
      out2 => reinterpret1_output_port_net_x16,
      sync_out => delay0_q_net_x8
    );

  fft_stage_8_5893958c25: entity work.fft_stage_8_entity_5893958c25
    port map (
      ce_1 => ce_1_sg_x431,
      clk_1 => clk_1_sg_x431,
      in1 => reinterpret2_output_port_net_x9,
      in2 => reinterpret1_output_port_net_x16,
      shift => delay11_q_net_x9,
      sync => delay0_q_net_x8,
      out1 => reinterpret2_output_port_net_x10,
      out2 => reinterpret1_output_port_net_x17,
      sync_out => delay0_q_net_x9
    );

  fft_stage_9_ba3a650d43: entity work.fft_stage_9_entity_ba3a650d43
    port map (
      ce_1 => ce_1_sg_x431,
      clk_1 => clk_1_sg_x431,
      in1 => reinterpret2_output_port_net_x10,
      in2 => reinterpret1_output_port_net_x17,
      shift => delay11_q_net_x9,
      sync => delay0_q_net_x9,
      out1 => reinterpret2_output_port_net_x12,
      out2 => reinterpret1_output_port_net_x24,
      sync_out => delay0_q_net_x11
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_biplex_real_4x"

entity fft_biplex_real_4x_entity_a1cfde3192 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pol0_in: in std_logic_vector(17 downto 0); 
    pol1_in: in std_logic_vector(17 downto 0); 
    pol2_in: in std_logic_vector(17 downto 0); 
    pol3_in: in std_logic_vector(17 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    pol0_out: out std_logic_vector(35 downto 0); 
    pol1_out: out std_logic_vector(35 downto 0); 
    pol2_out: out std_logic_vector(35 downto 0); 
    pol3_out: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_biplex_real_4x_entity_a1cfde3192;

architecture structural of fft_biplex_real_4x_entity_a1cfde3192 is
  signal ce_1_sg_x432: std_logic;
  signal clk_1_sg_x432: std_logic;
  signal concat_y_net_x1: std_logic_vector(35 downto 0);
  signal concat_y_net_x2: std_logic_vector(35 downto 0);
  signal delay0_q_net_x11: std_logic;
  signal delay10_q_net_x2: std_logic;
  signal delay11_q_net_x10: std_logic_vector(10 downto 0);
  signal delay16_q_net_x1: std_logic_vector(17 downto 0);
  signal delay17_q_net_x1: std_logic_vector(17 downto 0);
  signal delay18_q_net_x1: std_logic_vector(17 downto 0);
  signal delay19_q_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x19: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x22: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x23: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x24: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x25: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x26: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x12: std_logic_vector(35 downto 0);
  signal sync_delay1_q_net_x2: std_logic;

begin
  ce_1_sg_x432 <= ce_1;
  clk_1_sg_x432 <= clk_1;
  delay16_q_net_x1 <= pol0_in;
  delay17_q_net_x1 <= pol1_in;
  delay18_q_net_x1 <= pol2_in;
  delay19_q_net_x1 <= pol3_in;
  delay11_q_net_x10 <= shift;
  delay10_q_net_x2 <= sync;
  pol0_out <= reinterpret1_output_port_net_x4;
  pol1_out <= reinterpret1_output_port_net_x5;
  pol2_out <= reinterpret1_output_port_net_x6;
  pol3_out <= reinterpret1_output_port_net_x7;
  sync_out <= sync_delay1_q_net_x2;

  bi_real_unscr_4x_73f633bed2: entity work.bi_real_unscr_4x_entity_73f633bed2
    port map (
      ce_1 => ce_1_sg_x432,
      clk_1 => clk_1_sg_x432,
      even => reinterpret2_output_port_net_x12,
      odd => reinterpret1_output_port_net_x26,
      sync => delay0_q_net_x11,
      pol1_out => reinterpret1_output_port_net_x22,
      pol2_out => reinterpret1_output_port_net_x23,
      pol3_out => reinterpret1_output_port_net_x24,
      pol4_out => reinterpret1_output_port_net_x25,
      sync_out => sync_delay1_q_net_x2
    );

  biplex_core_7d6e890ad3: entity work.biplex_core_entity_7d6e890ad3
    port map (
      ce_1 => ce_1_sg_x432,
      clk_1 => clk_1_sg_x432,
      pol1 => reinterpret1_output_port_net_x19,
      pol2 => reinterpret1_output_port_net_x12,
      shift => delay11_q_net_x10,
      sync => delay10_q_net_x2,
      out1 => reinterpret2_output_port_net_x12,
      out2 => reinterpret1_output_port_net_x26,
      sync_out => delay0_q_net_x11
    );

  even_bussify_fc1bbfd872: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => concat_y_net_x1,
      bus_out => reinterpret1_output_port_net_x19
    );

  odd_bussify_806f9c2f87: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => concat_y_net_x2,
      bus_out => reinterpret1_output_port_net_x12
    );

  pol0_debus_878b71926e: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret1_output_port_net_x22,
      msb_lsb_out1 => reinterpret1_output_port_net_x4
    );

  pol1_debus_93b01381af: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret1_output_port_net_x23,
      msb_lsb_out1 => reinterpret1_output_port_net_x5
    );

  pol2_debus_dca7955e48: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret1_output_port_net_x24,
      msb_lsb_out1 => reinterpret1_output_port_net_x6
    );

  pol3_debus_45cd832a2a: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret1_output_port_net_x25,
      msb_lsb_out1 => reinterpret1_output_port_net_x7
    );

  ri_to_c0_16f9729d0d: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => delay17_q_net_x1,
      re => delay16_q_net_x1,
      c => concat_y_net_x1
    );

  ri_to_c1_e71ddbee4d: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => delay19_q_net_x1,
      re => delay18_q_net_x1,
      c => concat_y_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_add/op_bussify"

entity op_bussify_entity_5e6cc6bcf6 is
  port (
    in1: in std_logic_vector(19 downto 0); 
    in2: in std_logic_vector(19 downto 0); 
    in3: in std_logic_vector(19 downto 0); 
    in4: in std_logic_vector(19 downto 0); 
    bus_out: out std_logic_vector(79 downto 0)
  );
end op_bussify_entity_5e6cc6bcf6;

architecture structural of op_bussify_entity_5e6cc6bcf6 is
  signal addsub1_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub2_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub3_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub4_s_net_x0: std_logic_vector(19 downto 0);
  signal concatenate_y_net_x0: std_logic_vector(79 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(19 downto 0);

begin
  addsub1_s_net_x0 <= in1;
  addsub2_s_net_x0 <= in2;
  addsub3_s_net_x0 <= in3;
  addsub4_s_net_x0 <= in4;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_f86ebb6084
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub1_s_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub2_s_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub3_s_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub4_s_net_x0,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_add"

entity bus_add_entity_da476ff50b is
  port (
    a: in std_logic_vector(71 downto 0); 
    b: in std_logic_vector(75 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    dout: out std_logic_vector(79 downto 0)
  );
end bus_add_entity_da476ff50b;

architecture structural of bus_add_entity_da476ff50b is
  signal addsub1_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub2_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub3_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub4_s_net_x0: std_logic_vector(19 downto 0);
  signal ce_1_sg_x433: std_logic;
  signal clk_1_sg_x433: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(79 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(18 downto 0);

begin
  reinterpret1_output_port_net_x3 <= a;
  concatenate_y_net_x2 <= b;
  ce_1_sg_x433 <= ce_1;
  clk_1_sg_x433 <= clk_1;
  dout <= concatenate_y_net_x3;

  a_debus_d9d38a7da0: entity work.a_expand_entity_c51fa07742
    port map (
      bus_in => reinterpret1_output_port_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out4 => reinterpret4_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0
    );

  addsub1: entity work.addsub_c1b57d7d0a
    port map (
      a => reinterpret4_output_port_net_x0,
      b => reinterpret4_output_port_net_x1,
      ce => ce_1_sg_x433,
      clk => clk_1_sg_x433,
      clr => '0',
      s => addsub1_s_net_x0
    );

  addsub2: entity work.addsub_c1b57d7d0a
    port map (
      a => reinterpret3_output_port_net_x0,
      b => reinterpret3_output_port_net_x1,
      ce => ce_1_sg_x433,
      clk => clk_1_sg_x433,
      clr => '0',
      s => addsub2_s_net_x0
    );

  addsub3: entity work.addsub_c1b57d7d0a
    port map (
      a => reinterpret2_output_port_net_x0,
      b => reinterpret2_output_port_net_x1,
      ce => ce_1_sg_x433,
      clk => clk_1_sg_x433,
      clr => '0',
      s => addsub3_s_net_x0
    );

  addsub4: entity work.addsub_c1b57d7d0a
    port map (
      a => reinterpret1_output_port_net_x2,
      b => reinterpret1_output_port_net_x0,
      ce => ce_1_sg_x433,
      clk => clk_1_sg_x433,
      clr => '0',
      s => addsub4_s_net_x0
    );

  b_debus_b673682cdd: entity work.debus_entity_4d0b597c59
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

  op_bussify_5e6cc6bcf6: entity work.op_bussify_entity_5e6cc6bcf6
    port map (
      in1 => addsub1_s_net_x0,
      in2 => addsub2_s_net_x0,
      in3 => addsub3_s_net_x0,
      in4 => addsub4_s_net_x0,
      bus_out => concatenate_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_convert/bussify"

entity bussify_entity_86d13346e4 is
  port (
    in1: in std_logic_vector(17 downto 0); 
    in2: in std_logic_vector(17 downto 0); 
    in3: in std_logic_vector(17 downto 0); 
    in4: in std_logic_vector(17 downto 0); 
    in5: in std_logic_vector(17 downto 0); 
    in6: in std_logic_vector(17 downto 0); 
    in7: in std_logic_vector(17 downto 0); 
    in8: in std_logic_vector(17 downto 0); 
    bus_out: out std_logic_vector(143 downto 0)
  );
end bussify_entity_86d13346e4;

architecture structural of bussify_entity_86d13346e4 is
  signal adder_s_net_x10: std_logic_vector(17 downto 0);
  signal adder_s_net_x11: std_logic_vector(17 downto 0);
  signal adder_s_net_x12: std_logic_vector(17 downto 0);
  signal adder_s_net_x13: std_logic_vector(17 downto 0);
  signal adder_s_net_x14: std_logic_vector(17 downto 0);
  signal adder_s_net_x7: std_logic_vector(17 downto 0);
  signal adder_s_net_x8: std_logic_vector(17 downto 0);
  signal adder_s_net_x9: std_logic_vector(17 downto 0);
  signal concatenate_y_net_x0: std_logic_vector(143 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret5_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret8_output_port_net: std_logic_vector(17 downto 0);

begin
  adder_s_net_x7 <= in1;
  adder_s_net_x8 <= in2;
  adder_s_net_x9 <= in3;
  adder_s_net_x10 <= in4;
  adder_s_net_x11 <= in5;
  adder_s_net_x12 <= in6;
  adder_s_net_x13 <= in7;
  adder_s_net_x14 <= in8;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_341bdeba15
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      in4 => reinterpret5_output_port_net,
      in5 => reinterpret6_output_port_net,
      in6 => reinterpret7_output_port_net,
      in7 => reinterpret8_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x7,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x8,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x9,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x10,
      output_port => reinterpret4_output_port_net
    );

  reinterpret5: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x11,
      output_port => reinterpret5_output_port_net
    );

  reinterpret6: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x12,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x13,
      output_port => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x14,
      output_port => reinterpret8_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_convert/debus"

entity debus_entity_1a8b27754e is
  port (
    bus_in: in std_logic_vector(167 downto 0); 
    lsb_out1: out std_logic_vector(20 downto 0); 
    msb_out8: out std_logic_vector(20 downto 0); 
    out2: out std_logic_vector(20 downto 0); 
    out3: out std_logic_vector(20 downto 0); 
    out4: out std_logic_vector(20 downto 0); 
    out5: out std_logic_vector(20 downto 0); 
    out6: out std_logic_vector(20 downto 0); 
    out7: out std_logic_vector(20 downto 0)
  );
end debus_entity_1a8b27754e;

architecture structural of debus_entity_1a8b27754e is
  signal concatenate_y_net_x0: std_logic_vector(167 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret5_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret6_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret7_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret8_output_port_net_x2: std_logic_vector(20 downto 0);
  signal slice1_y_net: std_logic_vector(20 downto 0);
  signal slice2_y_net: std_logic_vector(20 downto 0);
  signal slice3_y_net: std_logic_vector(20 downto 0);
  signal slice4_y_net: std_logic_vector(20 downto 0);
  signal slice5_y_net: std_logic_vector(20 downto 0);
  signal slice6_y_net: std_logic_vector(20 downto 0);
  signal slice7_y_net: std_logic_vector(20 downto 0);
  signal slice8_y_net: std_logic_vector(20 downto 0);

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x2;
  msb_out8 <= reinterpret8_output_port_net_x2;
  out2 <= reinterpret2_output_port_net_x2;
  out3 <= reinterpret3_output_port_net_x2;
  out4 <= reinterpret4_output_port_net_x2;
  out5 <= reinterpret5_output_port_net_x2;
  out6 <= reinterpret6_output_port_net_x2;
  out7 <= reinterpret7_output_port_net_x2;

  reinterpret1: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x2
    );

  reinterpret2: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x2
    );

  reinterpret3: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x2
    );

  reinterpret4: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x2
    );

  reinterpret5: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice5_y_net,
      output_port => reinterpret5_output_port_net_x2
    );

  reinterpret6: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice6_y_net,
      output_port => reinterpret6_output_port_net_x2
    );

  reinterpret7: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice7_y_net,
      output_port => reinterpret7_output_port_net_x2
    );

  reinterpret8: entity work.reinterpret_d357e69fa3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice8_y_net,
      output_port => reinterpret8_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 20,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 21,
      new_msb => 41,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 42,
      new_msb => 62,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 63,
      new_msb => 83,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice4_y_net
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 84,
      new_msb => 104,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice5_y_net
    );

  slice6: entity work.xlslice
    generic map (
      new_lsb => 105,
      new_msb => 125,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice6_y_net
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 126,
      new_msb => 146,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice7_y_net
    );

  slice8: entity work.xlslice
    generic map (
      new_lsb => 147,
      new_msb => 167,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice8_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_convert"

entity bus_convert_entity_d2f13e5121 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(167 downto 0); 
    dout: out std_logic_vector(143 downto 0)
  );
end bus_convert_entity_d2f13e5121;

architecture structural of bus_convert_entity_d2f13e5121 is
  signal adder_s_net_x10: std_logic_vector(17 downto 0);
  signal adder_s_net_x11: std_logic_vector(17 downto 0);
  signal adder_s_net_x12: std_logic_vector(17 downto 0);
  signal adder_s_net_x13: std_logic_vector(17 downto 0);
  signal adder_s_net_x14: std_logic_vector(17 downto 0);
  signal adder_s_net_x15: std_logic_vector(17 downto 0);
  signal adder_s_net_x16: std_logic_vector(17 downto 0);
  signal adder_s_net_x9: std_logic_vector(17 downto 0);
  signal ce_1_sg_x450: std_logic;
  signal clk_1_sg_x450: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(167 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(143 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret5_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret6_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret7_output_port_net_x2: std_logic_vector(20 downto 0);
  signal reinterpret8_output_port_net_x2: std_logic_vector(20 downto 0);

begin
  ce_1_sg_x450 <= ce_1;
  clk_1_sg_x450 <= clk_1;
  concatenate_y_net_x2 <= din;
  dout <= concatenate_y_net_x3;

  bussify_86d13346e4: entity work.bussify_entity_86d13346e4
    port map (
      in1 => adder_s_net_x9,
      in2 => adder_s_net_x10,
      in3 => adder_s_net_x11,
      in4 => adder_s_net_x12,
      in5 => adder_s_net_x13,
      in6 => adder_s_net_x14,
      in7 => adder_s_net_x15,
      in8 => adder_s_net_x16,
      bus_out => concatenate_y_net_x3
    );

  conv1_fe8ce6ff6e: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x450,
      clk_1 => clk_1_sg_x450,
      din => reinterpret8_output_port_net_x2,
      dout => adder_s_net_x9
    );

  conv2_ebfbebd70b: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x450,
      clk_1 => clk_1_sg_x450,
      din => reinterpret7_output_port_net_x2,
      dout => adder_s_net_x10
    );

  conv3_55a74a15f8: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x450,
      clk_1 => clk_1_sg_x450,
      din => reinterpret6_output_port_net_x2,
      dout => adder_s_net_x11
    );

  conv4_e9a54caa3f: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x450,
      clk_1 => clk_1_sg_x450,
      din => reinterpret5_output_port_net_x2,
      dout => adder_s_net_x12
    );

  conv5_cbc63e1f26: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x450,
      clk_1 => clk_1_sg_x450,
      din => reinterpret4_output_port_net_x2,
      dout => adder_s_net_x13
    );

  conv6_aeff48d3b1: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x450,
      clk_1 => clk_1_sg_x450,
      din => reinterpret3_output_port_net_x2,
      dout => adder_s_net_x14
    );

  conv7_b5144a0fbe: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x450,
      clk_1 => clk_1_sg_x450,
      din => reinterpret2_output_port_net_x2,
      dout => adder_s_net_x15
    );

  conv8_a12a0d430a: entity work.conv1_entity_f1cf70b581
    port map (
      ce_1 => ce_1_sg_x450,
      clk_1 => clk_1_sg_x450,
      din => reinterpret1_output_port_net_x2,
      dout => adder_s_net_x16
    );

  debus_1a8b27754e: entity work.debus_entity_1a8b27754e
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out8 => reinterpret8_output_port_net_x2,
      out2 => reinterpret2_output_port_net_x2,
      out3 => reinterpret3_output_port_net_x2,
      out4 => reinterpret4_output_port_net_x2,
      out5 => reinterpret5_output_port_net_x2,
      out6 => reinterpret6_output_port_net_x2,
      out7 => reinterpret7_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_expand"

entity bus_expand_entity_c7f62b43f8 is
  port (
    bus_in: in std_logic_vector(143 downto 0); 
    lsb_out1: out std_logic_vector(71 downto 0); 
    msb_out2: out std_logic_vector(71 downto 0)
  );
end bus_expand_entity_c7f62b43f8;

architecture structural of bus_expand_entity_c7f62b43f8 is
  signal concatenate_y_net_x4: std_logic_vector(143 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(71 downto 0);
  signal slice1_y_net: std_logic_vector(71 downto 0);
  signal slice2_y_net: std_logic_vector(71 downto 0);

begin
  concatenate_y_net_x4 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x2;
  msb_out2 <= reinterpret2_output_port_net_x2;

  reinterpret1: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x2
    );

  reinterpret2: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 71,
      x_width => 144,
      y_width => 72
    )
    port map (
      x => concatenate_y_net_x4,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 72,
      new_msb => 143,
      x_width => 144,
      y_width => 72
    )
    port map (
      x => concatenate_y_net_x4,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_norm0/bussify"

entity bussify_entity_082ccba906 is
  port (
    in1: in std_logic_vector(20 downto 0); 
    in2: in std_logic_vector(20 downto 0); 
    in3: in std_logic_vector(20 downto 0); 
    in4: in std_logic_vector(20 downto 0); 
    in5: in std_logic_vector(20 downto 0); 
    in6: in std_logic_vector(20 downto 0); 
    in7: in std_logic_vector(20 downto 0); 
    in8: in std_logic_vector(20 downto 0); 
    bus_out: out std_logic_vector(167 downto 0)
  );
end bussify_entity_082ccba906;

architecture structural of bussify_entity_082ccba906 is
  signal concatenate_y_net_x0: std_logic_vector(167 downto 0);
  signal conv1_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv2_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv3_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv4_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv5_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv6_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv7_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv8_dout_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret5_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret8_output_port_net: std_logic_vector(20 downto 0);

begin
  conv1_dout_net_x0 <= in1;
  conv2_dout_net_x0 <= in2;
  conv3_dout_net_x0 <= in3;
  conv4_dout_net_x0 <= in4;
  conv5_dout_net_x0 <= in5;
  conv6_dout_net_x0 <= in6;
  conv7_dout_net_x0 <= in7;
  conv8_dout_net_x0 <= in8;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_7cb1306ccc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      in4 => reinterpret5_output_port_net,
      in5 => reinterpret6_output_port_net,
      in6 => reinterpret7_output_port_net,
      in7 => reinterpret8_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv1_dout_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv2_dout_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv3_dout_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv4_dout_net_x0,
      output_port => reinterpret4_output_port_net
    );

  reinterpret5: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv5_dout_net_x0,
      output_port => reinterpret5_output_port_net
    );

  reinterpret6: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv6_dout_net_x0,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv7_dout_net_x0,
      output_port => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_f0ca8483cb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => conv8_dout_net_x0,
      output_port => reinterpret8_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_norm0/debus"

entity debus_entity_d4c2d14787 is
  port (
    bus_in: in std_logic_vector(159 downto 0); 
    lsb_out1: out std_logic_vector(19 downto 0); 
    msb_out8: out std_logic_vector(19 downto 0); 
    out2: out std_logic_vector(19 downto 0); 
    out3: out std_logic_vector(19 downto 0); 
    out4: out std_logic_vector(19 downto 0); 
    out5: out std_logic_vector(19 downto 0); 
    out6: out std_logic_vector(19 downto 0); 
    out7: out std_logic_vector(19 downto 0)
  );
end debus_entity_d4c2d14787;

architecture structural of debus_entity_d4c2d14787 is
  signal concat_y_net_x0: std_logic_vector(159 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret5_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret6_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret7_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret8_output_port_net_x0: std_logic_vector(19 downto 0);
  signal slice1_y_net: std_logic_vector(19 downto 0);
  signal slice2_y_net: std_logic_vector(19 downto 0);
  signal slice3_y_net: std_logic_vector(19 downto 0);
  signal slice4_y_net: std_logic_vector(19 downto 0);
  signal slice5_y_net: std_logic_vector(19 downto 0);
  signal slice6_y_net: std_logic_vector(19 downto 0);
  signal slice7_y_net: std_logic_vector(19 downto 0);
  signal slice8_y_net: std_logic_vector(19 downto 0);

begin
  concat_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out8 <= reinterpret8_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;
  out4 <= reinterpret4_output_port_net_x0;
  out5 <= reinterpret5_output_port_net_x0;
  out6 <= reinterpret6_output_port_net_x0;
  out7 <= reinterpret7_output_port_net_x0;

  reinterpret1: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  reinterpret5: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice5_y_net,
      output_port => reinterpret5_output_port_net_x0
    );

  reinterpret6: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice6_y_net,
      output_port => reinterpret6_output_port_net_x0
    );

  reinterpret7: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice7_y_net,
      output_port => reinterpret7_output_port_net_x0
    );

  reinterpret8: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice8_y_net,
      output_port => reinterpret8_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 19,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 20,
      new_msb => 39,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 40,
      new_msb => 59,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 60,
      new_msb => 79,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice4_y_net
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 80,
      new_msb => 99,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice5_y_net
    );

  slice6: entity work.xlslice
    generic map (
      new_lsb => 100,
      new_msb => 119,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice6_y_net
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 120,
      new_msb => 139,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice7_y_net
    );

  slice8: entity work.xlslice
    generic map (
      new_lsb => 140,
      new_msb => 159,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concat_y_net_x0,
      y => slice8_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_norm0"

entity bus_norm0_entity_100a42851b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(159 downto 0); 
    dout: out std_logic_vector(167 downto 0)
  );
end bus_norm0_entity_100a42851b;

architecture structural of bus_norm0_entity_100a42851b is
  signal ce_1_sg_x451: std_logic;
  signal clk_1_sg_x451: std_logic;
  signal concat_y_net_x1: std_logic_vector(159 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(167 downto 0);
  signal conv1_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv2_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv3_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv4_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv5_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv6_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv7_dout_net_x0: std_logic_vector(20 downto 0);
  signal conv8_dout_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret5_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret6_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret7_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret8_output_port_net_x0: std_logic_vector(19 downto 0);

begin
  ce_1_sg_x451 <= ce_1;
  clk_1_sg_x451 <= clk_1;
  concat_y_net_x1 <= din;
  dout <= concatenate_y_net_x1;

  bussify_082ccba906: entity work.bussify_entity_082ccba906
    port map (
      in1 => conv1_dout_net_x0,
      in2 => conv2_dout_net_x0,
      in3 => conv3_dout_net_x0,
      in4 => conv4_dout_net_x0,
      in5 => conv5_dout_net_x0,
      in6 => conv6_dout_net_x0,
      in7 => conv7_dout_net_x0,
      in8 => conv8_dout_net_x0,
      bus_out => concatenate_y_net_x1
    );

  conv1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x451,
      clk => clk_1_sg_x451,
      clr => '0',
      din => reinterpret8_output_port_net_x0,
      en => "1",
      dout => conv1_dout_net_x0
    );

  conv2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x451,
      clk => clk_1_sg_x451,
      clr => '0',
      din => reinterpret7_output_port_net_x0,
      en => "1",
      dout => conv2_dout_net_x0
    );

  conv3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x451,
      clk => clk_1_sg_x451,
      clr => '0',
      din => reinterpret6_output_port_net_x0,
      en => "1",
      dout => conv3_dout_net_x0
    );

  conv4: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x451,
      clk => clk_1_sg_x451,
      clr => '0',
      din => reinterpret5_output_port_net_x0,
      en => "1",
      dout => conv4_dout_net_x0
    );

  conv5: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x451,
      clk => clk_1_sg_x451,
      clr => '0',
      din => reinterpret4_output_port_net_x0,
      en => "1",
      dout => conv5_dout_net_x0
    );

  conv6: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x451,
      clk => clk_1_sg_x451,
      clr => '0',
      din => reinterpret3_output_port_net_x0,
      en => "1",
      dout => conv6_dout_net_x0
    );

  conv7: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x451,
      clk => clk_1_sg_x451,
      clr => '0',
      din => reinterpret2_output_port_net_x0,
      en => "1",
      dout => conv7_dout_net_x0
    );

  conv8: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x451,
      clk => clk_1_sg_x451,
      clr => '0',
      din => reinterpret1_output_port_net_x0,
      en => "1",
      dout => conv8_dout_net_x0
    );

  debus_d4c2d14787: entity work.debus_entity_d4c2d14787
    port map (
      bus_in => concat_y_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out8 => reinterpret8_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0,
      out4 => reinterpret4_output_port_net_x0,
      out5 => reinterpret5_output_port_net_x0,
      out6 => reinterpret6_output_port_net_x0,
      out7 => reinterpret7_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_norm1/debus"

entity debus_entity_2c91a20592 is
  port (
    bus_in: in std_logic_vector(159 downto 0); 
    lsb_out1: out std_logic_vector(19 downto 0); 
    msb_out8: out std_logic_vector(19 downto 0); 
    out2: out std_logic_vector(19 downto 0); 
    out3: out std_logic_vector(19 downto 0); 
    out4: out std_logic_vector(19 downto 0); 
    out5: out std_logic_vector(19 downto 0); 
    out6: out std_logic_vector(19 downto 0); 
    out7: out std_logic_vector(19 downto 0)
  );
end debus_entity_2c91a20592;

architecture structural of debus_entity_2c91a20592 is
  signal concatenate_y_net_x0: std_logic_vector(159 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret5_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret6_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret7_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret8_output_port_net_x1: std_logic_vector(19 downto 0);
  signal slice1_y_net: std_logic_vector(19 downto 0);
  signal slice2_y_net: std_logic_vector(19 downto 0);
  signal slice3_y_net: std_logic_vector(19 downto 0);
  signal slice4_y_net: std_logic_vector(19 downto 0);
  signal slice5_y_net: std_logic_vector(19 downto 0);
  signal slice6_y_net: std_logic_vector(19 downto 0);
  signal slice7_y_net: std_logic_vector(19 downto 0);
  signal slice8_y_net: std_logic_vector(19 downto 0);

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x1;
  msb_out8 <= reinterpret8_output_port_net_x1;
  out2 <= reinterpret2_output_port_net_x1;
  out3 <= reinterpret3_output_port_net_x1;
  out4 <= reinterpret4_output_port_net_x1;
  out5 <= reinterpret5_output_port_net_x1;
  out6 <= reinterpret6_output_port_net_x1;
  out7 <= reinterpret7_output_port_net_x1;

  reinterpret1: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x1
    );

  reinterpret2: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x1
    );

  reinterpret3: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x1
    );

  reinterpret4: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x1
    );

  reinterpret5: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice5_y_net,
      output_port => reinterpret5_output_port_net_x1
    );

  reinterpret6: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice6_y_net,
      output_port => reinterpret6_output_port_net_x1
    );

  reinterpret7: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice7_y_net,
      output_port => reinterpret7_output_port_net_x1
    );

  reinterpret8: entity work.reinterpret_f661f8d9b7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice8_y_net,
      output_port => reinterpret8_output_port_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 19,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 20,
      new_msb => 39,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 40,
      new_msb => 59,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 60,
      new_msb => 79,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice4_y_net
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 80,
      new_msb => 99,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice5_y_net
    );

  slice6: entity work.xlslice
    generic map (
      new_lsb => 100,
      new_msb => 119,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice6_y_net
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 120,
      new_msb => 139,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice7_y_net
    );

  slice8: entity work.xlslice
    generic map (
      new_lsb => 140,
      new_msb => 159,
      x_width => 160,
      y_width => 20
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice8_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_norm1"

entity bus_norm1_entity_399783b802 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(159 downto 0); 
    dout: out std_logic_vector(167 downto 0)
  );
end bus_norm1_entity_399783b802;

architecture structural of bus_norm1_entity_399783b802 is
  signal adder_s_net_x10: std_logic_vector(20 downto 0);
  signal adder_s_net_x11: std_logic_vector(20 downto 0);
  signal adder_s_net_x12: std_logic_vector(20 downto 0);
  signal adder_s_net_x13: std_logic_vector(20 downto 0);
  signal adder_s_net_x14: std_logic_vector(20 downto 0);
  signal adder_s_net_x15: std_logic_vector(20 downto 0);
  signal adder_s_net_x8: std_logic_vector(20 downto 0);
  signal adder_s_net_x9: std_logic_vector(20 downto 0);
  signal ce_1_sg_x460: std_logic;
  signal clk_1_sg_x460: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(159 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(167 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret5_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret6_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret7_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret8_output_port_net_x1: std_logic_vector(19 downto 0);

begin
  ce_1_sg_x460 <= ce_1;
  clk_1_sg_x460 <= clk_1;
  concatenate_y_net_x2 <= din;
  dout <= concatenate_y_net_x3;

  bussify_8286ac0932: entity work.bussify_entity_082ccba906
    port map (
      in1 => adder_s_net_x8,
      in2 => adder_s_net_x9,
      in3 => adder_s_net_x10,
      in4 => adder_s_net_x11,
      in5 => adder_s_net_x12,
      in6 => adder_s_net_x13,
      in7 => adder_s_net_x14,
      in8 => adder_s_net_x15,
      bus_out => concatenate_y_net_x3
    );

  conv1_2789f7126c: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x460,
      clk_1 => clk_1_sg_x460,
      in_x0 => reinterpret8_output_port_net_x1,
      out_x0 => adder_s_net_x8
    );

  conv2_725f70cc97: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x460,
      clk_1 => clk_1_sg_x460,
      in_x0 => reinterpret7_output_port_net_x1,
      out_x0 => adder_s_net_x9
    );

  conv3_cc2fff9f3a: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x460,
      clk_1 => clk_1_sg_x460,
      in_x0 => reinterpret6_output_port_net_x1,
      out_x0 => adder_s_net_x10
    );

  conv4_a1fbc0e0af: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x460,
      clk_1 => clk_1_sg_x460,
      in_x0 => reinterpret5_output_port_net_x1,
      out_x0 => adder_s_net_x11
    );

  conv5_b6571a3124: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x460,
      clk_1 => clk_1_sg_x460,
      in_x0 => reinterpret4_output_port_net_x1,
      out_x0 => adder_s_net_x12
    );

  conv6_721da03c23: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x460,
      clk_1 => clk_1_sg_x460,
      in_x0 => reinterpret3_output_port_net_x1,
      out_x0 => adder_s_net_x13
    );

  conv7_091ed5c0c8: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x460,
      clk_1 => clk_1_sg_x460,
      in_x0 => reinterpret2_output_port_net_x1,
      out_x0 => adder_s_net_x14
    );

  conv8_5c226f2efb: entity work.conv1_entity_9907950251
    port map (
      ce_1 => ce_1_sg_x460,
      clk_1 => clk_1_sg_x460,
      in_x0 => reinterpret1_output_port_net_x1,
      out_x0 => adder_s_net_x15
    );

  debus_2c91a20592: entity work.debus_entity_2c91a20592
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out8 => reinterpret8_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1,
      out4 => reinterpret4_output_port_net_x1,
      out5 => reinterpret5_output_port_net_x1,
      out6 => reinterpret6_output_port_net_x1,
      out7 => reinterpret7_output_port_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_scale/bussify"

entity bussify_entity_228a6ab0cc is
  port (
    in1: in std_logic_vector(19 downto 0); 
    in2: in std_logic_vector(19 downto 0); 
    in3: in std_logic_vector(19 downto 0); 
    in4: in std_logic_vector(19 downto 0); 
    in5: in std_logic_vector(19 downto 0); 
    in6: in std_logic_vector(19 downto 0); 
    in7: in std_logic_vector(19 downto 0); 
    in8: in std_logic_vector(19 downto 0); 
    bus_out: out std_logic_vector(159 downto 0)
  );
end bussify_entity_228a6ab0cc;

architecture structural of bussify_entity_228a6ab0cc is
  signal concatenate_y_net_x3: std_logic_vector(159 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret5_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret8_output_port_net: std_logic_vector(19 downto 0);
  signal scale1_op_net_x0: std_logic_vector(19 downto 0);
  signal scale2_op_net_x0: std_logic_vector(19 downto 0);
  signal scale3_op_net_x0: std_logic_vector(19 downto 0);
  signal scale4_op_net_x0: std_logic_vector(19 downto 0);
  signal scale5_op_net_x0: std_logic_vector(19 downto 0);
  signal scale6_op_net_x0: std_logic_vector(19 downto 0);
  signal scale7_op_net_x0: std_logic_vector(19 downto 0);
  signal scale8_op_net_x0: std_logic_vector(19 downto 0);

begin
  scale1_op_net_x0 <= in1;
  scale2_op_net_x0 <= in2;
  scale3_op_net_x0 <= in3;
  scale4_op_net_x0 <= in4;
  scale5_op_net_x0 <= in5;
  scale6_op_net_x0 <= in6;
  scale7_op_net_x0 <= in7;
  scale8_op_net_x0 <= in8;
  bus_out <= concatenate_y_net_x3;

  concatenate: entity work.concat_babbadab38
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      in4 => reinterpret5_output_port_net,
      in5 => reinterpret6_output_port_net,
      in6 => reinterpret7_output_port_net,
      in7 => reinterpret8_output_port_net,
      y => concatenate_y_net_x3
    );

  reinterpret1: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale1_op_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale2_op_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale3_op_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale4_op_net_x0,
      output_port => reinterpret4_output_port_net
    );

  reinterpret5: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale5_op_net_x0,
      output_port => reinterpret5_output_port_net
    );

  reinterpret6: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale6_op_net_x0,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale7_op_net_x0,
      output_port => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_4a8cbc85ce
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => scale8_op_net_x0,
      output_port => reinterpret8_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_scale"

entity bus_scale_entity_3601d94d3d is
  port (
    din: in std_logic_vector(159 downto 0); 
    dout: out std_logic_vector(159 downto 0)
  );
end bus_scale_entity_3601d94d3d;

architecture structural of bus_scale_entity_3601d94d3d is
  signal concat_y_net_x3: std_logic_vector(159 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(159 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret5_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret6_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret7_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret8_output_port_net_x0: std_logic_vector(19 downto 0);
  signal scale1_op_net_x0: std_logic_vector(19 downto 0);
  signal scale2_op_net_x0: std_logic_vector(19 downto 0);
  signal scale3_op_net_x0: std_logic_vector(19 downto 0);
  signal scale4_op_net_x0: std_logic_vector(19 downto 0);
  signal scale5_op_net_x0: std_logic_vector(19 downto 0);
  signal scale6_op_net_x0: std_logic_vector(19 downto 0);
  signal scale7_op_net_x0: std_logic_vector(19 downto 0);
  signal scale8_op_net_x0: std_logic_vector(19 downto 0);

begin
  concat_y_net_x3 <= din;
  dout <= concatenate_y_net_x4;

  bussify_228a6ab0cc: entity work.bussify_entity_228a6ab0cc
    port map (
      in1 => scale1_op_net_x0,
      in2 => scale2_op_net_x0,
      in3 => scale3_op_net_x0,
      in4 => scale4_op_net_x0,
      in5 => scale5_op_net_x0,
      in6 => scale6_op_net_x0,
      in7 => scale7_op_net_x0,
      in8 => scale8_op_net_x0,
      bus_out => concatenate_y_net_x4
    );

  debus_82276f6d82: entity work.debus_entity_d4c2d14787
    port map (
      bus_in => concat_y_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out8 => reinterpret8_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0,
      out4 => reinterpret4_output_port_net_x0,
      out5 => reinterpret5_output_port_net_x0,
      out6 => reinterpret6_output_port_net_x0,
      out7 => reinterpret7_output_port_net_x0
    );

  scale1: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret8_output_port_net_x0,
      op => scale1_op_net_x0
    );

  scale2: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret7_output_port_net_x0,
      op => scale2_op_net_x0
    );

  scale3: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret6_output_port_net_x0,
      op => scale3_op_net_x0
    );

  scale4: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret5_output_port_net_x0,
      op => scale4_op_net_x0
    );

  scale5: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret4_output_port_net_x0,
      op => scale5_op_net_x0
    );

  scale6: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret3_output_port_net_x0,
      op => scale6_op_net_x0
    );

  scale7: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret2_output_port_net_x0,
      op => scale7_op_net_x0
    );

  scale8: entity work.scale_97239b8ed2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => reinterpret1_output_port_net_x0,
      op => scale8_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/bus_sub"

entity bus_sub_entity_379c72160f is
  port (
    a: in std_logic_vector(71 downto 0); 
    b: in std_logic_vector(75 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    dout: out std_logic_vector(79 downto 0)
  );
end bus_sub_entity_379c72160f;

architecture structural of bus_sub_entity_379c72160f is
  signal addsub1_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub2_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub3_s_net_x0: std_logic_vector(19 downto 0);
  signal addsub4_s_net_x0: std_logic_vector(19 downto 0);
  signal ce_1_sg_x461: std_logic;
  signal clk_1_sg_x461: std_logic;
  signal concatenate_y_net_x4: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(79 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(18 downto 0);

begin
  reinterpret1_output_port_net_x5 <= a;
  concatenate_y_net_x4 <= b;
  ce_1_sg_x461 <= ce_1;
  clk_1_sg_x461 <= clk_1;
  dout <= concatenate_y_net_x5;

  a_debus_be5be5196a: entity work.a_expand_entity_c51fa07742
    port map (
      bus_in => reinterpret1_output_port_net_x5,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out4 => reinterpret4_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0
    );

  addsub1: entity work.addsub_5f641f1cd5
    port map (
      a => reinterpret4_output_port_net_x0,
      b => reinterpret4_output_port_net_x1,
      ce => ce_1_sg_x461,
      clk => clk_1_sg_x461,
      clr => '0',
      s => addsub1_s_net_x0
    );

  addsub2: entity work.addsub_5f641f1cd5
    port map (
      a => reinterpret3_output_port_net_x0,
      b => reinterpret3_output_port_net_x1,
      ce => ce_1_sg_x461,
      clk => clk_1_sg_x461,
      clr => '0',
      s => addsub2_s_net_x0
    );

  addsub3: entity work.addsub_5f641f1cd5
    port map (
      a => reinterpret2_output_port_net_x0,
      b => reinterpret2_output_port_net_x1,
      ce => ce_1_sg_x461,
      clk => clk_1_sg_x461,
      clr => '0',
      s => addsub3_s_net_x0
    );

  addsub4: entity work.addsub_5f641f1cd5
    port map (
      a => reinterpret1_output_port_net_x0,
      b => reinterpret1_output_port_net_x1,
      ce => ce_1_sg_x461,
      clk => clk_1_sg_x461,
      clr => '0',
      s => addsub4_s_net_x0
    );

  b_debus_bbb7337449: entity work.debus_entity_4d0b597c59
    port map (
      bus_in => concatenate_y_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

  op_bussify_7bc5fae1f6: entity work.op_bussify_entity_5e6cc6bcf6
    port map (
      in1 => addsub1_s_net_x0,
      in2 => addsub2_s_net_x0,
      in3 => addsub3_s_net_x0,
      in4 => addsub4_s_net_x0,
      bus_out => concatenate_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/mux/d_bussify"

entity d_bussify_entity_418373d42b is
  port (
    in1: in std_logic_vector(20 downto 0); 
    in2: in std_logic_vector(20 downto 0); 
    in3: in std_logic_vector(20 downto 0); 
    in4: in std_logic_vector(20 downto 0); 
    in5: in std_logic_vector(20 downto 0); 
    in6: in std_logic_vector(20 downto 0); 
    in7: in std_logic_vector(20 downto 0); 
    in8: in std_logic_vector(20 downto 0); 
    bus_out: out std_logic_vector(167 downto 0)
  );
end d_bussify_entity_418373d42b;

architecture structural of d_bussify_entity_418373d42b is
  signal concatenate_y_net_x3: std_logic_vector(167 downto 0);
  signal mux0_y_net_x0: std_logic_vector(20 downto 0);
  signal mux1_y_net_x0: std_logic_vector(20 downto 0);
  signal mux2_y_net_x0: std_logic_vector(20 downto 0);
  signal mux3_y_net_x0: std_logic_vector(20 downto 0);
  signal mux4_y_net_x0: std_logic_vector(20 downto 0);
  signal mux5_y_net_x0: std_logic_vector(20 downto 0);
  signal mux6_y_net_x0: std_logic_vector(20 downto 0);
  signal mux7_y_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret5_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(20 downto 0);
  signal reinterpret8_output_port_net: std_logic_vector(20 downto 0);

begin
  mux0_y_net_x0 <= in1;
  mux1_y_net_x0 <= in2;
  mux2_y_net_x0 <= in3;
  mux3_y_net_x0 <= in4;
  mux4_y_net_x0 <= in5;
  mux5_y_net_x0 <= in6;
  mux6_y_net_x0 <= in7;
  mux7_y_net_x0 <= in8;
  bus_out <= concatenate_y_net_x3;

  concatenate: entity work.concat_7cb1306ccc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      in4 => reinterpret5_output_port_net,
      in5 => reinterpret6_output_port_net,
      in6 => reinterpret7_output_port_net,
      in7 => reinterpret8_output_port_net,
      y => concatenate_y_net_x3
    );

  reinterpret1: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux0_y_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux1_y_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux2_y_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux3_y_net_x0,
      output_port => reinterpret4_output_port_net
    );

  reinterpret5: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux4_y_net_x0,
      output_port => reinterpret5_output_port_net
    );

  reinterpret6: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux5_y_net_x0,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux6_y_net_x0,
      output_port => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux7_y_net_x0,
      output_port => reinterpret8_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/mux/expand0"

entity expand0_entity_066deb8cb3 is
  port (
    bus_in: in std_logic_vector(167 downto 0); 
    lsb_out1: out std_logic_vector(20 downto 0); 
    msb_out8: out std_logic_vector(20 downto 0); 
    out2: out std_logic_vector(20 downto 0); 
    out3: out std_logic_vector(20 downto 0); 
    out4: out std_logic_vector(20 downto 0); 
    out5: out std_logic_vector(20 downto 0); 
    out6: out std_logic_vector(20 downto 0); 
    out7: out std_logic_vector(20 downto 0)
  );
end expand0_entity_066deb8cb3;

architecture structural of expand0_entity_066deb8cb3 is
  signal concatenate_y_net_x2: std_logic_vector(167 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret5_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret6_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret7_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret8_output_port_net_x0: std_logic_vector(20 downto 0);
  signal slice1_y_net: std_logic_vector(20 downto 0);
  signal slice2_y_net: std_logic_vector(20 downto 0);
  signal slice3_y_net: std_logic_vector(20 downto 0);
  signal slice4_y_net: std_logic_vector(20 downto 0);
  signal slice5_y_net: std_logic_vector(20 downto 0);
  signal slice6_y_net: std_logic_vector(20 downto 0);
  signal slice7_y_net: std_logic_vector(20 downto 0);
  signal slice8_y_net: std_logic_vector(20 downto 0);

begin
  concatenate_y_net_x2 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out8 <= reinterpret8_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;
  out4 <= reinterpret4_output_port_net_x0;
  out5 <= reinterpret5_output_port_net_x0;
  out6 <= reinterpret6_output_port_net_x0;
  out7 <= reinterpret7_output_port_net_x0;

  reinterpret1: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  reinterpret5: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice5_y_net,
      output_port => reinterpret5_output_port_net_x0
    );

  reinterpret6: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice6_y_net,
      output_port => reinterpret6_output_port_net_x0
    );

  reinterpret7: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice7_y_net,
      output_port => reinterpret7_output_port_net_x0
    );

  reinterpret8: entity work.reinterpret_299ca43e25
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice8_y_net,
      output_port => reinterpret8_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 20,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 21,
      new_msb => 41,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 42,
      new_msb => 62,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 63,
      new_msb => 83,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice4_y_net
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 84,
      new_msb => 104,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice5_y_net
    );

  slice6: entity work.xlslice
    generic map (
      new_lsb => 105,
      new_msb => 125,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice6_y_net
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 126,
      new_msb => 146,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice7_y_net
    );

  slice8: entity work.xlslice
    generic map (
      new_lsb => 147,
      new_msb => 167,
      x_width => 168,
      y_width => 21
    )
    port map (
      x => concatenate_y_net_x2,
      y => slice8_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/mux/sel_expand"

entity sel_expand_entity_eee406ec75 is
  port (
    bus_in: in std_logic_vector(7 downto 0); 
    lsb_out1: out std_logic; 
    msb_out8: out std_logic; 
    out2: out std_logic; 
    out3: out std_logic; 
    out4: out std_logic; 
    out5: out std_logic; 
    out6: out std_logic; 
    out7: out std_logic
  );
end sel_expand_entity_eee406ec75;

architecture structural of sel_expand_entity_eee406ec75 is
  signal concatenate_y_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic;
  signal reinterpret2_output_port_net_x0: std_logic;
  signal reinterpret3_output_port_net_x0: std_logic;
  signal reinterpret4_output_port_net_x0: std_logic;
  signal reinterpret5_output_port_net_x0: std_logic;
  signal reinterpret6_output_port_net_x0: std_logic;
  signal reinterpret7_output_port_net_x0: std_logic;
  signal reinterpret8_output_port_net_x0: std_logic;
  signal slice1_y_net: std_logic;
  signal slice2_y_net: std_logic;
  signal slice3_y_net: std_logic;
  signal slice4_y_net: std_logic;
  signal slice5_y_net: std_logic;
  signal slice6_y_net: std_logic;
  signal slice7_y_net: std_logic;
  signal slice8_y_net: std_logic;

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out8 <= reinterpret8_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;
  out4 <= reinterpret4_output_port_net_x0;
  out5 <= reinterpret5_output_port_net_x0;
  out6 <= reinterpret6_output_port_net_x0;
  out7 <= reinterpret7_output_port_net_x0;

  reinterpret1: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice1_y_net,
      output_port(0) => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice2_y_net,
      output_port(0) => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice3_y_net,
      output_port(0) => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice4_y_net,
      output_port(0) => reinterpret4_output_port_net_x0
    );

  reinterpret5: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice5_y_net,
      output_port(0) => reinterpret5_output_port_net_x0
    );

  reinterpret6: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice6_y_net,
      output_port(0) => reinterpret6_output_port_net_x0
    );

  reinterpret7: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice7_y_net,
      output_port(0) => reinterpret7_output_port_net_x0
    );

  reinterpret8: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice8_y_net,
      output_port(0) => reinterpret8_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice4_y_net
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 4,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice5_y_net
    );

  slice6: entity work.xlslice
    generic map (
      new_lsb => 5,
      new_msb => 5,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice6_y_net
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 6,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice7_y_net
    );

  slice8: entity work.xlslice
    generic map (
      new_lsb => 7,
      new_msb => 7,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice8_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/mux"

entity mux_entity_0030050c3d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d0: in std_logic_vector(167 downto 0); 
    d1: in std_logic_vector(167 downto 0); 
    sel: in std_logic_vector(7 downto 0); 
    out_x0: out std_logic_vector(167 downto 0)
  );
end mux_entity_0030050c3d;

architecture structural of mux_entity_0030050c3d is
  signal ce_1_sg_x462: std_logic;
  signal clk_1_sg_x462: std_logic;
  signal concatenate_y_net_x5: std_logic_vector(167 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(167 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(7 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(167 downto 0);
  signal mux0_y_net_x0: std_logic_vector(20 downto 0);
  signal mux1_y_net_x0: std_logic_vector(20 downto 0);
  signal mux2_y_net_x0: std_logic_vector(20 downto 0);
  signal mux3_y_net_x0: std_logic_vector(20 downto 0);
  signal mux4_y_net_x0: std_logic_vector(20 downto 0);
  signal mux5_y_net_x0: std_logic_vector(20 downto 0);
  signal mux6_y_net_x0: std_logic_vector(20 downto 0);
  signal mux7_y_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic;
  signal reinterpret2_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic;
  signal reinterpret3_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret3_output_port_net_x2: std_logic;
  signal reinterpret4_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic;
  signal reinterpret5_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret5_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret5_output_port_net_x2: std_logic;
  signal reinterpret6_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret6_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret6_output_port_net_x2: std_logic;
  signal reinterpret7_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret7_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret7_output_port_net_x2: std_logic;
  signal reinterpret8_output_port_net_x0: std_logic_vector(20 downto 0);
  signal reinterpret8_output_port_net_x1: std_logic_vector(20 downto 0);
  signal reinterpret8_output_port_net_x2: std_logic;

begin
  ce_1_sg_x462 <= ce_1;
  clk_1_sg_x462 <= clk_1;
  concatenate_y_net_x5 <= d0;
  concatenate_y_net_x6 <= d1;
  concatenate_y_net_x7 <= sel;
  out_x0 <= concatenate_y_net_x8;

  d_bussify_418373d42b: entity work.d_bussify_entity_418373d42b
    port map (
      in1 => mux0_y_net_x0,
      in2 => mux1_y_net_x0,
      in3 => mux2_y_net_x0,
      in4 => mux3_y_net_x0,
      in5 => mux4_y_net_x0,
      in6 => mux5_y_net_x0,
      in7 => mux6_y_net_x0,
      in8 => mux7_y_net_x0,
      bus_out => concatenate_y_net_x8
    );

  expand0_066deb8cb3: entity work.expand0_entity_066deb8cb3
    port map (
      bus_in => concatenate_y_net_x5,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out8 => reinterpret8_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0,
      out4 => reinterpret4_output_port_net_x0,
      out5 => reinterpret5_output_port_net_x0,
      out6 => reinterpret6_output_port_net_x0,
      out7 => reinterpret7_output_port_net_x0
    );

  expand1_7ed28feebd: entity work.expand0_entity_066deb8cb3
    port map (
      bus_in => concatenate_y_net_x6,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out8 => reinterpret8_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1,
      out4 => reinterpret4_output_port_net_x1,
      out5 => reinterpret5_output_port_net_x1,
      out6 => reinterpret6_output_port_net_x1,
      out7 => reinterpret7_output_port_net_x1
    );

  mux0: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x462,
      clk => clk_1_sg_x462,
      clr => '0',
      d0 => reinterpret8_output_port_net_x0,
      d1 => reinterpret8_output_port_net_x1,
      sel(0) => reinterpret8_output_port_net_x2,
      y => mux0_y_net_x0
    );

  mux1: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x462,
      clk => clk_1_sg_x462,
      clr => '0',
      d0 => reinterpret7_output_port_net_x0,
      d1 => reinterpret7_output_port_net_x1,
      sel(0) => reinterpret7_output_port_net_x2,
      y => mux1_y_net_x0
    );

  mux2: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x462,
      clk => clk_1_sg_x462,
      clr => '0',
      d0 => reinterpret6_output_port_net_x0,
      d1 => reinterpret6_output_port_net_x1,
      sel(0) => reinterpret6_output_port_net_x2,
      y => mux2_y_net_x0
    );

  mux3: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x462,
      clk => clk_1_sg_x462,
      clr => '0',
      d0 => reinterpret5_output_port_net_x0,
      d1 => reinterpret5_output_port_net_x1,
      sel(0) => reinterpret5_output_port_net_x2,
      y => mux3_y_net_x0
    );

  mux4: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x462,
      clk => clk_1_sg_x462,
      clr => '0',
      d0 => reinterpret4_output_port_net_x0,
      d1 => reinterpret4_output_port_net_x1,
      sel(0) => reinterpret4_output_port_net_x2,
      y => mux4_y_net_x0
    );

  mux5: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x462,
      clk => clk_1_sg_x462,
      clr => '0',
      d0 => reinterpret3_output_port_net_x0,
      d1 => reinterpret3_output_port_net_x1,
      sel(0) => reinterpret3_output_port_net_x2,
      y => mux5_y_net_x0
    );

  mux6: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x462,
      clk => clk_1_sg_x462,
      clr => '0',
      d0 => reinterpret2_output_port_net_x0,
      d1 => reinterpret2_output_port_net_x1,
      sel(0) => reinterpret2_output_port_net_x2,
      y => mux6_y_net_x0
    );

  mux7: entity work.mux_46aae2a33a
    port map (
      ce => ce_1_sg_x462,
      clk => clk_1_sg_x462,
      clr => '0',
      d0 => reinterpret1_output_port_net_x0,
      d1 => reinterpret1_output_port_net_x1,
      sel(0) => reinterpret1_output_port_net_x2,
      y => mux7_y_net_x0
    );

  sel_expand_eee406ec75: entity work.sel_expand_entity_eee406ec75
    port map (
      bus_in => concatenate_y_net_x7,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out8 => reinterpret8_output_port_net_x2,
      out2 => reinterpret2_output_port_net_x2,
      out3 => reinterpret3_output_port_net_x2,
      out4 => reinterpret4_output_port_net_x2,
      out5 => reinterpret5_output_port_net_x2,
      out6 => reinterpret6_output_port_net_x2,
      out7 => reinterpret7_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/shift_replicate/bussify"

entity bussify_entity_108e3e6db7 is
  port (
    in1: in std_logic; 
    in2: in std_logic; 
    in3: in std_logic; 
    in4: in std_logic; 
    in5: in std_logic; 
    in6: in std_logic; 
    in7: in std_logic; 
    in8: in std_logic; 
    bus_out: out std_logic_vector(7 downto 0)
  );
end bussify_entity_108e3e6db7;

architecture structural of bussify_entity_108e3e6db7 is
  signal concatenate_y_net_x8: std_logic_vector(7 downto 0);
  signal din0_0_q_net_x0: std_logic;
  signal din0_1_q_net_x0: std_logic;
  signal din0_2_q_net_x0: std_logic;
  signal din0_3_q_net_x0: std_logic;
  signal din0_4_q_net_x0: std_logic;
  signal din0_5_q_net_x0: std_logic;
  signal din0_6_q_net_x0: std_logic;
  signal din0_7_q_net_x0: std_logic;
  signal reinterpret1_output_port_net: std_logic;
  signal reinterpret2_output_port_net: std_logic;
  signal reinterpret3_output_port_net: std_logic;
  signal reinterpret4_output_port_net: std_logic;
  signal reinterpret5_output_port_net: std_logic;
  signal reinterpret6_output_port_net: std_logic;
  signal reinterpret7_output_port_net: std_logic;
  signal reinterpret8_output_port_net: std_logic;

begin
  din0_0_q_net_x0 <= in1;
  din0_1_q_net_x0 <= in2;
  din0_2_q_net_x0 <= in3;
  din0_3_q_net_x0 <= in4;
  din0_4_q_net_x0 <= in5;
  din0_5_q_net_x0 <= in6;
  din0_6_q_net_x0 <= in7;
  din0_7_q_net_x0 <= in8;
  bus_out <= concatenate_y_net_x8;

  concatenate: entity work.concat_7673b9b993
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => reinterpret1_output_port_net,
      in1(0) => reinterpret2_output_port_net,
      in2(0) => reinterpret3_output_port_net,
      in3(0) => reinterpret4_output_port_net,
      in4(0) => reinterpret5_output_port_net,
      in5(0) => reinterpret6_output_port_net,
      in6(0) => reinterpret7_output_port_net,
      in7(0) => reinterpret8_output_port_net,
      y => concatenate_y_net_x8
    );

  reinterpret1: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din0_0_q_net_x0,
      output_port(0) => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din0_1_q_net_x0,
      output_port(0) => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din0_2_q_net_x0,
      output_port(0) => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din0_3_q_net_x0,
      output_port(0) => reinterpret4_output_port_net
    );

  reinterpret5: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din0_4_q_net_x0,
      output_port(0) => reinterpret5_output_port_net
    );

  reinterpret6: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din0_5_q_net_x0,
      output_port(0) => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din0_6_q_net_x0,
      output_port(0) => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din0_7_q_net_x0,
      output_port(0) => reinterpret8_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/shift_replicate"

entity shift_replicate_entity_6ea815bf7e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic_vector(7 downto 0)
  );
end shift_replicate_entity_6ea815bf7e;

architecture structural of shift_replicate_entity_6ea815bf7e is
  signal ce_1_sg_x463: std_logic;
  signal clk_1_sg_x463: std_logic;
  signal concatenate_y_net_x9: std_logic_vector(7 downto 0);
  signal din0_0_q_net_x0: std_logic;
  signal din0_1_q_net_x0: std_logic;
  signal din0_2_q_net_x0: std_logic;
  signal din0_3_q_net_x0: std_logic;
  signal din0_4_q_net_x0: std_logic;
  signal din0_5_q_net_x0: std_logic;
  signal din0_6_q_net_x0: std_logic;
  signal din0_7_q_net_x0: std_logic;
  signal slice0_y_net_x0: std_logic;

begin
  ce_1_sg_x463 <= ce_1;
  clk_1_sg_x463 <= clk_1;
  slice0_y_net_x0 <= in_x0;
  out_x0 <= concatenate_y_net_x9;

  bussify_108e3e6db7: entity work.bussify_entity_108e3e6db7
    port map (
      in1 => din0_0_q_net_x0,
      in2 => din0_1_q_net_x0,
      in3 => din0_2_q_net_x0,
      in4 => din0_3_q_net_x0,
      in5 => din0_4_q_net_x0,
      in6 => din0_5_q_net_x0,
      in7 => din0_6_q_net_x0,
      in8 => din0_7_q_net_x0,
      bus_out => concatenate_y_net_x9
    );

  din0_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x463,
      clk => clk_1_sg_x463,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_0_q_net_x0
    );

  din0_1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x463,
      clk => clk_1_sg_x463,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_1_q_net_x0
    );

  din0_2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x463,
      clk => clk_1_sg_x463,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_2_q_net_x0
    );

  din0_3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x463,
      clk => clk_1_sg_x463,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_3_q_net_x0
    );

  din0_4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x463,
      clk => clk_1_sg_x463,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_4_q_net_x0
    );

  din0_5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x463,
      clk => clk_1_sg_x463,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_5_q_net_x0
    );

  din0_6: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x463,
      clk => clk_1_sg_x463,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_6_q_net_x0
    );

  din0_7: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x463,
      clk => clk_1_sg_x463,
      d(0) => slice0_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_7_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/bus_convert/bussify"

entity bussify_entity_ccadb2644d is
  port (
    in1: in std_logic_vector(18 downto 0); 
    in2: in std_logic_vector(18 downto 0); 
    in3: in std_logic_vector(18 downto 0); 
    in4: in std_logic_vector(18 downto 0); 
    bus_out: out std_logic_vector(75 downto 0)
  );
end bussify_entity_ccadb2644d;

architecture structural of bussify_entity_ccadb2644d is
  signal adder_s_net_x3: std_logic_vector(18 downto 0);
  signal adder_s_net_x4: std_logic_vector(18 downto 0);
  signal adder_s_net_x5: std_logic_vector(18 downto 0);
  signal adder_s_net_x6: std_logic_vector(18 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(75 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(18 downto 0);

begin
  adder_s_net_x3 <= in1;
  adder_s_net_x4 <= in2;
  adder_s_net_x5 <= in3;
  adder_s_net_x6 <= in4;
  bus_out <= concatenate_y_net_x5;

  concatenate: entity work.concat_2aea51ccde
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x5
    );

  reinterpret1: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x3,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x4,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x5,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => adder_s_net_x6,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/bus_convert/debus"

entity debus_entity_77a5c2552c is
  port (
    bus_in: in std_logic_vector(147 downto 0); 
    lsb_out1: out std_logic_vector(36 downto 0); 
    msb_out4: out std_logic_vector(36 downto 0); 
    out2: out std_logic_vector(36 downto 0); 
    out3: out std_logic_vector(36 downto 0)
  );
end debus_entity_77a5c2552c;

architecture structural of debus_entity_77a5c2552c is
  signal concatenate_y_net_x0: std_logic_vector(147 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(36 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(36 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(36 downto 0);
  signal slice1_y_net: std_logic_vector(36 downto 0);
  signal slice2_y_net: std_logic_vector(36 downto 0);
  signal slice3_y_net: std_logic_vector(36 downto 0);
  signal slice4_y_net: std_logic_vector(36 downto 0);

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x1;
  msb_out4 <= reinterpret4_output_port_net_x1;
  out2 <= reinterpret2_output_port_net_x1;
  out3 <= reinterpret3_output_port_net_x1;

  reinterpret1: entity work.reinterpret_5b4829fb41
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x1
    );

  reinterpret2: entity work.reinterpret_5b4829fb41
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x1
    );

  reinterpret3: entity work.reinterpret_5b4829fb41
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x1
    );

  reinterpret4: entity work.reinterpret_5b4829fb41
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 36,
      x_width => 148,
      y_width => 37
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 37,
      new_msb => 73,
      x_width => 148,
      y_width => 37
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 74,
      new_msb => 110,
      x_width => 148,
      y_width => 37
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 111,
      new_msb => 147,
      x_width => 148,
      y_width => 37
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/bus_convert"

entity bus_convert_entity_8dae2ca850 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(147 downto 0); 
    misci: in std_logic_vector(72 downto 0); 
    dout: out std_logic_vector(75 downto 0); 
    misco: out std_logic_vector(72 downto 0)
  );
end bus_convert_entity_8dae2ca850;

architecture structural of bus_convert_entity_8dae2ca850 is
  signal adder_s_net_x4: std_logic_vector(18 downto 0);
  signal adder_s_net_x5: std_logic_vector(18 downto 0);
  signal adder_s_net_x6: std_logic_vector(18 downto 0);
  signal adder_s_net_x7: std_logic_vector(18 downto 0);
  signal ce_1_sg_x468: std_logic;
  signal clk_1_sg_x468: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(147 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(75 downto 0);
  signal dmisc_q_net_x1: std_logic_vector(72 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(72 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(36 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(36 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(36 downto 0);

begin
  ce_1_sg_x468 <= ce_1;
  clk_1_sg_x468 <= clk_1;
  concatenate_y_net_x1 <= din;
  dmisc_q_net_x1 <= misci;
  dout <= concatenate_y_net_x6;
  misco <= dmisc_q_net_x2;

  bussify_ccadb2644d: entity work.bussify_entity_ccadb2644d
    port map (
      in1 => adder_s_net_x4,
      in2 => adder_s_net_x5,
      in3 => adder_s_net_x6,
      in4 => adder_s_net_x7,
      bus_out => concatenate_y_net_x6
    );

  conv1_0762d0cc16: entity work.conv1_entity_4123be0548
    port map (
      ce_1 => ce_1_sg_x468,
      clk_1 => clk_1_sg_x468,
      in_x0 => reinterpret4_output_port_net_x1,
      out_x0 => adder_s_net_x4
    );

  conv2_44e329f0e3: entity work.conv1_entity_4123be0548
    port map (
      ce_1 => ce_1_sg_x468,
      clk_1 => clk_1_sg_x468,
      in_x0 => reinterpret3_output_port_net_x1,
      out_x0 => adder_s_net_x5
    );

  conv3_bd82e48687: entity work.conv1_entity_4123be0548
    port map (
      ce_1 => ce_1_sg_x468,
      clk_1 => clk_1_sg_x468,
      in_x0 => reinterpret2_output_port_net_x1,
      out_x0 => adder_s_net_x6
    );

  conv4_b4c8ed301b: entity work.conv1_entity_4123be0548
    port map (
      ce_1 => ce_1_sg_x468,
      clk_1 => clk_1_sg_x468,
      in_x0 => reinterpret1_output_port_net_x1,
      out_x0 => adder_s_net_x7
    );

  debus_77a5c2552c: entity work.debus_entity_77a5c2552c
    port map (
      bus_in => concatenate_y_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

  dmisc: entity work.delay_153a31495d
    port map (
      ce => ce_1_sg_x468,
      clk => clk_1_sg_x468,
      clr => '0',
      d => dmisc_q_net_x1,
      q => dmisc_q_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/bus_create"

entity bus_create_entity_f616134519 is
  port (
    in1: in std_logic_vector(71 downto 0); 
    in2: in std_logic; 
    in3: in std_logic_vector(71 downto 0); 
    bus_out: out std_logic_vector(144 downto 0)
  );
end bus_create_entity_f616134519;

architecture structural of bus_create_entity_f616134519 is
  signal concatenate_y_net_x2: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(144 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net: std_logic;
  signal reinterpret3_output_port_net: std_logic_vector(71 downto 0);
  signal sync_delay1_q_net_x3: std_logic;

begin
  concatenate_y_net_x3 <= in1;
  sync_delay1_q_net_x3 <= in2;
  concatenate_y_net_x2 <= in3;
  bus_out <= concatenate_y_net_x4;

  concatenate: entity work.concat_b15c89b6cc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1(0) => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      y => concatenate_y_net_x4
    );

  reinterpret1: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concatenate_y_net_x3,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => sync_delay1_q_net_x3,
      output_port(0) => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concatenate_y_net_x2,
      output_port => reinterpret3_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/bus_expand"

entity bus_expand_entity_5a07a5d8ef is
  port (
    bus_in: in std_logic_vector(144 downto 0); 
    lsb_out1: out std_logic_vector(72 downto 0); 
    msb_out2: out std_logic_vector(71 downto 0)
  );
end bus_expand_entity_5a07a5d8ef;

architecture structural of bus_expand_entity_5a07a5d8ef is
  signal dmisc_q_net_x0: std_logic_vector(144 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(72 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(71 downto 0);
  signal slice1_y_net: std_logic_vector(72 downto 0);
  signal slice2_y_net: std_logic_vector(71 downto 0);

begin
  dmisc_q_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out2 <= reinterpret2_output_port_net_x0;

  reinterpret1: entity work.reinterpret_3a91fc640e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 72,
      x_width => 145,
      y_width => 73
    )
    port map (
      x => dmisc_q_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 73,
      new_msb => 144,
      x_width => 145,
      y_width => 72
    )
    port map (
      x => dmisc_q_net_x0,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/bus_expand1"

entity bus_expand1_entity_6f4fd5d255 is
  port (
    bus_in: in std_logic_vector(72 downto 0); 
    lsb_out1: out std_logic_vector(71 downto 0); 
    msb_out2: out std_logic
  );
end bus_expand1_entity_6f4fd5d255;

architecture structural of bus_expand1_entity_6f4fd5d255 is
  signal dmisc_q_net_x3: std_logic_vector(72 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(71 downto 0);
  signal slice1_y_net: std_logic_vector(71 downto 0);
  signal slice2_y_net_x0: std_logic;

begin
  dmisc_q_net_x3 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x6;
  msb_out2 <= slice2_y_net_x0;

  reinterpret1: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x6
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 71,
      x_width => 73,
      y_width => 72
    )
    port map (
      x => dmisc_q_net_x3,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 72,
      new_msb => 72,
      x_width => 73,
      y_width => 1
    )
    port map (
      x => dmisc_q_net_x3,
      y(0) => slice2_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/bus_mult/a*b_bussify"

entity a_b_bussify_entity_34cf1a3239 is
  port (
    in1: in std_logic_vector(73 downto 0); 
    in2: in std_logic_vector(73 downto 0); 
    bus_out: out std_logic_vector(147 downto 0)
  );
end a_b_bussify_entity_34cf1a3239;

architecture structural of a_b_bussify_entity_34cf1a3239 is
  signal concat_y_net_x1: std_logic_vector(73 downto 0);
  signal concat_y_net_x2: std_logic_vector(73 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(147 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(73 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(73 downto 0);

begin
  concat_y_net_x1 <= in1;
  concat_y_net_x2 <= in2;
  bus_out <= concatenate_y_net_x2;

  concatenate: entity work.concat_1cac477702
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      y => concatenate_y_net_x2
    );

  reinterpret1: entity work.reinterpret_efdf1c3890
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat_y_net_x1,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_efdf1c3890
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat_y_net_x2,
      output_port => reinterpret2_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/bus_mult/repa"

entity repa_entity_886325a16f is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(35 downto 0); 
    out_x0: out std_logic_vector(35 downto 0)
  );
end repa_entity_886325a16f;

architecture structural of repa_entity_886325a16f is
  signal ce_1_sg_x475: std_logic;
  signal clk_1_sg_x475: std_logic;
  signal concat_y_net_x0: std_logic_vector(35 downto 0);
  signal din0_0_q_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x475 <= ce_1;
  clk_1_sg_x475 <= clk_1;
  concat_y_net_x0 <= in_x0;
  out_x0 <= reinterpret1_output_port_net_x3;

  bussify_260619bc37: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => din0_0_q_net_x0,
      bus_out => reinterpret1_output_port_net_x3
    );

  din0_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 36
    )
    port map (
      ce => ce_1_sg_x475,
      clk => clk_1_sg_x475,
      d => concat_y_net_x0,
      en => '1',
      rst => '1',
      q => din0_0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/bus_mult/repb/bussify"

entity bussify_entity_8e5b66fd39 is
  port (
    in1: in std_logic_vector(71 downto 0); 
    bus_out: out std_logic_vector(71 downto 0)
  );
end bussify_entity_8e5b66fd39;

architecture structural of bussify_entity_8e5b66fd39 is
  signal din0_0_q_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(71 downto 0);

begin
  din0_0_q_net_x0 <= in1;
  bus_out <= reinterpret1_output_port_net_x2;

  reinterpret1: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din0_0_q_net_x0,
      output_port => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/bus_mult/repb"

entity repb_entity_328f95978b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(71 downto 0); 
    out_x0: out std_logic_vector(71 downto 0)
  );
end repb_entity_328f95978b;

architecture structural of repb_entity_328f95978b is
  signal ce_1_sg_x476: std_logic;
  signal clk_1_sg_x476: std_logic;
  signal din0_0_q_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(71 downto 0);

begin
  ce_1_sg_x476 <= ce_1;
  clk_1_sg_x476 <= clk_1;
  reinterpret2_output_port_net_x1 <= in_x0;
  out_x0 <= reinterpret1_output_port_net_x3;

  bussify_8e5b66fd39: entity work.bussify_entity_8e5b66fd39
    port map (
      in1 => din0_0_q_net_x0,
      bus_out => reinterpret1_output_port_net_x3
    );

  din0_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 72
    )
    port map (
      ce => ce_1_sg_x476,
      clk => clk_1_sg_x476,
      d => reinterpret2_output_port_net_x1,
      en => '1',
      rst => '1',
      q => din0_0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/bus_mult"

entity bus_mult_entity_3f9ee7ffa7 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(71 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    a_b: out std_logic_vector(147 downto 0); 
    misco: out std_logic_vector(72 downto 0)
  );
end bus_mult_entity_3f9ee7ffa7;

architecture structural of bus_mult_entity_3f9ee7ffa7 is
  signal ce_1_sg_x477: std_logic;
  signal clk_1_sg_x477: std_logic;
  signal concat_y_net_x3: std_logic_vector(73 downto 0);
  signal concat_y_net_x4: std_logic_vector(73 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(147 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(72 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x8: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(72 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);

begin
  concat_y_net_x5 <= a;
  reinterpret2_output_port_net_x2 <= b;
  ce_1_sg_x477 <= ce_1;
  clk_1_sg_x477 <= clk_1;
  reinterpret1_output_port_net_x9 <= misci;
  a_b <= concatenate_y_net_x3;
  misco <= dmisc_q_net_x2;

  a_b_bussify_34cf1a3239: entity work.a_b_bussify_entity_34cf1a3239
    port map (
      in1 => concat_y_net_x3,
      in2 => concat_y_net_x4,
      bus_out => concatenate_y_net_x3
    );

  a_debus_4955579b88: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret1_output_port_net_x3,
      msb_lsb_out1 => reinterpret1_output_port_net_x7
    );

  b_debus_0192d8650f: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => reinterpret1_output_port_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x8,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  dmisc: entity work.delay_3ffe3e5660
    port map (
      ce => ce_1_sg_x477,
      clk => clk_1_sg_x477,
      clr => '0',
      d => reinterpret1_output_port_net_x9,
      q => dmisc_q_net_x2
    );

  mult1_63937917cc: entity work.mult1_entity_c19da6e8af
    port map (
      a => reinterpret1_output_port_net_x7,
      b => reinterpret2_output_port_net_x3,
      ce_1 => ce_1_sg_x477,
      clk_1 => clk_1_sg_x477,
      ab => concat_y_net_x3
    );

  mult2_37522ca515: entity work.mult1_entity_c19da6e8af
    port map (
      a => reinterpret1_output_port_net_x7,
      b => reinterpret1_output_port_net_x8,
      ce_1 => ce_1_sg_x477,
      clk_1 => clk_1_sg_x477,
      ab => concat_y_net_x4
    );

  repa_886325a16f: entity work.repa_entity_886325a16f
    port map (
      ce_1 => ce_1_sg_x477,
      clk_1 => clk_1_sg_x477,
      in_x0 => concat_y_net_x5,
      out_x0 => reinterpret1_output_port_net_x3
    );

  repb_328f95978b: entity work.repb_entity_328f95978b
    port map (
      ce_1 => ce_1_sg_x477,
      clk_1 => clk_1_sg_x477,
      in_x0 => reinterpret2_output_port_net_x2,
      out_x0 => reinterpret1_output_port_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/coeff_gen/feedback_osc/cmult/b_expand"

entity b_expand_entity_32fc3a5825 is
  port (
    bus_in: in std_logic_vector(99 downto 0); 
    lsb_out1: out std_logic_vector(24 downto 0); 
    msb_out4: out std_logic_vector(24 downto 0); 
    out2: out std_logic_vector(24 downto 0); 
    out3: out std_logic_vector(24 downto 0)
  );
end b_expand_entity_32fc3a5825;

architecture structural of b_expand_entity_32fc3a5825 is
  signal concatenate_y_net_x0: std_logic_vector(99 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(24 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(24 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(24 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(24 downto 0);
  signal slice1_y_net: std_logic_vector(24 downto 0);
  signal slice2_y_net: std_logic_vector(24 downto 0);
  signal slice3_y_net: std_logic_vector(24 downto 0);
  signal slice4_y_net: std_logic_vector(24 downto 0);

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_60ea556961
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_60ea556961
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_60ea556961
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_60ea556961
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 24,
      x_width => 100,
      y_width => 25
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 25,
      new_msb => 49,
      x_width => 100,
      y_width => 25
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 50,
      new_msb => 74,
      x_width => 100,
      y_width => 25
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 75,
      new_msb => 99,
      x_width => 100,
      y_width => 25
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/coeff_gen/feedback_osc/cmult/b_replicate/bussify"

entity bussify_entity_f956c66d5f is
  port (
    in1: in std_logic_vector(49 downto 0); 
    in2: in std_logic_vector(49 downto 0); 
    bus_out: out std_logic_vector(99 downto 0)
  );
end bussify_entity_f956c66d5f;

architecture structural of bussify_entity_f956c66d5f is
  signal concatenate_y_net_x1: std_logic_vector(99 downto 0);
  signal din0_0_q_net_x0: std_logic_vector(49 downto 0);
  signal din0_1_q_net_x0: std_logic_vector(49 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(49 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(49 downto 0);

begin
  din0_0_q_net_x0 <= in1;
  din0_1_q_net_x0 <= in2;
  bus_out <= concatenate_y_net_x1;

  concatenate: entity work.concat_402eae042e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      y => concatenate_y_net_x1
    );

  reinterpret1: entity work.reinterpret_0ad37a7234
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din0_0_q_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_0ad37a7234
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din0_1_q_net_x0,
      output_port => reinterpret2_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/coeff_gen/feedback_osc/cmult/b_replicate"

entity b_replicate_entity_7482f10046 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(49 downto 0); 
    out_x0: out std_logic_vector(99 downto 0)
  );
end b_replicate_entity_7482f10046;

architecture structural of b_replicate_entity_7482f10046 is
  signal ce_1_sg_x479: std_logic;
  signal clk_1_sg_x479: std_logic;
  signal concat_y_net_x0: std_logic_vector(49 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(99 downto 0);
  signal din0_0_q_net_x0: std_logic_vector(49 downto 0);
  signal din0_1_q_net_x0: std_logic_vector(49 downto 0);

begin
  ce_1_sg_x479 <= ce_1;
  clk_1_sg_x479 <= clk_1;
  concat_y_net_x0 <= in_x0;
  out_x0 <= concatenate_y_net_x2;

  bussify_f956c66d5f: entity work.bussify_entity_f956c66d5f
    port map (
      in1 => din0_0_q_net_x0,
      in2 => din0_1_q_net_x0,
      bus_out => concatenate_y_net_x2
    );

  din0_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 50
    )
    port map (
      ce => ce_1_sg_x479,
      clk => clk_1_sg_x479,
      d => concat_y_net_x0,
      en => '1',
      rst => '1',
      q => din0_0_q_net_x0
    );

  din0_1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 50
    )
    port map (
      ce => ce_1_sg_x479,
      clk => clk_1_sg_x479,
      d => concat_y_net_x0,
      en => '1',
      rst => '1',
      q => din0_1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/coeff_gen/feedback_osc/cmult"

entity cmult_entity_99c91d3ed6 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(49 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    ab: out std_logic_vector(35 downto 0)
  );
end cmult_entity_99c91d3ed6;

architecture structural of cmult_entity_99c91d3ed6 is
  signal addsub_im_s_net: std_logic_vector(43 downto 0);
  signal addsub_re_s_net: std_logic_vector(43 downto 0);
  signal ce_1_sg_x480: std_logic;
  signal clk_1_sg_x480: std_logic;
  signal concat_y_net_x2: std_logic_vector(49 downto 0);
  signal concat_y_net_x3: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(99 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(17 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(17 downto 0);
  signal imim_p_net: std_logic_vector(42 downto 0);
  signal imre_p_net: std_logic_vector(42 downto 0);
  signal reim_p_net: std_logic_vector(42 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(24 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(24 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(24 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(24 downto 0);
  signal rere_p_net: std_logic_vector(42 downto 0);
  signal working_values_doutb_net_x1: std_logic_vector(35 downto 0);

begin
  working_values_doutb_net_x1 <= a;
  concat_y_net_x2 <= b;
  ce_1_sg_x480 <= ce_1;
  clk_1_sg_x480 <= clk_1;
  ab <= concat_y_net_x3;

  a_expand_50783f2a1f: entity work.a_expand_entity_c51fa07742
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out4 => reinterpret4_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0
    );

  a_replicate_21a2a2edba: entity work.a_replicate_entity_fe36abb22a
    port map (
      ce_1 => ce_1_sg_x480,
      clk_1 => clk_1_sg_x480,
      in_x0 => working_values_doutb_net_x1,
      out_x0 => concatenate_y_net_x2
    );

  addsub_im: entity work.addsub_dffba22f79
    port map (
      a => imre_p_net,
      b => reim_p_net,
      ce => ce_1_sg_x480,
      clk => clk_1_sg_x480,
      clr => '0',
      s => addsub_im_s_net
    );

  addsub_re: entity work.addsub_e326baca6b
    port map (
      a => rere_p_net,
      b => imim_p_net,
      ce => ce_1_sg_x480,
      clk => clk_1_sg_x480,
      clr => '0',
      s => addsub_re_s_net
    );

  b_expand_32fc3a5825: entity work.b_expand_entity_32fc3a5825
    port map (
      bus_in => concatenate_y_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

  b_replicate_7482f10046: entity work.b_replicate_entity_7482f10046
    port map (
      ce_1 => ce_1_sg_x480,
      clk_1 => clk_1_sg_x480,
      in_x0 => concat_y_net_x2,
      out_x0 => concatenate_y_net_x3
    );

  convert_im: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 41,
      din_width => 44,
      dout_arith => 2,
      dout_bin_pt => 17,
      dout_width => 18,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlRound
    )
    port map (
      ce => ce_1_sg_x480,
      clk => clk_1_sg_x480,
      clr => '0',
      din => addsub_im_s_net,
      en => "1",
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 41,
      din_width => 44,
      dout_arith => 2,
      dout_bin_pt => 17,
      dout_width => 18,
      latency => 1,
      overflow => xlSaturate,
      quantization => xlRound
    )
    port map (
      ce => ce_1_sg_x480,
      clk => clk_1_sg_x480,
      clr => '0',
      din => addsub_re_s_net,
      en => "1",
      dout => convert_re_dout_net_x0
    );

  imim: entity work.mult_4d389c6c89
    port map (
      a => reinterpret3_output_port_net_x0,
      b => reinterpret3_output_port_net_x1,
      ce => ce_1_sg_x480,
      clk => clk_1_sg_x480,
      clr => '0',
      p => imim_p_net
    );

  imre: entity work.mult_4d389c6c89
    port map (
      a => reinterpret1_output_port_net_x0,
      b => reinterpret2_output_port_net_x1,
      ce => ce_1_sg_x480,
      clk => clk_1_sg_x480,
      clr => '0',
      p => imre_p_net
    );

  reim: entity work.mult_4d389c6c89
    port map (
      a => reinterpret2_output_port_net_x0,
      b => reinterpret1_output_port_net_x1,
      ce => ce_1_sg_x480,
      clk => clk_1_sg_x480,
      clr => '0',
      p => reim_p_net
    );

  rere: entity work.mult_4d389c6c89
    port map (
      a => reinterpret4_output_port_net_x0,
      b => reinterpret4_output_port_net_x1,
      ce => ce_1_sg_x480,
      clk => clk_1_sg_x480,
      clr => '0',
      p => rere_p_net
    );

  ri_to_c_5e0cd6b42d: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/coeff_gen/feedback_osc/outmux/sel_expand"

entity sel_expand_entity_75ea71b49a is
  port (
    bus_in: in std_logic_vector(1 downto 0); 
    lsb_out1: out std_logic; 
    msb_out2: out std_logic
  );
end sel_expand_entity_75ea71b49a;

architecture structural of sel_expand_entity_75ea71b49a is
  signal concatenate_y_net_x0: std_logic_vector(1 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic;
  signal reinterpret2_output_port_net_x0: std_logic;
  signal slice1_y_net: std_logic;
  signal slice2_y_net: std_logic;

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out2 <= reinterpret2_output_port_net_x0;

  reinterpret1: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice1_y_net,
      output_port(0) => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_81130c7f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => slice2_y_net,
      output_port(0) => reinterpret2_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/coeff_gen/feedback_osc/outmux"

entity outmux_entity_2e9bdd648a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d0: in std_logic_vector(35 downto 0); 
    d1: in std_logic_vector(35 downto 0); 
    sel: in std_logic_vector(1 downto 0); 
    out_x0: out std_logic_vector(35 downto 0)
  );
end outmux_entity_2e9bdd648a;

architecture structural of outmux_entity_2e9bdd648a is
  signal ce_1_sg_x481: std_logic;
  signal clk_1_sg_x481: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(1 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(35 downto 0);
  signal mux0_y_net_x0: std_logic_vector(17 downto 0);
  signal mux1_y_net_x0: std_logic_vector(17 downto 0);
  signal reference_values_data_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic;
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic;

begin
  ce_1_sg_x481 <= ce_1;
  clk_1_sg_x481 <= clk_1;
  reference_values_data_net_x1 <= d0;
  concat_y_net_x5 <= d1;
  concatenate_y_net_x2 <= sel;
  out_x0 <= concatenate_y_net_x3;

  d_bussify_333b622b16: entity work.join_entity_60290f1f6b
    port map (
      in1 => mux0_y_net_x0,
      in2 => mux1_y_net_x0,
      bus_out => concatenate_y_net_x3
    );

  expand0_67b659d79f: entity work.bus_expand_a_entity_708163d551
    port map (
      bus_in => reference_values_data_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out2 => reinterpret2_output_port_net_x0
    );

  expand1_ec1fb28398: entity work.bus_expand_a_entity_708163d551
    port map (
      bus_in => concat_y_net_x5,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  mux0: entity work.mux_b0d8099706
    port map (
      ce => ce_1_sg_x481,
      clk => clk_1_sg_x481,
      clr => '0',
      d0 => reinterpret2_output_port_net_x0,
      d1 => reinterpret2_output_port_net_x1,
      sel(0) => reinterpret2_output_port_net_x2,
      y => mux0_y_net_x0
    );

  mux1: entity work.mux_b0d8099706
    port map (
      ce => ce_1_sg_x481,
      clk => clk_1_sg_x481,
      clr => '0',
      d0 => reinterpret1_output_port_net_x0,
      d1 => reinterpret1_output_port_net_x1,
      sel(0) => reinterpret1_output_port_net_x2,
      y => mux1_y_net_x0
    );

  sel_expand_75ea71b49a: entity work.sel_expand_entity_75ea71b49a
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out2 => reinterpret2_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/coeff_gen/feedback_osc/ri_to_c"

entity ri_to_c_entity_bdc22e7566 is
  port (
    im: in std_logic_vector(24 downto 0); 
    re: in std_logic_vector(24 downto 0); 
    c: out std_logic_vector(49 downto 0)
  );
end ri_to_c_entity_bdc22e7566;

architecture structural of ri_to_c_entity_bdc22e7566 is
  signal concat_y_net_x3: std_logic_vector(49 downto 0);
  signal force_im_output_port_net: std_logic_vector(24 downto 0);
  signal force_re_output_port_net: std_logic_vector(24 downto 0);
  signal rotation_imag_op_net_x0: std_logic_vector(24 downto 0);
  signal rotation_real_op_net_x0: std_logic_vector(24 downto 0);

begin
  rotation_imag_op_net_x0 <= im;
  rotation_real_op_net_x0 <= re;
  c <= concat_y_net_x3;

  concat: entity work.concat_ed1960f5a8
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x3
    );

  force_im: entity work.reinterpret_c3c0e847be
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rotation_imag_op_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_c3c0e847be
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rotation_real_op_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/coeff_gen/feedback_osc/sel_replicate/bussify"

entity bussify_entity_0e1e4250bb is
  port (
    in1: in std_logic; 
    in2: in std_logic; 
    bus_out: out std_logic_vector(1 downto 0)
  );
end bussify_entity_0e1e4250bb;

architecture structural of bussify_entity_0e1e4250bb is
  signal concatenate_y_net_x3: std_logic_vector(1 downto 0);
  signal din0_0_q_net_x0: std_logic;
  signal din0_1_q_net_x0: std_logic;
  signal reinterpret1_output_port_net: std_logic;
  signal reinterpret2_output_port_net: std_logic;

begin
  din0_0_q_net_x0 <= in1;
  din0_1_q_net_x0 <= in2;
  bus_out <= concatenate_y_net_x3;

  concatenate: entity work.concat_e6f5ee726b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => reinterpret1_output_port_net,
      in1(0) => reinterpret2_output_port_net,
      y => concatenate_y_net_x3
    );

  reinterpret1: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din0_0_q_net_x0,
      output_port(0) => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => din0_1_q_net_x0,
      output_port(0) => reinterpret2_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/coeff_gen/feedback_osc/sel_replicate"

entity sel_replicate_entity_ed643ef8b8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic_vector(1 downto 0)
  );
end sel_replicate_entity_ed643ef8b8;

architecture structural of sel_replicate_entity_ed643ef8b8 is
  signal ce_1_sg_x482: std_logic;
  signal clk_1_sg_x482: std_logic;
  signal concatenate_y_net_x4: std_logic_vector(1 downto 0);
  signal din0_0_q_net_x0: std_logic;
  signal din0_1_q_net_x0: std_logic;
  signal dselect_q_net_x0: std_logic;

begin
  ce_1_sg_x482 <= ce_1;
  clk_1_sg_x482 <= clk_1;
  dselect_q_net_x0 <= in_x0;
  out_x0 <= concatenate_y_net_x4;

  bussify_0e1e4250bb: entity work.bussify_entity_0e1e4250bb
    port map (
      in1 => din0_0_q_net_x0,
      in2 => din0_1_q_net_x0,
      bus_out => concatenate_y_net_x4
    );

  din0_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x482,
      clk => clk_1_sg_x482,
      d(0) => dselect_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_0_q_net_x0
    );

  din0_1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x482,
      clk => clk_1_sg_x482,
      d(0) => dselect_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => din0_1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/coeff_gen/feedback_osc"

entity feedback_osc_entity_8ae9a48d50 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    en: in std_logic; 
    misci: in std_logic_vector(144 downto 0); 
    sync: in std_logic; 
    cos: out std_logic_vector(17 downto 0); 
    misco: out std_logic_vector(144 downto 0); 
    sin: out std_logic_vector(17 downto 0)
  );
end feedback_osc_entity_8ae9a48d50;

architecture structural of feedback_osc_entity_8ae9a48d50 is
  signal ce_1_sg_x483: std_logic;
  signal choice_y_net: std_logic_vector(3 downto 0);
  signal clk_1_sg_x483: std_logic;
  signal concat_y_net: std_logic_vector(4 downto 0);
  signal concat_y_net_x3: std_logic_vector(49 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(1 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(144 downto 0);
  signal constant_op_net: std_logic_vector(3 downto 0);
  signal count_op_net: std_logic_vector(8 downto 0);
  signal dcoeffs_q_net_x0: std_logic_vector(35 downto 0);
  signal dconcat_q_net: std_logic_vector(4 downto 0);
  signal den0_q_net: std_logic;
  signal dmisc_q_net_x1: std_logic_vector(144 downto 0);
  signal doffset0_q_net: std_logic_vector(3 downto 0);
  signal doffset1_q_net: std_logic_vector(3 downto 0);
  signal dselect_q_net_x0: std_logic;
  signal en_op_net_x0: std_logic;
  signal force_im_output_port_net_x1: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(17 downto 0);
  signal offset_y_net: std_logic_vector(3 downto 0);
  signal reference_values_data_net_x1: std_logic_vector(35 downto 0);
  signal rotation_imag_op_net_x0: std_logic_vector(24 downto 0);
  signal rotation_real_op_net_x0: std_logic_vector(24 downto 0);
  signal segment_y_net: std_logic;
  signal select_op_net: std_logic;
  signal sync_delay1_q_net_x4: std_logic;
  signal working_values_doutb_net_x1: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x483 <= ce_1;
  clk_1_sg_x483 <= clk_1;
  en_op_net_x0 <= en;
  concatenate_y_net_x6 <= misci;
  sync_delay1_q_net_x4 <= sync;
  cos <= force_re_output_port_net_x1;
  misco <= dmisc_q_net_x1;
  sin <= force_im_output_port_net_x1;

  c_to_ri_861155d2d5: entity work.c_to_ri_entity_27418540ef
    port map (
      c => dcoeffs_q_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  choice: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 7,
      x_width => 9,
      y_width => 4
    )
    port map (
      x => count_op_net,
      y => choice_y_net
    );

  cmult_99c91d3ed6: entity work.cmult_entity_99c91d3ed6
    port map (
      a => working_values_doutb_net_x1,
      b => concat_y_net_x3,
      ce_1 => ce_1_sg_x483,
      clk_1 => clk_1_sg_x483,
      ab => concat_y_net_x5
    );

  concat: entity work.concat_cf540617d5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => segment_y_net,
      in1 => offset_y_net,
      y => concat_y_net
    );

  constant_x0: entity work.constant_4c449dd556
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  count: entity work.xlcounter_free_window_and_fft_test_v4
    generic map (
      core_name0 => "cntr_11_0_9966d4e54ef143a4",
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x483,
      clk => clk_1_sg_x483,
      clr => '0',
      en(0) => en_op_net_x0,
      rst(0) => sync_delay1_q_net_x4,
      op => count_op_net
    );

  dcoeffs: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x483,
      clk => clk_1_sg_x483,
      clr => '0',
      d => concatenate_y_net_x3,
      q => dcoeffs_q_net_x0
    );

  dconcat: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 5
    )
    port map (
      ce => ce_1_sg_x483,
      clk => clk_1_sg_x483,
      d => concat_y_net,
      en => '1',
      rst => '1',
      q => dconcat_q_net
    );

  den0: entity work.xldelay
    generic map (
      latency => 10,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x483,
      clk => clk_1_sg_x483,
      d(0) => en_op_net_x0,
      en => '1',
      rst => '1',
      q(0) => den0_q_net
    );

  dmisc: entity work.delay_907aecc619
    port map (
      ce => ce_1_sg_x483,
      clk => clk_1_sg_x483,
      clr => '0',
      d => concatenate_y_net_x6,
      q => dmisc_q_net_x1
    );

  doffset0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 4
    )
    port map (
      ce => ce_1_sg_x483,
      clk => clk_1_sg_x483,
      d => offset_y_net,
      en => '1',
      rst => '1',
      q => doffset0_q_net
    );

  doffset1: entity work.xldelay
    generic map (
      latency => 10,
      reg_retiming => 0,
      reset => 0,
      width => 4
    )
    port map (
      ce => ce_1_sg_x483,
      clk => clk_1_sg_x483,
      d => offset_y_net,
      en => '1',
      rst => '1',
      q => doffset1_q_net
    );

  dselect: entity work.delay_aab7b18c27
    port map (
      ce => ce_1_sg_x483,
      clk => clk_1_sg_x483,
      clr => '0',
      d(0) => select_op_net,
      q(0) => dselect_q_net_x0
    );

  offset: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 3,
      x_width => 9,
      y_width => 4
    )
    port map (
      x => count_op_net,
      y => offset_y_net
    );

  outmux_2e9bdd648a: entity work.outmux_entity_2e9bdd648a
    port map (
      ce_1 => ce_1_sg_x483,
      clk_1 => clk_1_sg_x483,
      d0 => reference_values_data_net_x1,
      d1 => concat_y_net_x5,
      sel => concatenate_y_net_x5,
      out_x0 => concatenate_y_net_x3
    );

  reference_values: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 5,
      c_width => 36,
      core_name0 => "bmg_72_5b8023f54686b589",
      latency => 1
    )
    port map (
      addr => dconcat_q_net,
      ce => ce_1_sg_x483,
      clk => clk_1_sg_x483,
      en => "1",
      rst => "0",
      data => reference_values_data_net_x1
    );

  ri_to_c_bdc22e7566: entity work.ri_to_c_entity_bdc22e7566
    port map (
      im => rotation_imag_op_net_x0,
      re => rotation_real_op_net_x0,
      c => concat_y_net_x3
    );

  rotation_imag: entity work.constant_df65ba8bae
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => rotation_imag_op_net_x0
    );

  rotation_real: entity work.constant_190b65ebff
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => rotation_real_op_net_x0
    );

  segment: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => count_op_net,
      y(0) => segment_y_net
    );

  sel_replicate_ed643ef8b8: entity work.sel_replicate_entity_ed643ef8b8
    port map (
      ce_1 => ce_1_sg_x483,
      clk_1 => clk_1_sg_x483,
      in_x0 => dselect_q_net_x0,
      out_x0 => concatenate_y_net_x5
    );

  select_x0: entity work.relational_01718d4f17
    port map (
      a => constant_op_net,
      b => choice_y_net,
      ce => ce_1_sg_x483,
      clk => clk_1_sg_x483,
      clr => '0',
      op(0) => select_op_net
    );

  working_values: entity work.xldpram_dist_window_and_fft_test_v4
    generic map (
      addr_width => 4,
      c_address_width => 4,
      c_width => 36,
      core_name0 => "dmg_72_06baee6e81a49674",
      latency => 2
    )
    port map (
      a_ce => ce_1_sg_x483,
      a_clk => clk_1_sg_x483,
      addra => doffset1_q_net,
      addrb => doffset0_q_net,
      b_ce => ce_1_sg_x483,
      b_clk => clk_1_sg_x483,
      dina => concatenate_y_net_x3,
      ena => "1",
      enb => "1",
      wea(0) => den0_q_net,
      doutb => working_values_doutb_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle/coeff_gen"

entity coeff_gen_entity_45e50c8248 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(144 downto 0); 
    rst: in std_logic; 
    misco: out std_logic_vector(144 downto 0); 
    w: out std_logic_vector(35 downto 0)
  );
end coeff_gen_entity_45e50c8248;

architecture structural of coeff_gen_entity_45e50c8248 is
  signal ce_1_sg_x484: std_logic;
  signal clk_1_sg_x484: std_logic;
  signal concat_y_net_x7: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(144 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(144 downto 0);
  signal en_op_net_x0: std_logic;
  signal force_im_output_port_net_x2: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x2: std_logic_vector(17 downto 0);
  signal sync_delay1_q_net_x5: std_logic;

begin
  ce_1_sg_x484 <= ce_1;
  clk_1_sg_x484 <= clk_1;
  concatenate_y_net_x7 <= misci;
  sync_delay1_q_net_x5 <= rst;
  misco <= dmisc_q_net_x2;
  w <= concat_y_net_x7;

  en: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => en_op_net_x0
    );

  feedback_osc_8ae9a48d50: entity work.feedback_osc_entity_8ae9a48d50
    port map (
      ce_1 => ce_1_sg_x484,
      clk_1 => clk_1_sg_x484,
      en => en_op_net_x0,
      misci => concatenate_y_net_x7,
      sync => sync_delay1_q_net_x5,
      cos => force_re_output_port_net_x2,
      misco => dmisc_q_net_x2,
      sin => force_im_output_port_net_x2
    );

  ri_to_c_15782dfc3e: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => force_im_output_port_net_x2,
      re => force_re_output_port_net_x2,
      c => concat_y_net_x7
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0/twiddle"

entity twiddle_entity_5f068b21a9 is
  port (
    ai: in std_logic_vector(71 downto 0); 
    bi: in std_logic_vector(71 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ao: out std_logic_vector(71 downto 0); 
    bwo: out std_logic_vector(75 downto 0); 
    sync_out: out std_logic
  );
end twiddle_entity_5f068b21a9;

architecture structural of twiddle_entity_5f068b21a9 is
  signal ce_1_sg_x485: std_logic;
  signal clk_1_sg_x485: std_logic;
  signal concat_y_net_x7: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(144 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(147 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(71 downto 0);
  signal dmisc_q_net_x2: std_logic_vector(72 downto 0);
  signal dmisc_q_net_x3: std_logic_vector(72 downto 0);
  signal dmisc_q_net_x4: std_logic_vector(144 downto 0);
  signal reinterpret1_output_port_net_x10: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(72 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(71 downto 0);
  signal slice2_y_net_x1: std_logic;
  signal sync_delay1_q_net_x6: std_logic;

begin
  concatenate_y_net_x4 <= ai;
  concatenate_y_net_x9 <= bi;
  ce_1_sg_x485 <= ce_1;
  clk_1_sg_x485 <= clk_1;
  sync_delay1_q_net_x6 <= sync_in;
  ao <= reinterpret1_output_port_net_x10;
  bwo <= concatenate_y_net_x10;
  sync_out <= slice2_y_net_x1;

  bus_convert_8dae2ca850: entity work.bus_convert_entity_8dae2ca850
    port map (
      ce_1 => ce_1_sg_x485,
      clk_1 => clk_1_sg_x485,
      din => concatenate_y_net_x8,
      misci => dmisc_q_net_x2,
      dout => concatenate_y_net_x10,
      misco => dmisc_q_net_x3
    );

  bus_create_f616134519: entity work.bus_create_entity_f616134519
    port map (
      in1 => concatenate_y_net_x9,
      in2 => sync_delay1_q_net_x6,
      in3 => concatenate_y_net_x4,
      bus_out => concatenate_y_net_x7
    );

  bus_expand1_6f4fd5d255: entity work.bus_expand1_entity_6f4fd5d255
    port map (
      bus_in => dmisc_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x10,
      msb_out2 => slice2_y_net_x1
    );

  bus_expand_5a07a5d8ef: entity work.bus_expand_entity_5a07a5d8ef
    port map (
      bus_in => dmisc_q_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x9,
      msb_out2 => reinterpret2_output_port_net_x2
    );

  bus_mult_3f9ee7ffa7: entity work.bus_mult_entity_3f9ee7ffa7
    port map (
      a => concat_y_net_x7,
      b => reinterpret2_output_port_net_x2,
      ce_1 => ce_1_sg_x485,
      clk_1 => clk_1_sg_x485,
      misci => reinterpret1_output_port_net_x9,
      a_b => concatenate_y_net_x8,
      misco => dmisc_q_net_x2
    );

  coeff_gen_45e50c8248: entity work.coeff_gen_entity_45e50c8248
    port map (
      ce_1 => ce_1_sg_x485,
      clk_1 => clk_1_sg_x485,
      misci => concatenate_y_net_x7,
      rst => sync_delay1_q_net_x6,
      misco => dmisc_q_net_x4,
      w => concat_y_net_x7
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly0_0"

entity butterfly0_0_entity_0276d59789 is
  port (
    a: in std_logic_vector(71 downto 0); 
    b: in std_logic_vector(71 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(71 downto 0); 
    a_bw_x0: out std_logic_vector(71 downto 0); 
    sync_out: out std_logic
  );
end butterfly0_0_entity_0276d59789;

architecture structural of butterfly0_0_entity_0276d59789 is
  signal ce_1_sg_x486: std_logic;
  signal clk_1_sg_x486: std_logic;
  signal concat_y_net_x3: std_logic_vector(159 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(167 downto 0);
  signal concatenate_y_net_x11: std_logic_vector(167 downto 0);
  signal concatenate_y_net_x12: std_logic_vector(7 downto 0);
  signal concatenate_y_net_x13: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x14: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x15: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(143 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(167 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(159 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(79 downto 0);
  signal delay0_q_net_x0: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(71 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice2_y_net_x1: std_logic;
  signal sync_delay1_q_net_x7: std_logic;

begin
  concatenate_y_net_x14 <= a;
  concatenate_y_net_x15 <= b;
  ce_1_sg_x486 <= ce_1;
  clk_1_sg_x486 <= clk_1;
  slice0_y_net_x1 <= shift;
  sync_delay1_q_net_x7 <= sync_in;
  a_bw <= reinterpret1_output_port_net_x3;
  a_bw_x0 <= reinterpret2_output_port_net_x3;
  sync_out <= delay0_q_net_x0;

  bus_add_da476ff50b: entity work.bus_add_entity_da476ff50b
    port map (
      a => reinterpret1_output_port_net_x10,
      b => concatenate_y_net_x13,
      ce_1 => ce_1_sg_x486,
      clk_1 => clk_1_sg_x486,
      dout => concatenate_y_net_x3
    );

  bus_convert_d2f13e5121: entity work.bus_convert_entity_d2f13e5121
    port map (
      ce_1 => ce_1_sg_x486,
      clk_1 => clk_1_sg_x486,
      din => concatenate_y_net_x11,
      dout => concatenate_y_net_x5
    );

  bus_expand_c7f62b43f8: entity work.bus_expand_entity_c7f62b43f8
    port map (
      bus_in => concatenate_y_net_x5,
      lsb_out1 => reinterpret1_output_port_net_x3,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  bus_norm0_100a42851b: entity work.bus_norm0_entity_100a42851b
    port map (
      ce_1 => ce_1_sg_x486,
      clk_1 => clk_1_sg_x486,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x6
    );

  bus_norm1_399783b802: entity work.bus_norm1_entity_399783b802
    port map (
      ce_1 => ce_1_sg_x486,
      clk_1 => clk_1_sg_x486,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x10
    );

  bus_scale_3601d94d3d: entity work.bus_scale_entity_3601d94d3d
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_379c72160f: entity work.bus_sub_entity_379c72160f
    port map (
      a => reinterpret1_output_port_net_x10,
      b => concatenate_y_net_x13,
      ce_1 => ce_1_sg_x486,
      clk_1 => clk_1_sg_x486,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_1ea5b7e23c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x3,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  delay0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x486,
      clk => clk_1_sg_x486,
      clr => '0',
      d(0) => slice2_y_net_x1,
      q(0) => delay0_q_net_x0
    );

  mux_0030050c3d: entity work.mux_entity_0030050c3d
    port map (
      ce_1 => ce_1_sg_x486,
      clk_1 => clk_1_sg_x486,
      d0 => concatenate_y_net_x6,
      d1 => concatenate_y_net_x10,
      sel => concatenate_y_net_x12,
      out_x0 => concatenate_y_net_x11
    );

  shift_replicate_6ea815bf7e: entity work.shift_replicate_entity_6ea815bf7e
    port map (
      ce_1 => ce_1_sg_x486,
      clk_1 => clk_1_sg_x486,
      in_x0 => slice0_y_net_x1,
      out_x0 => concatenate_y_net_x12
    );

  twiddle_5f068b21a9: entity work.twiddle_entity_5f068b21a9
    port map (
      ai => concatenate_y_net_x14,
      bi => concatenate_y_net_x15,
      ce_1 => ce_1_sg_x486,
      clk_1 => clk_1_sg_x486,
      sync_in => sync_delay1_q_net_x7,
      ao => reinterpret1_output_port_net_x10,
      bwo => concatenate_y_net_x13,
      sync_out => slice2_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly1_0/bus_expand"

entity bus_expand_entity_23b685a9dd is
  port (
    bus_in: in std_logic_vector(71 downto 0); 
    msb_out2: out std_logic_vector(35 downto 0)
  );
end bus_expand_entity_23b685a9dd;

architecture structural of bus_expand_entity_23b685a9dd is
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(35 downto 0);
  signal slice2_y_net: std_logic_vector(35 downto 0);

begin
  concatenate_y_net_x4 <= bus_in;
  msb_out2 <= reinterpret2_output_port_net_x1;

  reinterpret2: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x1
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 36,
      new_msb => 71,
      x_width => 72,
      y_width => 36
    )
    port map (
      x => concatenate_y_net_x4,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly1_0/twiddle/coeff_gen/feedback_osc"

entity feedback_osc_entity_24b0f033c4 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    en: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    sync: in std_logic; 
    cos: out std_logic_vector(17 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    sin: out std_logic_vector(17 downto 0)
  );
end feedback_osc_entity_24b0f033c4;

architecture structural of feedback_osc_entity_24b0f033c4 is
  signal ce_1_sg_x518: std_logic;
  signal choice_y_net: std_logic_vector(3 downto 0);
  signal clk_1_sg_x518: std_logic;
  signal concat_y_net: std_logic_vector(4 downto 0);
  signal concat_y_net_x3: std_logic_vector(49 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(1 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(72 downto 0);
  signal constant_op_net: std_logic_vector(3 downto 0);
  signal count_op_net: std_logic_vector(8 downto 0);
  signal dcoeffs_q_net_x0: std_logic_vector(35 downto 0);
  signal dconcat_q_net: std_logic_vector(4 downto 0);
  signal delay0_q_net_x2: std_logic;
  signal den0_q_net: std_logic;
  signal dmisc_q_net_x1: std_logic_vector(72 downto 0);
  signal doffset0_q_net: std_logic_vector(3 downto 0);
  signal doffset1_q_net: std_logic_vector(3 downto 0);
  signal dselect_q_net_x0: std_logic;
  signal en_op_net_x0: std_logic;
  signal force_im_output_port_net_x1: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(17 downto 0);
  signal offset_y_net: std_logic_vector(3 downto 0);
  signal reference_values_data_net_x1: std_logic_vector(35 downto 0);
  signal rotation_imag_op_net_x0: std_logic_vector(24 downto 0);
  signal rotation_real_op_net_x0: std_logic_vector(24 downto 0);
  signal segment_y_net: std_logic;
  signal select_op_net: std_logic;
  signal working_values_doutb_net_x1: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x518 <= ce_1;
  clk_1_sg_x518 <= clk_1;
  en_op_net_x0 <= en;
  concatenate_y_net_x5 <= misci;
  delay0_q_net_x2 <= sync;
  cos <= force_re_output_port_net_x1;
  misco <= dmisc_q_net_x1;
  sin <= force_im_output_port_net_x1;

  c_to_ri_11343a62a1: entity work.c_to_ri_entity_27418540ef
    port map (
      c => dcoeffs_q_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  choice: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 7,
      x_width => 9,
      y_width => 4
    )
    port map (
      x => count_op_net,
      y => choice_y_net
    );

  cmult_82c1bccdfe: entity work.cmult_entity_99c91d3ed6
    port map (
      a => working_values_doutb_net_x1,
      b => concat_y_net_x3,
      ce_1 => ce_1_sg_x518,
      clk_1 => clk_1_sg_x518,
      ab => concat_y_net_x5
    );

  concat: entity work.concat_cf540617d5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => segment_y_net,
      in1 => offset_y_net,
      y => concat_y_net
    );

  constant_x0: entity work.constant_4c449dd556
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  count: entity work.xlcounter_free_window_and_fft_test_v4
    generic map (
      core_name0 => "cntr_11_0_9966d4e54ef143a4",
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x518,
      clk => clk_1_sg_x518,
      clr => '0',
      en(0) => en_op_net_x0,
      rst(0) => delay0_q_net_x2,
      op => count_op_net
    );

  dcoeffs: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x518,
      clk => clk_1_sg_x518,
      clr => '0',
      d => concatenate_y_net_x3,
      q => dcoeffs_q_net_x0
    );

  dconcat: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 5
    )
    port map (
      ce => ce_1_sg_x518,
      clk => clk_1_sg_x518,
      d => concat_y_net,
      en => '1',
      rst => '1',
      q => dconcat_q_net
    );

  den0: entity work.xldelay
    generic map (
      latency => 10,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x518,
      clk => clk_1_sg_x518,
      d(0) => en_op_net_x0,
      en => '1',
      rst => '1',
      q(0) => den0_q_net
    );

  dmisc: entity work.delay_055ed7478a
    port map (
      ce => ce_1_sg_x518,
      clk => clk_1_sg_x518,
      clr => '0',
      d => concatenate_y_net_x5,
      q => dmisc_q_net_x1
    );

  doffset0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 4
    )
    port map (
      ce => ce_1_sg_x518,
      clk => clk_1_sg_x518,
      d => offset_y_net,
      en => '1',
      rst => '1',
      q => doffset0_q_net
    );

  doffset1: entity work.xldelay
    generic map (
      latency => 10,
      reg_retiming => 0,
      reset => 0,
      width => 4
    )
    port map (
      ce => ce_1_sg_x518,
      clk => clk_1_sg_x518,
      d => offset_y_net,
      en => '1',
      rst => '1',
      q => doffset1_q_net
    );

  dselect: entity work.delay_aab7b18c27
    port map (
      ce => ce_1_sg_x518,
      clk => clk_1_sg_x518,
      clr => '0',
      d(0) => select_op_net,
      q(0) => dselect_q_net_x0
    );

  offset: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 3,
      x_width => 9,
      y_width => 4
    )
    port map (
      x => count_op_net,
      y => offset_y_net
    );

  outmux_2c0a9df61b: entity work.outmux_entity_2e9bdd648a
    port map (
      ce_1 => ce_1_sg_x518,
      clk_1 => clk_1_sg_x518,
      d0 => reference_values_data_net_x1,
      d1 => concat_y_net_x5,
      sel => concatenate_y_net_x4,
      out_x0 => concatenate_y_net_x3
    );

  reference_values: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 5,
      c_width => 36,
      core_name0 => "bmg_72_2d8e9bcfdb574c10",
      latency => 1
    )
    port map (
      addr => dconcat_q_net,
      ce => ce_1_sg_x518,
      clk => clk_1_sg_x518,
      en => "1",
      rst => "0",
      data => reference_values_data_net_x1
    );

  ri_to_c_68a838319f: entity work.ri_to_c_entity_bdc22e7566
    port map (
      im => rotation_imag_op_net_x0,
      re => rotation_real_op_net_x0,
      c => concat_y_net_x3
    );

  rotation_imag: entity work.constant_e4af129d49
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => rotation_imag_op_net_x0
    );

  rotation_real: entity work.constant_6731bdab96
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => rotation_real_op_net_x0
    );

  segment: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => count_op_net,
      y(0) => segment_y_net
    );

  sel_replicate_318fce8bca: entity work.sel_replicate_entity_ed643ef8b8
    port map (
      ce_1 => ce_1_sg_x518,
      clk_1 => clk_1_sg_x518,
      in_x0 => dselect_q_net_x0,
      out_x0 => concatenate_y_net_x4
    );

  select_x0: entity work.relational_01718d4f17
    port map (
      a => constant_op_net,
      b => choice_y_net,
      ce => ce_1_sg_x518,
      clk => clk_1_sg_x518,
      clr => '0',
      op(0) => select_op_net
    );

  working_values: entity work.xldpram_dist_window_and_fft_test_v4
    generic map (
      addr_width => 4,
      c_address_width => 4,
      c_width => 36,
      core_name0 => "dmg_72_06baee6e81a49674",
      latency => 2
    )
    port map (
      a_ce => ce_1_sg_x518,
      a_clk => clk_1_sg_x518,
      addra => doffset1_q_net,
      addrb => doffset0_q_net,
      b_ce => ce_1_sg_x518,
      b_clk => clk_1_sg_x518,
      dina => concatenate_y_net_x3,
      ena => "1",
      enb => "1",
      wea(0) => den0_q_net,
      doutb => working_values_doutb_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly1_0/twiddle/coeff_gen"

entity coeff_gen_entity_95edfda61e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    rst: in std_logic; 
    misco: out std_logic_vector(72 downto 0); 
    w: out std_logic_vector(35 downto 0)
  );
end coeff_gen_entity_95edfda61e;

architecture structural of coeff_gen_entity_95edfda61e is
  signal ce_1_sg_x519: std_logic;
  signal clk_1_sg_x519: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(72 downto 0);
  signal delay0_q_net_x3: std_logic;
  signal dmisc_q_net_x2: std_logic_vector(72 downto 0);
  signal en_op_net_x0: std_logic;
  signal force_im_output_port_net_x2: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x519 <= ce_1;
  clk_1_sg_x519 <= clk_1;
  concatenate_y_net_x6 <= misci;
  delay0_q_net_x3 <= rst;
  misco <= dmisc_q_net_x2;
  w <= concat_y_net_x5;

  en: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => en_op_net_x0
    );

  feedback_osc_24b0f033c4: entity work.feedback_osc_entity_24b0f033c4
    port map (
      ce_1 => ce_1_sg_x519,
      clk_1 => clk_1_sg_x519,
      en => en_op_net_x0,
      misci => concatenate_y_net_x6,
      sync => delay0_q_net_x3,
      cos => force_re_output_port_net_x2,
      misco => dmisc_q_net_x2,
      sin => force_im_output_port_net_x2
    );

  ri_to_c_5ee8f4018c: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => force_im_output_port_net_x2,
      re => force_re_output_port_net_x2,
      c => concat_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly1_0/twiddle"

entity twiddle_entity_9e73da22c9 is
  port (
    ai: in std_logic_vector(35 downto 0); 
    bi: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ao: out std_logic_vector(35 downto 0); 
    bwo: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end twiddle_entity_9e73da22c9;

architecture structural of twiddle_entity_9e73da22c9 is
  signal ce_1_sg_x520: std_logic;
  signal clk_1_sg_x520: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(72 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(37 downto 0);
  signal delay0_q_net_x4: std_logic;
  signal dmisc_q_net_x2: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x3: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x4: std_logic_vector(72 downto 0);
  signal reinterpret1_output_port_net_x10: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x5: std_logic_vector(35 downto 0);
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret2_output_port_net_x5 <= ai;
  reinterpret1_output_port_net_x2 <= bi;
  ce_1_sg_x520 <= ce_1;
  clk_1_sg_x520 <= clk_1;
  delay0_q_net_x4 <= sync_in;
  ao <= reinterpret1_output_port_net_x11;
  bwo <= concatenate_y_net_x8;
  sync_out <= slice2_y_net_x1;

  bus_convert_497e9a5ac4: entity work.bus_convert_entity_8995348ed7
    port map (
      ce_1 => ce_1_sg_x520,
      clk_1 => clk_1_sg_x520,
      din => reinterpret1_output_port_net_x10,
      misci => dmisc_q_net_x2,
      dout => concatenate_y_net_x8,
      misco => dmisc_q_net_x3
    );

  bus_create_fd13330477: entity work.bus_create_entity_bca4476356
    port map (
      in1 => reinterpret1_output_port_net_x2,
      in2 => delay0_q_net_x4,
      in3 => reinterpret2_output_port_net_x5,
      bus_out => concatenate_y_net_x7
    );

  bus_expand1_cfc29b8177: entity work.bus_expand1_entity_94af2caf5e
    port map (
      bus_in => dmisc_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x11,
      msb_out2 => slice2_y_net_x1
    );

  bus_expand_0d33d2eb8d: entity work.bus_expand_entity_0c73098dab
    port map (
      bus_in => dmisc_q_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x9,
      msb_out2 => reinterpret2_output_port_net_x4
    );

  bus_mult_b811034997: entity work.bus_mult_entity_516ba8171e
    port map (
      a => concat_y_net_x5,
      b => reinterpret2_output_port_net_x4,
      ce_1 => ce_1_sg_x520,
      clk_1 => clk_1_sg_x520,
      misci => reinterpret1_output_port_net_x9,
      a_b => reinterpret1_output_port_net_x10,
      misco => dmisc_q_net_x2
    );

  coeff_gen_95edfda61e: entity work.coeff_gen_entity_95edfda61e
    port map (
      ce_1 => ce_1_sg_x520,
      clk_1 => clk_1_sg_x520,
      misci => concatenate_y_net_x7,
      rst => delay0_q_net_x4,
      misco => dmisc_q_net_x4,
      w => concat_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly1_0"

entity butterfly1_0_entity_135fbf9fb0 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end butterfly1_0_entity_135fbf9fb0;

architecture structural of butterfly1_0_entity_135fbf9fb0 is
  signal ce_1_sg_x521: std_logic;
  signal clk_1_sg_x521: std_logic;
  signal concat_y_net_x3: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x11: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(83 downto 0);
  signal delay0_q_net_x0: std_logic;
  signal delay0_q_net_x5: std_logic;
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x6: std_logic_vector(35 downto 0);
  signal slice1_y_net_x1: std_logic;
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret2_output_port_net_x6 <= a;
  reinterpret1_output_port_net_x3 <= b;
  ce_1_sg_x521 <= ce_1;
  clk_1_sg_x521 <= clk_1;
  slice1_y_net_x1 <= shift;
  delay0_q_net_x5 <= sync_in;
  a_bw <= reinterpret2_output_port_net_x2;
  sync_out <= delay0_q_net_x0;

  bus_add_cc89ff939c: entity work.bus_add_entity_b1cdda5af7
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      dout => concatenate_y_net_x3
    );

  bus_convert_b982af6b96: entity work.bus_convert_entity_b950f53ae4
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      din => concatenate_y_net_x9,
      dout => concatenate_y_net_x4
    );

  bus_expand_23b685a9dd: entity work.bus_expand_entity_23b685a9dd
    port map (
      bus_in => concatenate_y_net_x4,
      msb_out2 => reinterpret2_output_port_net_x2
    );

  bus_norm0_aac513cdf9: entity work.bus_norm0_entity_e7ca085468
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x5
    );

  bus_norm1_56ceee53f2: entity work.bus_norm1_entity_bd510a87ea
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x6
    );

  bus_scale_3da1662e56: entity work.bus_scale_entity_25e603273f
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_cd674f9a37: entity work.bus_sub_entity_9893acc382
    port map (
      a => reinterpret1_output_port_net_x11,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_cfdc93535e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x3,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  delay0: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x521,
      clk => clk_1_sg_x521,
      clr => '0',
      d(0) => slice2_y_net_x1,
      q(0) => delay0_q_net_x0
    );

  mux_9692eb6794: entity work.mux_entity_83804557c8
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      d0 => concatenate_y_net_x5,
      d1 => concatenate_y_net_x6,
      sel => concatenate_y_net_x10,
      out_x0 => concatenate_y_net_x9
    );

  shift_replicate_66ad24b9af: entity work.shift_replicate_entity_7f26e672bf
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      in_x0 => slice1_y_net_x1,
      out_x0 => concatenate_y_net_x10
    );

  twiddle_9e73da22c9: entity work.twiddle_entity_9e73da22c9
    port map (
      ai => reinterpret2_output_port_net_x6,
      bi => reinterpret1_output_port_net_x3,
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      sync_in => delay0_q_net_x5,
      ao => reinterpret1_output_port_net_x11,
      bwo => concatenate_y_net_x11,
      sync_out => slice2_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly1_1/twiddle/bus_expand1"

entity bus_expand1_entity_47e1c34a37 is
  port (
    bus_in: in std_logic_vector(36 downto 0); 
    lsb_out1: out std_logic_vector(35 downto 0)
  );
end bus_expand1_entity_47e1c34a37;

architecture structural of bus_expand1_entity_47e1c34a37 is
  signal dmisc_q_net_x3: std_logic_vector(36 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);
  signal slice1_y_net: std_logic_vector(35 downto 0);

begin
  dmisc_q_net_x3 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x6;

  reinterpret1: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x6
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 35,
      x_width => 37,
      y_width => 36
    )
    port map (
      x => dmisc_q_net_x3,
      y => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly1_1/twiddle/coeff_gen/feedback_osc"

entity feedback_osc_entity_ad82cf63a0 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    en: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    sync: in std_logic; 
    cos: out std_logic_vector(17 downto 0); 
    misco: out std_logic_vector(72 downto 0); 
    sin: out std_logic_vector(17 downto 0)
  );
end feedback_osc_entity_ad82cf63a0;

architecture structural of feedback_osc_entity_ad82cf63a0 is
  signal ce_1_sg_x553: std_logic;
  signal choice_y_net: std_logic_vector(3 downto 0);
  signal clk_1_sg_x553: std_logic;
  signal concat_y_net: std_logic_vector(4 downto 0);
  signal concat_y_net_x3: std_logic_vector(49 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(1 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(72 downto 0);
  signal constant_op_net: std_logic_vector(3 downto 0);
  signal count_op_net: std_logic_vector(8 downto 0);
  signal dcoeffs_q_net_x0: std_logic_vector(35 downto 0);
  signal dconcat_q_net: std_logic_vector(4 downto 0);
  signal delay0_q_net_x7: std_logic;
  signal den0_q_net: std_logic;
  signal dmisc_q_net_x1: std_logic_vector(72 downto 0);
  signal doffset0_q_net: std_logic_vector(3 downto 0);
  signal doffset1_q_net: std_logic_vector(3 downto 0);
  signal dselect_q_net_x0: std_logic;
  signal en_op_net_x0: std_logic;
  signal force_im_output_port_net_x1: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(17 downto 0);
  signal offset_y_net: std_logic_vector(3 downto 0);
  signal reference_values_data_net_x1: std_logic_vector(35 downto 0);
  signal rotation_imag_op_net_x0: std_logic_vector(24 downto 0);
  signal rotation_real_op_net_x0: std_logic_vector(24 downto 0);
  signal segment_y_net: std_logic;
  signal select_op_net: std_logic;
  signal working_values_doutb_net_x1: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x553 <= ce_1;
  clk_1_sg_x553 <= clk_1;
  en_op_net_x0 <= en;
  concatenate_y_net_x5 <= misci;
  delay0_q_net_x7 <= sync;
  cos <= force_re_output_port_net_x1;
  misco <= dmisc_q_net_x1;
  sin <= force_im_output_port_net_x1;

  c_to_ri_53b7c92eeb: entity work.c_to_ri_entity_27418540ef
    port map (
      c => dcoeffs_q_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  choice: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 7,
      x_width => 9,
      y_width => 4
    )
    port map (
      x => count_op_net,
      y => choice_y_net
    );

  cmult_ad031738a3: entity work.cmult_entity_99c91d3ed6
    port map (
      a => working_values_doutb_net_x1,
      b => concat_y_net_x3,
      ce_1 => ce_1_sg_x553,
      clk_1 => clk_1_sg_x553,
      ab => concat_y_net_x5
    );

  concat: entity work.concat_cf540617d5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => segment_y_net,
      in1 => offset_y_net,
      y => concat_y_net
    );

  constant_x0: entity work.constant_4c449dd556
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  count: entity work.xlcounter_free_window_and_fft_test_v4
    generic map (
      core_name0 => "cntr_11_0_9966d4e54ef143a4",
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x553,
      clk => clk_1_sg_x553,
      clr => '0',
      en(0) => en_op_net_x0,
      rst(0) => delay0_q_net_x7,
      op => count_op_net
    );

  dcoeffs: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x553,
      clk => clk_1_sg_x553,
      clr => '0',
      d => concatenate_y_net_x3,
      q => dcoeffs_q_net_x0
    );

  dconcat: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 5
    )
    port map (
      ce => ce_1_sg_x553,
      clk => clk_1_sg_x553,
      d => concat_y_net,
      en => '1',
      rst => '1',
      q => dconcat_q_net
    );

  den0: entity work.xldelay
    generic map (
      latency => 10,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x553,
      clk => clk_1_sg_x553,
      d(0) => en_op_net_x0,
      en => '1',
      rst => '1',
      q(0) => den0_q_net
    );

  dmisc: entity work.delay_055ed7478a
    port map (
      ce => ce_1_sg_x553,
      clk => clk_1_sg_x553,
      clr => '0',
      d => concatenate_y_net_x5,
      q => dmisc_q_net_x1
    );

  doffset0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 4
    )
    port map (
      ce => ce_1_sg_x553,
      clk => clk_1_sg_x553,
      d => offset_y_net,
      en => '1',
      rst => '1',
      q => doffset0_q_net
    );

  doffset1: entity work.xldelay
    generic map (
      latency => 10,
      reg_retiming => 0,
      reset => 0,
      width => 4
    )
    port map (
      ce => ce_1_sg_x553,
      clk => clk_1_sg_x553,
      d => offset_y_net,
      en => '1',
      rst => '1',
      q => doffset1_q_net
    );

  dselect: entity work.delay_aab7b18c27
    port map (
      ce => ce_1_sg_x553,
      clk => clk_1_sg_x553,
      clr => '0',
      d(0) => select_op_net,
      q(0) => dselect_q_net_x0
    );

  offset: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 3,
      x_width => 9,
      y_width => 4
    )
    port map (
      x => count_op_net,
      y => offset_y_net
    );

  outmux_4093fadf1f: entity work.outmux_entity_2e9bdd648a
    port map (
      ce_1 => ce_1_sg_x553,
      clk_1 => clk_1_sg_x553,
      d0 => reference_values_data_net_x1,
      d1 => concat_y_net_x5,
      sel => concatenate_y_net_x4,
      out_x0 => concatenate_y_net_x3
    );

  reference_values: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 5,
      c_width => 36,
      core_name0 => "bmg_72_ffcaf565dc759de1",
      latency => 1
    )
    port map (
      addr => dconcat_q_net,
      ce => ce_1_sg_x553,
      clk => clk_1_sg_x553,
      en => "1",
      rst => "0",
      data => reference_values_data_net_x1
    );

  ri_to_c_69bf98eb87: entity work.ri_to_c_entity_bdc22e7566
    port map (
      im => rotation_imag_op_net_x0,
      re => rotation_real_op_net_x0,
      c => concat_y_net_x3
    );

  rotation_imag: entity work.constant_e4af129d49
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => rotation_imag_op_net_x0
    );

  rotation_real: entity work.constant_6731bdab96
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => rotation_real_op_net_x0
    );

  segment: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => count_op_net,
      y(0) => segment_y_net
    );

  sel_replicate_fada1cd6d3: entity work.sel_replicate_entity_ed643ef8b8
    port map (
      ce_1 => ce_1_sg_x553,
      clk_1 => clk_1_sg_x553,
      in_x0 => dselect_q_net_x0,
      out_x0 => concatenate_y_net_x4
    );

  select_x0: entity work.relational_01718d4f17
    port map (
      a => constant_op_net,
      b => choice_y_net,
      ce => ce_1_sg_x553,
      clk => clk_1_sg_x553,
      clr => '0',
      op(0) => select_op_net
    );

  working_values: entity work.xldpram_dist_window_and_fft_test_v4
    generic map (
      addr_width => 4,
      c_address_width => 4,
      c_width => 36,
      core_name0 => "dmg_72_06baee6e81a49674",
      latency => 2
    )
    port map (
      a_ce => ce_1_sg_x553,
      a_clk => clk_1_sg_x553,
      addra => doffset1_q_net,
      addrb => doffset0_q_net,
      b_ce => ce_1_sg_x553,
      b_clk => clk_1_sg_x553,
      dina => concatenate_y_net_x3,
      ena => "1",
      enb => "1",
      wea(0) => den0_q_net,
      doutb => working_values_doutb_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly1_1/twiddle/coeff_gen"

entity coeff_gen_entity_60ab7febeb is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    misci: in std_logic_vector(72 downto 0); 
    rst: in std_logic; 
    misco: out std_logic_vector(72 downto 0); 
    w: out std_logic_vector(35 downto 0)
  );
end coeff_gen_entity_60ab7febeb;

architecture structural of coeff_gen_entity_60ab7febeb is
  signal ce_1_sg_x554: std_logic;
  signal clk_1_sg_x554: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(72 downto 0);
  signal delay0_q_net_x8: std_logic;
  signal dmisc_q_net_x2: std_logic_vector(72 downto 0);
  signal en_op_net_x0: std_logic;
  signal force_im_output_port_net_x2: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x554 <= ce_1;
  clk_1_sg_x554 <= clk_1;
  concatenate_y_net_x6 <= misci;
  delay0_q_net_x8 <= rst;
  misco <= dmisc_q_net_x2;
  w <= concat_y_net_x5;

  en: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => en_op_net_x0
    );

  feedback_osc_ad82cf63a0: entity work.feedback_osc_entity_ad82cf63a0
    port map (
      ce_1 => ce_1_sg_x554,
      clk_1 => clk_1_sg_x554,
      en => en_op_net_x0,
      misci => concatenate_y_net_x6,
      sync => delay0_q_net_x8,
      cos => force_re_output_port_net_x2,
      misco => dmisc_q_net_x2,
      sin => force_im_output_port_net_x2
    );

  ri_to_c_d554c6d452: entity work.ri_to_c_entity_bee9343a9a
    port map (
      im => force_im_output_port_net_x2,
      re => force_re_output_port_net_x2,
      c => concat_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly1_1/twiddle"

entity twiddle_entity_22d3e50fff is
  port (
    ai: in std_logic_vector(35 downto 0); 
    bi: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ao: out std_logic_vector(35 downto 0); 
    bwo: out std_logic_vector(37 downto 0)
  );
end twiddle_entity_22d3e50fff;

architecture structural of twiddle_entity_22d3e50fff is
  signal ce_1_sg_x555: std_logic;
  signal clk_1_sg_x555: std_logic;
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(72 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(37 downto 0);
  signal delay0_q_net_x9: std_logic;
  signal dmisc_q_net_x2: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x3: std_logic_vector(36 downto 0);
  signal dmisc_q_net_x4: std_logic_vector(72 downto 0);
  signal reinterpret1_output_port_net_x10: std_logic_vector(73 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x9: std_logic_vector(36 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);

begin
  reinterpret2_output_port_net_x2 <= ai;
  reinterpret1_output_port_net_x11 <= bi;
  ce_1_sg_x555 <= ce_1;
  clk_1_sg_x555 <= clk_1;
  delay0_q_net_x9 <= sync_in;
  ao <= reinterpret1_output_port_net_x12;
  bwo <= concatenate_y_net_x8;

  bus_convert_e0179724eb: entity work.bus_convert_entity_8995348ed7
    port map (
      ce_1 => ce_1_sg_x555,
      clk_1 => clk_1_sg_x555,
      din => reinterpret1_output_port_net_x10,
      misci => dmisc_q_net_x2,
      dout => concatenate_y_net_x8,
      misco => dmisc_q_net_x3
    );

  bus_create_c1ec0f7702: entity work.bus_create_entity_bca4476356
    port map (
      in1 => reinterpret1_output_port_net_x11,
      in2 => delay0_q_net_x9,
      in3 => reinterpret2_output_port_net_x2,
      bus_out => concatenate_y_net_x7
    );

  bus_expand1_47e1c34a37: entity work.bus_expand1_entity_47e1c34a37
    port map (
      bus_in => dmisc_q_net_x3,
      lsb_out1 => reinterpret1_output_port_net_x12
    );

  bus_expand_315f94daae: entity work.bus_expand_entity_0c73098dab
    port map (
      bus_in => dmisc_q_net_x4,
      lsb_out1 => reinterpret1_output_port_net_x9,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  bus_mult_33f7a13f0c: entity work.bus_mult_entity_516ba8171e
    port map (
      a => concat_y_net_x5,
      b => reinterpret2_output_port_net_x3,
      ce_1 => ce_1_sg_x555,
      clk_1 => clk_1_sg_x555,
      misci => reinterpret1_output_port_net_x9,
      a_b => reinterpret1_output_port_net_x10,
      misco => dmisc_q_net_x2
    );

  coeff_gen_60ab7febeb: entity work.coeff_gen_entity_60ab7febeb
    port map (
      ce_1 => ce_1_sg_x555,
      clk_1 => clk_1_sg_x555,
      misci => concatenate_y_net_x7,
      rst => delay0_q_net_x9,
      misco => dmisc_q_net_x4,
      w => concat_y_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct/butterfly1_1"

entity butterfly1_1_entity_d1c7ec9809 is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    shift: in std_logic; 
    sync_in: in std_logic; 
    a_bw: out std_logic_vector(35 downto 0)
  );
end butterfly1_1_entity_d1c7ec9809;

architecture structural of butterfly1_1_entity_d1c7ec9809 is
  signal ce_1_sg_x556: std_logic;
  signal clk_1_sg_x556: std_logic;
  signal concat_y_net_x3: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x10: std_logic_vector(3 downto 0);
  signal concatenate_y_net_x11: std_logic_vector(37 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x4: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x5: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x6: std_logic_vector(83 downto 0);
  signal concatenate_y_net_x7: std_logic_vector(79 downto 0);
  signal concatenate_y_net_x8: std_logic_vector(39 downto 0);
  signal concatenate_y_net_x9: std_logic_vector(83 downto 0);
  signal delay0_q_net_x10: std_logic;
  signal reinterpret1_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x13: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x4: std_logic_vector(35 downto 0);
  signal slice1_y_net_x3: std_logic;

begin
  reinterpret2_output_port_net_x3 <= a;
  reinterpret1_output_port_net_x13 <= b;
  ce_1_sg_x556 <= ce_1;
  clk_1_sg_x556 <= clk_1;
  slice1_y_net_x3 <= shift;
  delay0_q_net_x10 <= sync_in;
  a_bw <= reinterpret2_output_port_net_x4;

  bus_add_1aa1ca00cd: entity work.bus_add_entity_b1cdda5af7
    port map (
      a => reinterpret1_output_port_net_x12,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x556,
      clk_1 => clk_1_sg_x556,
      dout => concatenate_y_net_x3
    );

  bus_convert_683740d9b5: entity work.bus_convert_entity_b950f53ae4
    port map (
      ce_1 => ce_1_sg_x556,
      clk_1 => clk_1_sg_x556,
      din => concatenate_y_net_x9,
      dout => concatenate_y_net_x4
    );

  bus_expand_ccb644fa31: entity work.bus_expand_entity_23b685a9dd
    port map (
      bus_in => concatenate_y_net_x4,
      msb_out2 => reinterpret2_output_port_net_x4
    );

  bus_norm0_e001910186: entity work.bus_norm0_entity_e7ca085468
    port map (
      ce_1 => ce_1_sg_x556,
      clk_1 => clk_1_sg_x556,
      din => concat_y_net_x3,
      dout => concatenate_y_net_x5
    );

  bus_norm1_70a4fbcf75: entity work.bus_norm1_entity_bd510a87ea
    port map (
      ce_1 => ce_1_sg_x556,
      clk_1 => clk_1_sg_x556,
      din => concatenate_y_net_x7,
      dout => concatenate_y_net_x6
    );

  bus_scale_850913e127: entity work.bus_scale_entity_25e603273f
    port map (
      din => concat_y_net_x3,
      dout => concatenate_y_net_x7
    );

  bus_sub_bfaf8bb079: entity work.bus_sub_entity_9893acc382
    port map (
      a => reinterpret1_output_port_net_x12,
      b => concatenate_y_net_x11,
      ce_1 => ce_1_sg_x556,
      clk_1 => clk_1_sg_x556,
      dout => concatenate_y_net_x8
    );

  concat: entity work.concat_cfdc93535e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concatenate_y_net_x3,
      in1 => concatenate_y_net_x8,
      y => concat_y_net_x3
    );

  mux_947f2c3cda: entity work.mux_entity_83804557c8
    port map (
      ce_1 => ce_1_sg_x556,
      clk_1 => clk_1_sg_x556,
      d0 => concatenate_y_net_x5,
      d1 => concatenate_y_net_x6,
      sel => concatenate_y_net_x10,
      out_x0 => concatenate_y_net_x9
    );

  shift_replicate_9988fc47c7: entity work.shift_replicate_entity_7f26e672bf
    port map (
      ce_1 => ce_1_sg_x556,
      clk_1 => clk_1_sg_x556,
      in_x0 => slice1_y_net_x3,
      out_x0 => concatenate_y_net_x10
    );

  twiddle_22d3e50fff: entity work.twiddle_entity_22d3e50fff
    port map (
      ai => reinterpret2_output_port_net_x3,
      bi => reinterpret1_output_port_net_x13,
      ce_1 => ce_1_sg_x556,
      clk_1 => clk_1_sg_x556,
      sync_in => delay0_q_net_x10,
      ao => reinterpret1_output_port_net_x12,
      bwo => concatenate_y_net_x11
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_direct"

entity fft_direct_entity_bb6d489f82 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in00: in std_logic_vector(35 downto 0); 
    in01: in std_logic_vector(35 downto 0); 
    in02: in std_logic_vector(35 downto 0); 
    in03: in std_logic_vector(35 downto 0); 
    shift: in std_logic_vector(1 downto 0); 
    sync: in std_logic; 
    out00: out std_logic_vector(35 downto 0); 
    out01: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_direct_entity_bb6d489f82;

architecture structural of fft_direct_entity_bb6d489f82 is
  signal ce_1_sg_x557: std_logic;
  signal clk_1_sg_x557: std_logic;
  signal concatenate_y_net_x14: std_logic_vector(71 downto 0);
  signal concatenate_y_net_x15: std_logic_vector(71 downto 0);
  signal delay0_q_net_x1: std_logic;
  signal delay0_q_net_x10: std_logic;
  signal reinterpret1_output_port_net_x11: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x13: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x14: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x15: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x16: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x17: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x18: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x19: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x7: std_logic_vector(71 downto 0);
  signal slice0_y_net_x1: std_logic;
  signal slice1_y_net_x3: std_logic;
  signal slice_y_net_x0: std_logic_vector(1 downto 0);
  signal sync_delay1_q_net_x8: std_logic;

begin
  ce_1_sg_x557 <= ce_1;
  clk_1_sg_x557 <= clk_1;
  reinterpret1_output_port_net_x14 <= in00;
  reinterpret1_output_port_net_x15 <= in01;
  reinterpret1_output_port_net_x16 <= in02;
  reinterpret1_output_port_net_x17 <= in03;
  slice_y_net_x0 <= shift;
  sync_delay1_q_net_x8 <= sync;
  out00 <= reinterpret1_output_port_net_x18;
  out01 <= reinterpret1_output_port_net_x19;
  sync_out <= delay0_q_net_x1;

  abus_7739dc1465: entity work.bussify_entity_400b078c8a
    port map (
      in1 => reinterpret1_output_port_net_x14,
      in2 => reinterpret1_output_port_net_x15,
      bus_out => concatenate_y_net_x14
    );

  adebus0_0_a9e0c306f8: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => reinterpret2_output_port_net_x7,
      lsb_out1 => reinterpret1_output_port_net_x3,
      msb_out2 => reinterpret2_output_port_net_x6
    );

  adebus1_0_e55985ff33: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret2_output_port_net_x2,
      msb_lsb_out1 => reinterpret1_output_port_net_x18
    );

  adebus1_1_e9fee1e111: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret2_output_port_net_x4,
      msb_lsb_out1 => reinterpret1_output_port_net_x19
    );

  bbus_d2c377a884: entity work.bussify_entity_400b078c8a
    port map (
      in1 => reinterpret1_output_port_net_x16,
      in2 => reinterpret1_output_port_net_x17,
      bus_out => concatenate_y_net_x15
    );

  bdebus0_0_661132becd: entity work.bus_expand_entity_8d8547ea86
    port map (
      bus_in => reinterpret1_output_port_net_x11,
      lsb_out1 => reinterpret1_output_port_net_x13,
      msb_out2 => reinterpret2_output_port_net_x3
    );

  butterfly0_0_0276d59789: entity work.butterfly0_0_entity_0276d59789
    port map (
      a => concatenate_y_net_x14,
      b => concatenate_y_net_x15,
      ce_1 => ce_1_sg_x557,
      clk_1 => clk_1_sg_x557,
      shift => slice0_y_net_x1,
      sync_in => sync_delay1_q_net_x8,
      a_bw => reinterpret1_output_port_net_x11,
      a_bw_x0 => reinterpret2_output_port_net_x7,
      sync_out => delay0_q_net_x10
    );

  butterfly1_0_135fbf9fb0: entity work.butterfly1_0_entity_135fbf9fb0
    port map (
      a => reinterpret2_output_port_net_x6,
      b => reinterpret1_output_port_net_x3,
      ce_1 => ce_1_sg_x557,
      clk_1 => clk_1_sg_x557,
      shift => slice1_y_net_x3,
      sync_in => delay0_q_net_x10,
      a_bw => reinterpret2_output_port_net_x2,
      sync_out => delay0_q_net_x1
    );

  butterfly1_1_d1c7ec9809: entity work.butterfly1_1_entity_d1c7ec9809
    port map (
      a => reinterpret2_output_port_net_x3,
      b => reinterpret1_output_port_net_x13,
      ce_1 => ce_1_sg_x557,
      clk_1 => clk_1_sg_x557,
      shift => slice1_y_net_x3,
      sync_in => delay0_q_net_x10,
      a_bw => reinterpret2_output_port_net_x4
    );

  slice0: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => slice0_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => slice_y_net_x0,
      y(0) => slice1_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/addr_expand"

entity addr_expand_entity_c642de21e1 is
  port (
    bus_in: in std_logic_vector(17 downto 0); 
    lsb_out1: out std_logic_vector(8 downto 0); 
    msb_out2: out std_logic_vector(8 downto 0)
  );
end addr_expand_entity_c642de21e1;

architecture structural of addr_expand_entity_c642de21e1 is
  signal concatenate_y_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(8 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(8 downto 0);
  signal slice1_y_net: std_logic_vector(8 downto 0);
  signal slice2_y_net: std_logic_vector(8 downto 0);

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out2 <= reinterpret2_output_port_net_x0;

  reinterpret1: entity work.reinterpret_b754317574
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_b754317574
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 8,
      x_width => 18,
      y_width => 9
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 9,
      new_msb => 17,
      x_width => 18,
      y_width => 9
    )
    port map (
      x => concatenate_y_net_x0,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/addr_replicate/bussify"

entity bussify_entity_eaa3968c06 is
  port (
    in1: in std_logic_vector(8 downto 0); 
    in2: in std_logic_vector(8 downto 0); 
    bus_out: out std_logic_vector(17 downto 0)
  );
end bussify_entity_eaa3968c06;

architecture structural of bussify_entity_eaa3968c06 is
  signal concatenate_y_net_x1: std_logic_vector(17 downto 0);
  signal din0_0_q_net_x0: std_logic_vector(8 downto 0);
  signal din0_1_q_net_x0: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(8 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(8 downto 0);

begin
  din0_0_q_net_x0 <= in1;
  din0_1_q_net_x0 <= in2;
  bus_out <= concatenate_y_net_x1;

  concatenate: entity work.concat_f2f6490a28
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      y => concatenate_y_net_x1
    );

  reinterpret1: entity work.reinterpret_b754317574
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din0_0_q_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_b754317574
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din0_1_q_net_x0,
      output_port => reinterpret2_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/addr_replicate"

entity addr_replicate_entity_031e932087 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(8 downto 0); 
    out_x0: out std_logic_vector(17 downto 0)
  );
end addr_replicate_entity_031e932087;

architecture structural of addr_replicate_entity_031e932087 is
  signal ce_1_sg_x558: std_logic;
  signal clk_1_sg_x558: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(17 downto 0);
  signal din0_0_q_net_x0: std_logic_vector(8 downto 0);
  signal din0_1_q_net_x0: std_logic_vector(8 downto 0);
  signal map_mux_y_net_x0: std_logic_vector(8 downto 0);

begin
  ce_1_sg_x558 <= ce_1;
  clk_1_sg_x558 <= clk_1;
  map_mux_y_net_x0 <= in_x0;
  out_x0 <= concatenate_y_net_x2;

  bussify_eaa3968c06: entity work.bussify_entity_eaa3968c06
    port map (
      in1 => din0_0_q_net_x0,
      in2 => din0_1_q_net_x0,
      bus_out => concatenate_y_net_x2
    );

  din0_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x558,
      clk => clk_1_sg_x558,
      d => map_mux_y_net_x0,
      en => '1',
      rst => '1',
      q => din0_0_q_net_x0
    );

  din0_1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x558,
      clk => clk_1_sg_x558,
      d => map_mux_y_net_x0,
      en => '1',
      rst => '1',
      q => din0_1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/buf0/debus_addr"

entity debus_addr_entity_dfbf7e3025 is
  port (
    bus_in: in std_logic_vector(8 downto 0); 
    msb_lsb_out1: out std_logic_vector(8 downto 0)
  );
end debus_addr_entity_dfbf7e3025;

architecture structural of debus_addr_entity_dfbf7e3025 is
  signal reinterpret1_output_port_net_x1: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(8 downto 0);
  signal slice1_y_net: std_logic_vector(8 downto 0);

begin
  reinterpret1_output_port_net_x1 <= bus_in;
  msb_lsb_out1 <= reinterpret1_output_port_net_x2;

  reinterpret1: entity work.reinterpret_b754317574
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 8,
      x_width => 9,
      y_width => 9
    )
    port map (
      x => reinterpret1_output_port_net_x1,
      y => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/buf0/rep_addr/bussify"

entity bussify_entity_e63896cf3b is
  port (
    in1: in std_logic_vector(8 downto 0); 
    bus_out: out std_logic_vector(8 downto 0)
  );
end bussify_entity_e63896cf3b;

architecture structural of bussify_entity_e63896cf3b is
  signal din1_0_q_net_x0: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(8 downto 0);

begin
  din1_0_q_net_x0 <= in1;
  bus_out <= reinterpret1_output_port_net_x2;

  reinterpret1: entity work.reinterpret_b754317574
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => din1_0_q_net_x0,
      output_port => reinterpret1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/buf0/rep_addr"

entity rep_addr_entity_accc32e192 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(8 downto 0); 
    out_x0: out std_logic_vector(8 downto 0)
  );
end rep_addr_entity_accc32e192;

architecture structural of rep_addr_entity_accc32e192 is
  signal ce_1_sg_x559: std_logic;
  signal clk_1_sg_x559: std_logic;
  signal din0_0_q_net: std_logic_vector(8 downto 0);
  signal din1_0_q_net_x0: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(8 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(8 downto 0);

begin
  ce_1_sg_x559 <= ce_1;
  clk_1_sg_x559 <= clk_1;
  reinterpret2_output_port_net_x1 <= in_x0;
  out_x0 <= reinterpret1_output_port_net_x3;

  bussify_e63896cf3b: entity work.bussify_entity_e63896cf3b
    port map (
      in1 => din1_0_q_net_x0,
      bus_out => reinterpret1_output_port_net_x3
    );

  din0_0: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x559,
      clk => clk_1_sg_x559,
      clr => '0',
      d => reinterpret2_output_port_net_x1,
      q => din0_0_q_net
    );

  din1_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x559,
      clk => clk_1_sg_x559,
      d => din0_0_q_net,
      en => '1',
      rst => '1',
      q => din1_0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/buf0/rep_we"

entity rep_we_entity_50649b4f04 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end rep_we_entity_50649b4f04;

architecture structural of rep_we_entity_50649b4f04 is
  signal ce_1_sg_x560: std_logic;
  signal clk_1_sg_x560: std_logic;
  signal din0_0_q_net: std_logic;
  signal din1_0_q_net_x0: std_logic;
  signal reinterpret1_output_port_net_x2: std_logic;
  signal slice2_y_net_x0: std_logic;

begin
  ce_1_sg_x560 <= ce_1;
  clk_1_sg_x560 <= clk_1;
  slice2_y_net_x0 <= in_x0;
  out_x0 <= reinterpret1_output_port_net_x2;

  bussify_5cc4985352: entity work.bussify_entity_ac1ae9cf2f
    port map (
      in1 => din1_0_q_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

  din0_0: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x560,
      clk => clk_1_sg_x560,
      clr => '0',
      d(0) => slice2_y_net_x0,
      q(0) => din0_0_q_net
    );

  din1_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x560,
      clk => clk_1_sg_x560,
      d(0) => din0_0_q_net,
      en => '1',
      rst => '1',
      q(0) => din1_0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/buf0"

entity buf0_entity_f7768151e2 is
  port (
    addr: in std_logic_vector(8 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    we: in std_logic; 
    dout: out std_logic_vector(35 downto 0)
  );
end buf0_entity_f7768151e2;

architecture structural of buf0_entity_f7768151e2 is
  signal bram0_data_out_net_x0: std_logic_vector(35 downto 0);
  signal ce_1_sg_x561: std_logic;
  signal clk_1_sg_x561: std_logic;
  signal ddin_q_net_x0: std_logic_vector(35 downto 0);
  signal delay_din0_q_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic;
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(8 downto 0);
  signal slice1_y_net_x0: std_logic;
  signal slice2_y_net_x1: std_logic;

begin
  reinterpret2_output_port_net_x2 <= addr;
  ce_1_sg_x561 <= ce_1;
  clk_1_sg_x561 <= clk_1;
  delay_din0_q_net_x0 <= din;
  slice2_y_net_x1 <= we;
  dout <= reinterpret1_output_port_net_x6;

  bram0: entity work.xlspram_window_and_fft_test_v4
    generic map (
      c_address_width => 9,
      c_width => 36,
      core_name0 => "bmg_72_d53572f04cfc7154",
      latency => 1
    )
    port map (
      addr => reinterpret1_output_port_net_x2,
      ce => ce_1_sg_x561,
      clk => clk_1_sg_x561,
      data_in => reinterpret1_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => slice1_y_net_x0,
      data_out => bram0_data_out_net_x0
    );

  ddin: entity work.delay_38898c80c0
    port map (
      ce => ce_1_sg_x561,
      clk => clk_1_sg_x561,
      clr => '0',
      d => delay_din0_q_net_x0,
      q => ddin_q_net_x0
    );

  debus_addr_dfbf7e3025: entity work.debus_addr_entity_dfbf7e3025
    port map (
      bus_in => reinterpret1_output_port_net_x4,
      msb_lsb_out1 => reinterpret1_output_port_net_x2
    );

  debus_din_2612d68bbc: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => ddin_q_net_x0,
      msb_lsb_out1 => reinterpret1_output_port_net_x0
    );

  debus_we_c861442e09: entity work.debus_we_entity_13d5242861
    port map (
      bus_in => reinterpret1_output_port_net_x5,
      msb_lsb_out1 => slice1_y_net_x0
    );

  din_bussify_7e6ddc4de6: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => bram0_data_out_net_x0,
      bus_out => reinterpret1_output_port_net_x6
    );

  rep_addr_accc32e192: entity work.rep_addr_entity_accc32e192
    port map (
      ce_1 => ce_1_sg_x561,
      clk_1 => clk_1_sg_x561,
      in_x0 => reinterpret2_output_port_net_x2,
      out_x0 => reinterpret1_output_port_net_x4
    );

  rep_we_50649b4f04: entity work.rep_we_entity_50649b4f04
    port map (
      ce_1 => ce_1_sg_x561,
      clk_1 => clk_1_sg_x561,
      in_x0 => slice2_y_net_x1,
      out_x0 => reinterpret1_output_port_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/current_map/rep_addra"

entity rep_addra_entity_4da102357f is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(8 downto 0); 
    out_x0: out std_logic_vector(8 downto 0)
  );
end rep_addra_entity_4da102357f;

architecture structural of rep_addra_entity_4da102357f is
  signal ce_1_sg_x565: std_logic;
  signal clk_1_sg_x565: std_logic;
  signal daddr1_q_net_x0: std_logic_vector(8 downto 0);
  signal din0_0_q_net: std_logic_vector(8 downto 0);
  signal din1_0_q_net: std_logic_vector(8 downto 0);
  signal din2_0_q_net: std_logic_vector(8 downto 0);
  signal din3_0_q_net_x0: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(8 downto 0);

begin
  ce_1_sg_x565 <= ce_1;
  clk_1_sg_x565 <= clk_1;
  daddr1_q_net_x0 <= in_x0;
  out_x0 <= reinterpret1_output_port_net_x3;

  bussify_7d7e9dde8a: entity work.bussify_entity_e63896cf3b
    port map (
      in1 => din3_0_q_net_x0,
      bus_out => reinterpret1_output_port_net_x3
    );

  din0_0: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x565,
      clk => clk_1_sg_x565,
      clr => '0',
      d => daddr1_q_net_x0,
      q => din0_0_q_net
    );

  din1_0: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x565,
      clk => clk_1_sg_x565,
      clr => '0',
      d => din0_0_q_net,
      q => din1_0_q_net
    );

  din2_0: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x565,
      clk => clk_1_sg_x565,
      clr => '0',
      d => din1_0_q_net,
      q => din2_0_q_net
    );

  din3_0: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x565,
      clk => clk_1_sg_x565,
      clr => '0',
      d => din2_0_q_net,
      q => din3_0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/current_map/rep_addrb"

entity rep_addrb_entity_2eb3cd51ce is
  port (
    in_x0: in std_logic_vector(8 downto 0); 
    out_x0: out std_logic_vector(8 downto 0)
  );
end rep_addrb_entity_2eb3cd51ce;

architecture structural of rep_addrb_entity_2eb3cd51ce is
  signal daddr0_q_net_x1: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(8 downto 0);

begin
  daddr0_q_net_x1 <= in_x0;
  out_x0 <= reinterpret1_output_port_net_x3;

  bussify_48d34eb9a1: entity work.bussify_entity_e63896cf3b
    port map (
      in1 => daddr0_q_net_x1,
      bus_out => reinterpret1_output_port_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/current_map/rep_wea"

entity rep_wea_entity_0a2bb606c3 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end rep_wea_entity_0a2bb606c3;

architecture structural of rep_wea_entity_0a2bb606c3 is
  signal ce_1_sg_x566: std_logic;
  signal clk_1_sg_x566: std_logic;
  signal den_q_net_x0: std_logic;
  signal din0_0_q_net: std_logic;
  signal din1_0_q_net: std_logic;
  signal din2_0_q_net: std_logic;
  signal din3_0_q_net_x0: std_logic;
  signal reinterpret1_output_port_net_x2: std_logic;

begin
  ce_1_sg_x566 <= ce_1;
  clk_1_sg_x566 <= clk_1;
  den_q_net_x0 <= in_x0;
  out_x0 <= reinterpret1_output_port_net_x2;

  bussify_ec5dcb5188: entity work.bussify_entity_ac1ae9cf2f
    port map (
      in1 => din3_0_q_net_x0,
      bus_out => reinterpret1_output_port_net_x2
    );

  din0_0: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x566,
      clk => clk_1_sg_x566,
      clr => '0',
      d(0) => den_q_net_x0,
      q(0) => din0_0_q_net
    );

  din1_0: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x566,
      clk => clk_1_sg_x566,
      clr => '0',
      d(0) => din0_0_q_net,
      q(0) => din1_0_q_net
    );

  din2_0: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x566,
      clk => clk_1_sg_x566,
      clr => '0',
      d(0) => din1_0_q_net,
      q(0) => din2_0_q_net
    );

  din3_0: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x566,
      clk => clk_1_sg_x566,
      d(0) => din2_0_q_net,
      en => '1',
      rst => '1',
      q(0) => din3_0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/current_map"

entity current_map_entity_aff4ba913d is
  port (
    addra: in std_logic_vector(8 downto 0); 
    addrb: in std_logic_vector(8 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    dina: in std_logic_vector(8 downto 0); 
    dinb: in std_logic_vector(8 downto 0); 
    wea: in std_logic; 
    web: in std_logic; 
    b: out std_logic_vector(8 downto 0)
  );
end current_map_entity_aff4ba913d;

architecture structural of current_map_entity_aff4ba913d is
  signal blank_op_net_x0: std_logic_vector(8 downto 0);
  signal bram0_doutb_net_x0: std_logic_vector(8 downto 0);
  signal ce_1_sg_x567: std_logic;
  signal clk_1_sg_x567: std_logic;
  signal daddr0_q_net_x2: std_logic_vector(8 downto 0);
  signal daddr1_q_net_x1: std_logic_vector(8 downto 0);
  signal ddina_q_net_x0: std_logic_vector(8 downto 0);
  signal ddinb_q_net_x0: std_logic_vector(8 downto 0);
  signal den_q_net_x1: std_logic;
  signal dnew_map_q_net_x0: std_logic_vector(8 downto 0);
  signal never_op_net_x2: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x5: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x7: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x8: std_logic;
  signal reinterpret1_output_port_net_x9: std_logic;
  signal slice1_y_net_x0: std_logic;
  signal slice1_y_net_x1: std_logic;

begin
  daddr1_q_net_x1 <= addra;
  daddr0_q_net_x2 <= addrb;
  ce_1_sg_x567 <= ce_1;
  clk_1_sg_x567 <= clk_1;
  dnew_map_q_net_x0 <= dina;
  blank_op_net_x0 <= dinb;
  den_q_net_x1 <= wea;
  never_op_net_x2 <= web;
  b <= reinterpret1_output_port_net_x10;

  b_bussify_5bda2fec40: entity work.bussify_entity_e63896cf3b
    port map (
      in1 => bram0_doutb_net_x0,
      bus_out => reinterpret1_output_port_net_x10
    );

  bram0: entity work.xldpram_window_and_fft_test_v4
    generic map (
      c_address_width_a => 9,
      c_address_width_b => 9,
      c_width_a => 9,
      c_width_b => 9,
      core_name0 => "bmg_72_3673c2b46bfb142f",
      latency => 2
    )
    port map (
      a_ce => ce_1_sg_x567,
      a_clk => clk_1_sg_x567,
      addra => reinterpret1_output_port_net_x2,
      addrb => reinterpret1_output_port_net_x3,
      b_ce => ce_1_sg_x567,
      b_clk => clk_1_sg_x567,
      dina => reinterpret1_output_port_net_x4,
      dinb => reinterpret1_output_port_net_x5,
      ena => "1",
      enb => "1",
      rsta => "0",
      rstb => "0",
      wea(0) => slice1_y_net_x0,
      web(0) => slice1_y_net_x1,
      doutb => bram0_doutb_net_x0
    );

  ddina: entity work.delay_a99984b20e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => dnew_map_q_net_x0,
      q => ddina_q_net_x0
    );

  ddinb: entity work.delay_a99984b20e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => blank_op_net_x0,
      q => ddinb_q_net_x0
    );

  debus_addra_0b72f7bd93: entity work.debus_addr_entity_dfbf7e3025
    port map (
      bus_in => reinterpret1_output_port_net_x6,
      msb_lsb_out1 => reinterpret1_output_port_net_x2
    );

  debus_addrb_0e6081cf52: entity work.debus_addr_entity_dfbf7e3025
    port map (
      bus_in => reinterpret1_output_port_net_x7,
      msb_lsb_out1 => reinterpret1_output_port_net_x3
    );

  debus_dina_0624344442: entity work.debus_addr_entity_dfbf7e3025
    port map (
      bus_in => ddina_q_net_x0,
      msb_lsb_out1 => reinterpret1_output_port_net_x4
    );

  debus_dinb_56f6c654cc: entity work.debus_addr_entity_dfbf7e3025
    port map (
      bus_in => ddinb_q_net_x0,
      msb_lsb_out1 => reinterpret1_output_port_net_x5
    );

  debus_wea_1f1fdb5cd7: entity work.debus_we_entity_13d5242861
    port map (
      bus_in => reinterpret1_output_port_net_x8,
      msb_lsb_out1 => slice1_y_net_x0
    );

  debus_web_93466572d8: entity work.debus_we_entity_13d5242861
    port map (
      bus_in => reinterpret1_output_port_net_x9,
      msb_lsb_out1 => slice1_y_net_x1
    );

  rep_addra_4da102357f: entity work.rep_addra_entity_4da102357f
    port map (
      ce_1 => ce_1_sg_x567,
      clk_1 => clk_1_sg_x567,
      in_x0 => daddr1_q_net_x1,
      out_x0 => reinterpret1_output_port_net_x6
    );

  rep_addrb_2eb3cd51ce: entity work.rep_addrb_entity_2eb3cd51ce
    port map (
      in_x0 => daddr0_q_net_x2,
      out_x0 => reinterpret1_output_port_net_x7
    );

  rep_wea_0a2bb606c3: entity work.rep_wea_entity_0a2bb606c3
    port map (
      ce_1 => ce_1_sg_x567,
      clk_1 => clk_1_sg_x567,
      in_x0 => den_q_net_x1,
      out_x0 => reinterpret1_output_port_net_x8
    );

  rep_web_b72bacfa68: entity work.sel_replicate0_entity_463a6c0651
    port map (
      in_x0 => never_op_net_x2,
      out_x0 => reinterpret1_output_port_net_x9
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/edge_detect"

entity edge_detect_entity_f46b362212 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end edge_detect_entity_f46b362212;

architecture structural of edge_detect_entity_f46b362212 is
  signal ce_1_sg_x568: std_logic;
  signal clk_1_sg_x568: std_logic;
  signal delay_q_net: std_logic;
  signal edge_op_y_net_x0: std_logic;
  signal inverter_op_net: std_logic;
  signal msb_y_net_x0: std_logic;

begin
  ce_1_sg_x568 <= ce_1;
  clk_1_sg_x568 <= clk_1;
  msb_y_net_x0 <= in_x0;
  out_x0 <= edge_op_y_net_x0;

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x568,
      clk => clk_1_sg_x568,
      d(0) => msb_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay_q_net
    );

  edge_op: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => inverter_op_net,
      d1(0) => delay_q_net,
      y(0) => edge_op_y_net_x0
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x568,
      clk => clk_1_sg_x568,
      clr => '0',
      ip(0) => msb_y_net_x0,
      op(0) => inverter_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/sync_delay_en"

entity sync_delay_en_entity_e1dd3f1d6c is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    en: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_en_entity_e1dd3f1d6c;

architecture structural of sync_delay_en_entity_e1dd3f1d6c is
  signal ce_1_sg_x569: std_logic;
  signal clk_1_sg_x569: std_logic;
  signal constant1_op_net: std_logic_vector(9 downto 0);
  signal constant2_op_net: std_logic_vector(9 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(9 downto 0);
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal logical1_y_net: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x0: std_logic;
  signal or_y_net_x0: std_logic;
  signal pre_sync_delay_q_net_x0: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x569 <= ce_1;
  clk_1_sg_x569 <= clk_1;
  or_y_net_x0 <= en;
  pre_sync_delay_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x0;

  constant1: entity work.constant_498bc68c14
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_fbc2f0cce1
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_f1ac4bddff
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_d3720c25c3
    port map (
      ce => ce_1_sg_x569,
      clk => clk_1_sg_x569,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical1_y_net,
      load(0) => pre_sync_delay_q_net_x0,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => pre_sync_delay_q_net_x0,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  logical1: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => logical_y_net,
      d1(0) => or_y_net_x0,
      y(0) => logical1_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => pre_sync_delay_q_net_x0,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x0
    );

  relational: entity work.relational_0ffd72e037
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_f6702ea2f7
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder/we_expand"

entity we_expand_entity_84fd4e5b2c is
  port (
    bus_in: in std_logic_vector(1 downto 0); 
    lsb_out1: out std_logic; 
    msb_out2: out std_logic
  );
end we_expand_entity_84fd4e5b2c;

architecture structural of we_expand_entity_84fd4e5b2c is
  signal concatenate_y_net_x0: std_logic_vector(1 downto 0);
  signal slice1_y_net_x3: std_logic;
  signal slice2_y_net_x2: std_logic;

begin
  concatenate_y_net_x0 <= bus_in;
  lsb_out1 <= slice1_y_net_x3;
  msb_out2 <= slice2_y_net_x2;

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice1_y_net_x3
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => concatenate_y_net_x0,
      y(0) => slice2_y_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/reorder"

entity reorder_entity_6cf90680c7 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din0: in std_logic_vector(35 downto 0); 
    din1: in std_logic_vector(35 downto 0); 
    en: in std_logic; 
    sync: in std_logic; 
    dout0: out std_logic_vector(35 downto 0); 
    dout1: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end reorder_entity_6cf90680c7;

architecture structural of reorder_entity_6cf90680c7 is
  signal blank_op_net_x0: std_logic_vector(8 downto 0);
  signal ce_1_sg_x571: std_logic;
  signal clk_1_sg_x571: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(17 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(1 downto 0);
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal daddr0_q_net_x2: std_logic_vector(8 downto 0);
  signal daddr1_q_net_x1: std_logic_vector(8 downto 0);
  signal delay_din0_q_net_x0: std_logic_vector(35 downto 0);
  signal delay_din1_q_net_x0: std_logic_vector(35 downto 0);
  signal delay_we0_q_net: std_logic;
  signal delay_we2_q_net_x0: std_logic;
  signal den_q_net_x1: std_logic;
  signal dly_q_net_x1: std_logic_vector(35 downto 0);
  signal dly_q_net_x2: std_logic;
  signal dmap_src_q_net: std_logic;
  signal dnew_map_q_net_x0: std_logic_vector(8 downto 0);
  signal dsync_q_net: std_logic;
  signal edge_op_y_net_x0: std_logic;
  signal en_op_net_x0: std_logic;
  signal map_mod_data_net: std_logic_vector(8 downto 0);
  signal map_mux_y_net_x0: std_logic_vector(8 downto 0);
  signal map_src_q_net: std_logic;
  signal msb_y_net_x0: std_logic;
  signal mux21_y_net_x0: std_logic_vector(35 downto 0);
  signal mux_y_net_x0: std_logic;
  signal never_op_net_x2: std_logic;
  signal or_y_net_x0: std_logic;
  signal post_sync_delay_q_net_x0: std_logic;
  signal pre_sync_delay_q_net_x0: std_logic;
  signal reinterpret1_output_port_net_x10: std_logic_vector(8 downto 0);
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(8 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(8 downto 0);
  signal slice1_y_net_x3: std_logic;
  signal slice2_y_net_x2: std_logic;

begin
  ce_1_sg_x571 <= ce_1;
  clk_1_sg_x571 <= clk_1;
  dly_q_net_x1 <= din0;
  mux21_y_net_x0 <= din1;
  en_op_net_x0 <= en;
  dly_q_net_x2 <= sync;
  dout0 <= reinterpret1_output_port_net_x11;
  dout1 <= reinterpret1_output_port_net_x12;
  sync_out <= post_sync_delay_q_net_x0;

  addr_expand_c642de21e1: entity work.addr_expand_entity_c642de21e1
    port map (
      bus_in => concatenate_y_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x6,
      msb_out2 => reinterpret2_output_port_net_x2
    );

  addr_replicate_031e932087: entity work.addr_replicate_entity_031e932087
    port map (
      ce_1 => ce_1_sg_x571,
      clk_1 => clk_1_sg_x571,
      in_x0 => map_mux_y_net_x0,
      out_x0 => concatenate_y_net_x2
    );

  blank: entity work.constant_fd85eb7067
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => blank_op_net_x0
    );

  buf0_f7768151e2: entity work.buf0_entity_f7768151e2
    port map (
      addr => reinterpret2_output_port_net_x2,
      ce_1 => ce_1_sg_x571,
      clk_1 => clk_1_sg_x571,
      din => delay_din0_q_net_x0,
      we => slice2_y_net_x2,
      dout => reinterpret1_output_port_net_x11
    );

  buf1_772c6daf83: entity work.buf0_entity_f7768151e2
    port map (
      addr => reinterpret1_output_port_net_x6,
      ce_1 => ce_1_sg_x571,
      clk_1 => clk_1_sg_x571,
      din => delay_din1_q_net_x0,
      we => slice1_y_net_x3,
      dout => reinterpret1_output_port_net_x12
    );

  counter: entity work.counter_eeeda8f61f
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      en(0) => en_op_net_x0,
      rst(0) => dly_q_net_x2,
      op => counter_op_net
    );

  current_map_aff4ba913d: entity work.current_map_entity_aff4ba913d
    port map (
      addra => daddr1_q_net_x1,
      addrb => daddr0_q_net_x2,
      ce_1 => ce_1_sg_x571,
      clk_1 => clk_1_sg_x571,
      dina => dnew_map_q_net_x0,
      dinb => blank_op_net_x0,
      wea => den_q_net_x1,
      web => never_op_net_x2,
      b => reinterpret1_output_port_net_x10
    );

  daddr0: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d => counter_op_net,
      q => daddr0_q_net_x2
    );

  daddr1: entity work.delay_6104cbef7a
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d => daddr0_q_net_x2,
      q => daddr1_q_net_x1
    );

  delay_din0: entity work.delay_7439478232
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d => dly_q_net_x1,
      q => delay_din0_q_net_x0
    );

  delay_din1: entity work.delay_7439478232
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d => mux21_y_net_x0,
      q => delay_din1_q_net_x0
    );

  delay_we0: entity work.delay_a14e3dd1bd
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d(0) => en_op_net_x0,
      q(0) => delay_we0_q_net
    );

  delay_we2: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d(0) => en_op_net_x0,
      q(0) => delay_we2_q_net_x0
    );

  den: entity work.delay_23d71a76f2
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d(0) => en_op_net_x0,
      q(0) => den_q_net_x1
    );

  dmap_src: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d(0) => map_src_q_net,
      q(0) => dmap_src_q_net
    );

  dnew_map: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d => map_mod_data_net,
      q => dnew_map_q_net_x0
    );

  dsync: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d(0) => dly_q_net_x2,
      q(0) => dsync_q_net
    );

  edge_detect_f46b362212: entity work.edge_detect_entity_f46b362212
    port map (
      ce_1 => ce_1_sg_x571,
      clk_1 => clk_1_sg_x571,
      in_x0 => msb_y_net_x0,
      out_x0 => edge_op_y_net_x0
    );

  map_mod: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 9,
      c_width => 9,
      core_name0 => "bmg_72_d5319d7881548c22",
      latency => 1
    )
    port map (
      addr => map_mux_y_net_x0,
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      en => "1",
      rst => "0",
      data => map_mod_data_net
    );

  map_mux: entity work.mux_c839fa4342
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d0 => daddr1_q_net_x1,
      d1 => reinterpret1_output_port_net_x10,
      sel(0) => dmap_src_q_net,
      y => map_mux_y_net_x0
    );

  map_src: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      d(0) => edge_op_y_net_x0,
      en(0) => edge_op_y_net_x0,
      rst(0) => dsync_q_net,
      q(0) => map_src_q_net
    );

  msb: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => msb_y_net_x0
    );

  never: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => never_op_net_x2
    );

  or_x0: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => pre_sync_delay_q_net_x0,
      d1(0) => delay_we0_q_net,
      y(0) => or_y_net_x0
    );

  post_sync_delay: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d(0) => mux_y_net_x0,
      q(0) => post_sync_delay_q_net_x0
    );

  pre_sync_delay: entity work.delay_a14e3dd1bd
    port map (
      ce => ce_1_sg_x571,
      clk => clk_1_sg_x571,
      clr => '0',
      d(0) => dly_q_net_x2,
      q(0) => pre_sync_delay_q_net_x0
    );

  sync_delay_en_e1dd3f1d6c: entity work.sync_delay_en_entity_e1dd3f1d6c
    port map (
      ce_1 => ce_1_sg_x571,
      clk_1 => clk_1_sg_x571,
      en => or_y_net_x0,
      in_x0 => pre_sync_delay_q_net_x0,
      out_x0 => mux_y_net_x0
    );

  we_expand_84fd4e5b2c: entity work.we_expand_entity_84fd4e5b2c
    port map (
      bus_in => concatenate_y_net_x3,
      lsb_out1 => slice1_y_net_x3,
      msb_out2 => slice2_y_net_x2
    );

  we_replicate_d7457fff3f: entity work.sel_replicate_entity_ed643ef8b8
    port map (
      ce_1 => ce_1_sg_x571,
      clk_1 => clk_1_sg_x571,
      in_x0 => delay_we2_q_net_x0,
      out_x0 => concatenate_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/square_transposer/barrel_switcher"

entity barrel_switcher_entity_1ea8fe68bb is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    sel: in std_logic; 
    sync_in: in std_logic; 
    out1: out std_logic_vector(35 downto 0); 
    out2: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end barrel_switcher_entity_1ea8fe68bb;

architecture structural of barrel_switcher_entity_1ea8fe68bb is
  signal ce_1_sg_x572: std_logic;
  signal clk_1_sg_x572: std_logic;
  signal counter_op_net_x0: std_logic;
  signal delay0_q_net_x2: std_logic;
  signal delay_sync_q_net_x0: std_logic;
  signal dly_q_net_x0: std_logic_vector(35 downto 0);
  signal mux11_y_net_x0: std_logic_vector(35 downto 0);
  signal mux21_y_net_x1: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(35 downto 0);
  signal slice1_y_net: std_logic;

begin
  ce_1_sg_x572 <= ce_1;
  clk_1_sg_x572 <= clk_1;
  reinterpret1_output_port_net_x1 <= in1;
  dly_q_net_x0 <= in2;
  counter_op_net_x0 <= sel;
  delay0_q_net_x2 <= sync_in;
  out1 <= mux11_y_net_x0;
  out2 <= mux21_y_net_x1;
  sync_out <= delay_sync_q_net_x0;

  delay_sync: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x572,
      clk => clk_1_sg_x572,
      clr => '0',
      d(0) => delay0_q_net_x2,
      q(0) => delay_sync_q_net_x0
    );

  mux11: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x572,
      clk => clk_1_sg_x572,
      clr => '0',
      d0 => reinterpret1_output_port_net_x1,
      d1 => dly_q_net_x0,
      sel(0) => slice1_y_net,
      y => mux11_y_net_x0
    );

  mux21: entity work.mux_4bb6f691f7
    port map (
      ce => ce_1_sg_x572,
      clk => clk_1_sg_x572,
      clr => '0',
      d0 => dly_q_net_x0,
      d1 => reinterpret1_output_port_net_x1,
      sel(0) => slice1_y_net,
      y => mux21_y_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => counter_op_net_x0,
      y(0) => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/square_transposer/db0"

entity db0_entity_e94fb2d643 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(35 downto 0)
  );
end db0_entity_e94fb2d643;

architecture structural of db0_entity_e94fb2d643 is
  signal ce_1_sg_x573: std_logic;
  signal clk_1_sg_x573: std_logic;
  signal dly_q_net_x2: std_logic_vector(35 downto 0);
  signal mux11_y_net_x1: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x573 <= ce_1;
  clk_1_sg_x573 <= clk_1;
  mux11_y_net_x1 <= din;
  dout <= dly_q_net_x2;

  dly: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x573,
      clk => clk_1_sg_x573,
      clr => '0',
      d => mux11_y_net_x1,
      q => dly_q_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/square_transposer/dsync"

entity dsync_entity_fed58cfed6 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic; 
    dout: out std_logic
  );
end dsync_entity_fed58cfed6;

architecture structural of dsync_entity_fed58cfed6 is
  signal ce_1_sg_x575: std_logic;
  signal clk_1_sg_x575: std_logic;
  signal delay_sync_q_net_x1: std_logic;
  signal dly_q_net_x3: std_logic;

begin
  ce_1_sg_x575 <= ce_1;
  clk_1_sg_x575 <= clk_1;
  delay_sync_q_net_x1 <= din;
  dout <= dly_q_net_x3;

  dly: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x575,
      clk => clk_1_sg_x575,
      clr => '0',
      d(0) => delay_sync_q_net_x1,
      q(0) => dly_q_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler/square_transposer"

entity square_transposer_entity_ea01da2bde is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in0: in std_logic_vector(35 downto 0); 
    in1: in std_logic_vector(35 downto 0); 
    sync: in std_logic; 
    out0: out std_logic_vector(35 downto 0); 
    out1: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end square_transposer_entity_ea01da2bde;

architecture structural of square_transposer_entity_ea01da2bde is
  signal ce_1_sg_x576: std_logic;
  signal clk_1_sg_x576: std_logic;
  signal counter_op_net_x0: std_logic;
  signal delay0_q_net_x3: std_logic;
  signal delay_sync_q_net_x1: std_logic;
  signal dly_q_net_x1: std_logic_vector(35 downto 0);
  signal dly_q_net_x4: std_logic_vector(35 downto 0);
  signal dly_q_net_x5: std_logic;
  signal mux11_y_net_x1: std_logic_vector(35 downto 0);
  signal mux21_y_net_x2: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x576 <= ce_1;
  clk_1_sg_x576 <= clk_1;
  reinterpret1_output_port_net_x3 <= in0;
  reinterpret1_output_port_net_x4 <= in1;
  delay0_q_net_x3 <= sync;
  out0 <= dly_q_net_x4;
  out1 <= mux21_y_net_x2;
  sync_out <= dly_q_net_x5;

  barrel_switcher_1ea8fe68bb: entity work.barrel_switcher_entity_1ea8fe68bb
    port map (
      ce_1 => ce_1_sg_x576,
      clk_1 => clk_1_sg_x576,
      in1 => reinterpret1_output_port_net_x3,
      in2 => dly_q_net_x1,
      sel => counter_op_net_x0,
      sync_in => delay0_q_net_x3,
      out1 => mux11_y_net_x1,
      out2 => mux21_y_net_x2,
      sync_out => delay_sync_q_net_x1
    );

  counter: entity work.counter_9f61b180a8
    port map (
      ce => ce_1_sg_x576,
      clk => clk_1_sg_x576,
      clr => '0',
      rst(0) => delay0_q_net_x3,
      op(0) => counter_op_net_x0
    );

  db0_e94fb2d643: entity work.db0_entity_e94fb2d643
    port map (
      ce_1 => ce_1_sg_x576,
      clk_1 => clk_1_sg_x576,
      din => mux11_y_net_x1,
      dout => dly_q_net_x4
    );

  df1_ef08067f5b: entity work.db0_entity_e94fb2d643
    port map (
      ce_1 => ce_1_sg_x576,
      clk_1 => clk_1_sg_x576,
      din => reinterpret1_output_port_net_x4,
      dout => dly_q_net_x1
    );

  dsync_fed58cfed6: entity work.dsync_entity_fed58cfed6
    port map (
      ce_1 => ce_1_sg_x576,
      clk_1 => clk_1_sg_x576,
      din => delay_sync_q_net_x1,
      dout => dly_q_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1/fft_unscrambler"

entity fft_unscrambler_entity_6e62eedbc0 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in00: in std_logic_vector(35 downto 0); 
    in01: in std_logic_vector(35 downto 0); 
    sync: in std_logic; 
    out00: out std_logic_vector(35 downto 0); 
    out01: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_unscrambler_entity_6e62eedbc0;

architecture structural of fft_unscrambler_entity_6e62eedbc0 is
  signal ce_1_sg_x577: std_logic;
  signal clk_1_sg_x577: std_logic;
  signal delay0_q_net_x4: std_logic;
  signal dly_q_net_x4: std_logic_vector(35 downto 0);
  signal dly_q_net_x5: std_logic;
  signal en_op_net_x0: std_logic;
  signal mux21_y_net_x2: std_logic_vector(35 downto 0);
  signal post_sync_delay_q_net_x1: std_logic;
  signal reinterpret1_output_port_net_x11: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x12: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x21: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x22: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x23: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x6: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x577 <= ce_1;
  clk_1_sg_x577 <= clk_1;
  reinterpret1_output_port_net_x21 <= in00;
  reinterpret1_output_port_net_x22 <= in01;
  delay0_q_net_x4 <= sync;
  out00 <= reinterpret1_output_port_net_x6;
  out01 <= reinterpret1_output_port_net_x23;
  sync_out <= post_sync_delay_q_net_x1;

  bus0_e3bf7ff921: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => reinterpret1_output_port_net_x21,
      bus_out => reinterpret1_output_port_net_x3
    );

  bus1_0bfc58e535: entity work.d_bussify_entity_02f24549a3
    port map (
      in1 => reinterpret1_output_port_net_x22,
      bus_out => reinterpret1_output_port_net_x4
    );

  debus0_a39b186f28: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret1_output_port_net_x11,
      msb_lsb_out1 => reinterpret1_output_port_net_x6
    );

  debus1_57db135cf0: entity work.expand0_entity_4f272c7f41
    port map (
      bus_in => reinterpret1_output_port_net_x12,
      msb_lsb_out1 => reinterpret1_output_port_net_x23
    );

  en: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => en_op_net_x0
    );

  reorder_6cf90680c7: entity work.reorder_entity_6cf90680c7
    port map (
      ce_1 => ce_1_sg_x577,
      clk_1 => clk_1_sg_x577,
      din0 => dly_q_net_x4,
      din1 => mux21_y_net_x2,
      en => en_op_net_x0,
      sync => dly_q_net_x5,
      dout0 => reinterpret1_output_port_net_x11,
      dout1 => reinterpret1_output_port_net_x12,
      sync_out => post_sync_delay_q_net_x1
    );

  square_transposer_ea01da2bde: entity work.square_transposer_entity_ea01da2bde
    port map (
      ce_1 => ce_1_sg_x577,
      clk_1 => clk_1_sg_x577,
      in0 => reinterpret1_output_port_net_x3,
      in1 => reinterpret1_output_port_net_x4,
      sync => delay0_q_net_x4,
      out0 => dly_q_net_x4,
      out1 => mux21_y_net_x2,
      sync_out => dly_q_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/fft_wideband_real1"

entity fft_wideband_real1_entity_41856fd605 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in00: in std_logic_vector(17 downto 0); 
    in01: in std_logic_vector(17 downto 0); 
    in02: in std_logic_vector(17 downto 0); 
    in03: in std_logic_vector(17 downto 0); 
    shift: in std_logic_vector(10 downto 0); 
    sync: in std_logic; 
    out00: out std_logic_vector(35 downto 0); 
    out01: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end fft_wideband_real1_entity_41856fd605;

architecture structural of fft_wideband_real1_entity_41856fd605 is
  signal ce_1_sg_x578: std_logic;
  signal clk_1_sg_x578: std_logic;
  signal delay0_q_net_x4: std_logic;
  signal delay10_q_net_x3: std_logic;
  signal delay11_q_net_x11: std_logic_vector(10 downto 0);
  signal delay16_q_net_x2: std_logic_vector(17 downto 0);
  signal delay17_q_net_x2: std_logic_vector(17 downto 0);
  signal delay18_q_net_x2: std_logic_vector(17 downto 0);
  signal delay19_q_net_x2: std_logic_vector(17 downto 0);
  signal post_sync_delay_q_net_x2: std_logic;
  signal reinterpret1_output_port_net_x14: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x15: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x16: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x17: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x21: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x22: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x24: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x25: std_logic_vector(35 downto 0);
  signal slice_y_net_x0: std_logic_vector(1 downto 0);
  signal sync_delay1_q_net_x8: std_logic;

begin
  ce_1_sg_x578 <= ce_1;
  clk_1_sg_x578 <= clk_1;
  delay16_q_net_x2 <= in00;
  delay17_q_net_x2 <= in01;
  delay18_q_net_x2 <= in02;
  delay19_q_net_x2 <= in03;
  delay11_q_net_x11 <= shift;
  delay10_q_net_x3 <= sync;
  out00 <= reinterpret1_output_port_net_x24;
  out01 <= reinterpret1_output_port_net_x25;
  sync_out <= post_sync_delay_q_net_x2;

  fft_biplex_real_4x_a1cfde3192: entity work.fft_biplex_real_4x_entity_a1cfde3192
    port map (
      ce_1 => ce_1_sg_x578,
      clk_1 => clk_1_sg_x578,
      pol0_in => delay16_q_net_x2,
      pol1_in => delay17_q_net_x2,
      pol2_in => delay18_q_net_x2,
      pol3_in => delay19_q_net_x2,
      shift => delay11_q_net_x11,
      sync => delay10_q_net_x3,
      pol0_out => reinterpret1_output_port_net_x14,
      pol1_out => reinterpret1_output_port_net_x15,
      pol2_out => reinterpret1_output_port_net_x16,
      pol3_out => reinterpret1_output_port_net_x17,
      sync_out => sync_delay1_q_net_x8
    );

  fft_direct_bb6d489f82: entity work.fft_direct_entity_bb6d489f82
    port map (
      ce_1 => ce_1_sg_x578,
      clk_1 => clk_1_sg_x578,
      in00 => reinterpret1_output_port_net_x14,
      in01 => reinterpret1_output_port_net_x15,
      in02 => reinterpret1_output_port_net_x16,
      in03 => reinterpret1_output_port_net_x17,
      shift => slice_y_net_x0,
      sync => sync_delay1_q_net_x8,
      out00 => reinterpret1_output_port_net_x21,
      out01 => reinterpret1_output_port_net_x22,
      sync_out => delay0_q_net_x4
    );

  fft_unscrambler_6e62eedbc0: entity work.fft_unscrambler_entity_6e62eedbc0
    port map (
      ce_1 => ce_1_sg_x578,
      clk_1 => clk_1_sg_x578,
      in00 => reinterpret1_output_port_net_x21,
      in01 => reinterpret1_output_port_net_x22,
      sync => delay0_q_net_x4,
      out00 => reinterpret1_output_port_net_x24,
      out01 => reinterpret1_output_port_net_x25,
      sync_out => post_sync_delay_q_net_x2
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 9,
      new_msb => 10,
      x_width => 11,
      y_width => 2
    )
    port map (
      x => delay11_q_net_x11,
      y => slice_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/mixer_cnt"

entity mixer_cnt_entity_cb8600b24e is
  port (
    window_and_fft_test_v4_mixer_cnt_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end mixer_cnt_entity_cb8600b24e;

architecture structural of mixer_cnt_entity_cb8600b24e is
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_mixer_cnt_user_data_out_net_x0: std_logic_vector(31 downto 0);

begin
  window_and_fft_test_v4_mixer_cnt_user_data_out_net_x0 <= window_and_fft_test_v4_mixer_cnt_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => window_and_fft_test_v4_mixer_cnt_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/adder_1_1"

entity adder_1_1_entity_e699198897 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din1: in std_logic_vector(35 downto 0); 
    din2: in std_logic_vector(35 downto 0); 
    din3: in std_logic_vector(35 downto 0); 
    din4: in std_logic_vector(35 downto 0); 
    sync: in std_logic; 
    dout: out std_logic_vector(25 downto 0); 
    sync_out: out std_logic
  );
end adder_1_1_entity_e699198897;

architecture structural of adder_1_1_entity_e699198897 is
  signal addr1_s_net: std_logic_vector(25 downto 0);
  signal addr2_s_net: std_logic_vector(25 downto 0);
  signal addr3_s_net_x0: std_logic_vector(25 downto 0);
  signal ce_1_sg_x581: std_logic;
  signal clk_1_sg_x581: std_logic;
  signal delay_q_net_x0: std_logic;
  signal mult_p_net_x3: std_logic_vector(35 downto 0);
  signal mult_p_net_x4: std_logic_vector(35 downto 0);
  signal mult_p_net_x5: std_logic_vector(35 downto 0);
  signal mult_p_net_x6: std_logic_vector(35 downto 0);
  signal sync_delay_q_net_x0: std_logic;

begin
  ce_1_sg_x581 <= ce_1;
  clk_1_sg_x581 <= clk_1;
  mult_p_net_x3 <= din1;
  mult_p_net_x5 <= din2;
  mult_p_net_x6 <= din3;
  mult_p_net_x4 <= din4;
  delay_q_net_x0 <= sync;
  dout <= addr3_s_net_x0;
  sync_out <= sync_delay_q_net_x0;

  addr1: entity work.addsub_65704f220d
    port map (
      a => mult_p_net_x3,
      b => mult_p_net_x5,
      ce => ce_1_sg_x581,
      clk => clk_1_sg_x581,
      clr => '0',
      s => addr1_s_net
    );

  addr2: entity work.addsub_65704f220d
    port map (
      a => mult_p_net_x6,
      b => mult_p_net_x4,
      ce => ce_1_sg_x581,
      clk => clk_1_sg_x581,
      clr => '0',
      s => addr2_s_net
    );

  addr3: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 24,
      a_width => 26,
      b_arith => xlSigned,
      b_bin_pt => 24,
      b_width => 26,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 27,
      core_name0 => "addsb_11_0_325ab3980d59a98e",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 27,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 24,
      s_width => 26
    )
    port map (
      a => addr1_s_net,
      b => addr2_s_net,
      ce => ce_1_sg_x581,
      clk => clk_1_sg_x581,
      clr => '0',
      en => "1",
      s => addr3_s_net_x0
    );

  sync_delay: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x581,
      clk => clk_1_sg_x581,
      clr => '0',
      d(0) => delay_q_net_x0,
      q(0) => sync_delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/adder_1_2"

entity adder_1_2_entity_3e607ccf9a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din1: in std_logic_vector(35 downto 0); 
    din2: in std_logic_vector(35 downto 0); 
    din3: in std_logic_vector(35 downto 0); 
    din4: in std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(25 downto 0)
  );
end adder_1_2_entity_3e607ccf9a;

architecture structural of adder_1_2_entity_3e607ccf9a is
  signal addr1_s_net: std_logic_vector(25 downto 0);
  signal addr2_s_net: std_logic_vector(25 downto 0);
  signal addr3_s_net_x0: std_logic_vector(25 downto 0);
  signal ce_1_sg_x582: std_logic;
  signal clk_1_sg_x582: std_logic;
  signal mult_p_net_x3: std_logic_vector(35 downto 0);
  signal mult_p_net_x4: std_logic_vector(35 downto 0);
  signal mult_p_net_x5: std_logic_vector(35 downto 0);
  signal mult_p_net_x6: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x582 <= ce_1;
  clk_1_sg_x582 <= clk_1;
  mult_p_net_x3 <= din1;
  mult_p_net_x5 <= din2;
  mult_p_net_x6 <= din3;
  mult_p_net_x4 <= din4;
  dout <= addr3_s_net_x0;

  addr1: entity work.addsub_65704f220d
    port map (
      a => mult_p_net_x3,
      b => mult_p_net_x5,
      ce => ce_1_sg_x582,
      clk => clk_1_sg_x582,
      clr => '0',
      s => addr1_s_net
    );

  addr2: entity work.addsub_65704f220d
    port map (
      a => mult_p_net_x6,
      b => mult_p_net_x4,
      ce => ce_1_sg_x582,
      clk => clk_1_sg_x582,
      clr => '0',
      s => addr2_s_net
    );

  addr3: entity work.xladdsub_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 24,
      a_width => 26,
      b_arith => xlSigned,
      b_bin_pt => 24,
      b_width => 26,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 27,
      core_name0 => "addsb_11_0_325ab3980d59a98e",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 27,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 24,
      s_width => 26
    )
    port map (
      a => addr1_s_net,
      b => addr2_s_net,
      ce => ce_1_sg_x582,
      clk => clk_1_sg_x582,
      clr => '0',
      en => "1",
      s => addr3_s_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in1_coeffs"

entity pol1_in1_coeffs_entity_ad249aca95 is
  port (
    ce_1: in std_logic; 
    ce_2500: in std_logic; 
    clk_1: in std_logic; 
    clk_2500: in std_logic; 
    din: in std_logic_vector(17 downto 0); 
    sync: in std_logic; 
    coeff: out std_logic_vector(71 downto 0); 
    dout: out std_logic_vector(17 downto 0); 
    sync_out: out std_logic
  );
end pol1_in1_coeffs_entity_ad249aca95;

architecture structural of pol1_in1_coeffs_entity_ad249aca95 is
  signal ce_1_sg_x585: std_logic;
  signal ce_2500_sg_x4: std_logic;
  signal clk_1_sg_x585: std_logic;
  signal clk_2500_sg_x4: std_logic;
  signal concat_y_net: std_logic_vector(71 downto 0);
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal delay1_q_net_x0: std_logic_vector(17 downto 0);
  signal delay4_q_net_x0: std_logic_vector(17 downto 0);
  signal delay8_q_net_x0: std_logic;
  signal delay_q_net_x0: std_logic;
  signal fan_delay1_q_net: std_logic_vector(9 downto 0);
  signal fan_delay2_q_net: std_logic_vector(9 downto 0);
  signal fan_delay3_q_net: std_logic_vector(9 downto 0);
  signal fan_delay4_q_net: std_logic_vector(9 downto 0);
  signal register_q_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(17 downto 0);
  signal rom1_data_net: std_logic_vector(17 downto 0);
  signal rom2_data_net: std_logic_vector(17 downto 0);
  signal rom3_data_net: std_logic_vector(17 downto 0);
  signal rom4_data_net: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x585 <= ce_1;
  ce_2500_sg_x4 <= ce_2500;
  clk_1_sg_x585 <= clk_1;
  clk_2500_sg_x4 <= clk_2500;
  delay4_q_net_x0 <= din;
  delay8_q_net_x0 <= sync;
  coeff <= register_q_net_x0;
  dout <= delay1_q_net_x0;
  sync_out <= delay_q_net_x0;

  concat: entity work.concat_a246e373e7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concat_y_net
    );

  counter: entity work.xlcounter_free_window_and_fft_test_v4
    generic map (
      core_name0 => "cntr_11_0_5c0d8fded7f0a054",
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x585,
      clk => clk_1_sg_x585,
      clr => '0',
      en => "1",
      rst(0) => delay8_q_net_x0,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x585,
      clk => clk_1_sg_x585,
      d(0) => delay8_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay_q_net_x0
    );

  delay1: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_2500_sg_x4,
      clk => clk_2500_sg_x4,
      d => delay4_q_net_x0,
      en => '1',
      rst => '1',
      q => delay1_q_net_x0
    );

  fan_delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x585,
      clk => clk_1_sg_x585,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay1_q_net
    );

  fan_delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x585,
      clk => clk_1_sg_x585,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay2_q_net
    );

  fan_delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x585,
      clk => clk_1_sg_x585,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay3_q_net
    );

  fan_delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x585,
      clk => clk_1_sg_x585,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay4_q_net
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 72,
      init_value => b"000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x585,
      clk => clk_1_sg_x585,
      d => concat_y_net,
      en => "1",
      rst => "0",
      q => register_q_net_x0
    );

  reinterpret1: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom1_data_net,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom2_data_net,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom3_data_net,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom4_data_net,
      output_port => reinterpret4_output_port_net
    );

  rom1: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_b7d413d71af73706",
      latency => 1
    )
    port map (
      addr => fan_delay1_q_net,
      ce => ce_1_sg_x585,
      clk => clk_1_sg_x585,
      en => "1",
      rst => "0",
      data => rom1_data_net
    );

  rom2: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_fba27241bcd4df38",
      latency => 1
    )
    port map (
      addr => fan_delay2_q_net,
      ce => ce_1_sg_x585,
      clk => clk_1_sg_x585,
      en => "1",
      rst => "0",
      data => rom2_data_net
    );

  rom3: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_5d708e36ddb23a80",
      latency => 1
    )
    port map (
      addr => fan_delay3_q_net,
      ce => ce_1_sg_x585,
      clk => clk_1_sg_x585,
      en => "1",
      rst => "0",
      data => rom3_data_net
    );

  rom4: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_146e01525f281df8",
      latency => 1
    )
    port map (
      addr => fan_delay4_q_net,
      ce => ce_1_sg_x585,
      clk => clk_1_sg_x585,
      en => "1",
      rst => "0",
      data => rom4_data_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in1_first_tap/delay_bram"

entity delay_bram_entity_14d0e85ca6 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(17 downto 0); 
    dout: out std_logic_vector(17 downto 0)
  );
end delay_bram_entity_14d0e85ca6;

architecture structural of delay_bram_entity_14d0e85ca6 is
  signal ce_1_sg_x586: std_logic;
  signal clk_1_sg_x586: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal delay1_q_net_x1: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x586 <= ce_1;
  clk_1_sg_x586 <= clk_1;
  delay1_q_net_x1 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.counter_9c042fac90
    port map (
      ce => ce_1_sg_x586,
      clk => clk_1_sg_x586,
      clr => '0',
      op => counter_op_net
    );

  ram: entity work.xlspram_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_25cb9ebb8094dade",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x586,
      clk => clk_1_sg_x586,
      data_in => delay1_q_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in1_first_tap/sync_delay"

entity sync_delay_entity_44e5b7c4aa is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end sync_delay_entity_44e5b7c4aa;

architecture structural of sync_delay_entity_44e5b7c4aa is
  signal ce_1_sg_x587: std_logic;
  signal clk_1_sg_x587: std_logic;
  signal constant1_op_net: std_logic_vector(10 downto 0);
  signal constant2_op_net: std_logic_vector(10 downto 0);
  signal constant3_op_net: std_logic;
  signal constant_op_net: std_logic_vector(10 downto 0);
  signal counter_op_net: std_logic_vector(10 downto 0);
  signal delay_q_net_x1: std_logic;
  signal logical_y_net: std_logic;
  signal mux_y_net_x0: std_logic;
  signal relational1_op_net: std_logic;
  signal relational_op_net: std_logic;

begin
  ce_1_sg_x587 <= ce_1;
  clk_1_sg_x587 <= clk_1;
  delay_q_net_x1 <= in_x0;
  out_x0 <= mux_y_net_x0;

  constant1: entity work.constant_a3923dd146
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_0604807f72
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant_x0: entity work.constant_118598964d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  counter: entity work.counter_b5e433c475
    port map (
      ce => ce_1_sg_x587,
      clk => clk_1_sg_x587,
      clr => '0',
      din => constant2_op_net,
      en(0) => logical_y_net,
      load(0) => delay_q_net_x1,
      op => counter_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay_q_net_x1,
      d1(0) => relational1_op_net,
      y(0) => logical_y_net
    );

  mux: entity work.mux_1bef4ba0e4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay_q_net_x1,
      d1(0) => relational_op_net,
      sel(0) => constant3_op_net,
      y(0) => mux_y_net_x0
    );

  relational: entity work.relational_2147430058
    port map (
      a => constant_op_net,
      b => counter_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_b4b277ae0f
    port map (
      a => counter_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in1_first_tap"

entity pol1_in1_first_tap_entity_68007830ab is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    coeffs: in std_logic_vector(71 downto 0); 
    din: in std_logic_vector(17 downto 0); 
    sync: in std_logic; 
    coeff_out: out std_logic_vector(53 downto 0); 
    dout: out std_logic_vector(17 downto 0); 
    sync_out: out std_logic; 
    taps_out: out std_logic_vector(35 downto 0)
  );
end pol1_in1_first_tap_entity_68007830ab;

architecture structural of pol1_in1_first_tap_entity_68007830ab is
  signal ce_1_sg_x588: std_logic;
  signal clk_1_sg_x588: std_logic;
  signal delay1_q_net_x2: std_logic_vector(17 downto 0);
  signal delay_q_net_x2: std_logic;
  signal mult_p_net_x4: std_logic_vector(35 downto 0);
  signal mux_y_net_x1: std_logic;
  signal ram_data_out_net_x1: std_logic_vector(17 downto 0);
  signal register_q_net_x1: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(17 downto 0);
  signal slice1_y_net_x0: std_logic_vector(53 downto 0);
  signal slice_y_net: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x588 <= ce_1;
  clk_1_sg_x588 <= clk_1;
  register_q_net_x1 <= coeffs;
  delay1_q_net_x2 <= din;
  delay_q_net_x2 <= sync;
  coeff_out <= slice1_y_net_x0;
  dout <= ram_data_out_net_x1;
  sync_out <= mux_y_net_x1;
  taps_out <= mult_p_net_x4;

  delay_bram_14d0e85ca6: entity work.delay_bram_entity_14d0e85ca6
    port map (
      ce_1 => ce_1_sg_x588,
      clk_1 => clk_1_sg_x588,
      din => delay1_q_net_x2,
      dout => ram_data_out_net_x1
    );

  mult: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret2_output_port_net,
      b => reinterpret_output_port_net,
      ce => ce_1_sg_x588,
      clk => clk_1_sg_x588,
      clr => '0',
      p => mult_p_net_x4
    );

  reinterpret: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_y_net,
      output_port => reinterpret_output_port_net
    );

  reinterpret2: entity work.reinterpret_120751dc4b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay1_q_net_x2,
      output_port => reinterpret2_output_port_net
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => register_q_net_x1,
      y => slice_y_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 71,
      x_width => 72,
      y_width => 54
    )
    port map (
      x => register_q_net_x1,
      y => slice1_y_net_x0
    );

  sync_delay_44e5b7c4aa: entity work.sync_delay_entity_44e5b7c4aa
    port map (
      ce_1 => ce_1_sg_x588,
      clk_1 => clk_1_sg_x588,
      in_x0 => delay_q_net_x2,
      out_x0 => mux_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in1_last_tap"

entity pol1_in1_last_tap_entity_052c470427 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    coeff: in std_logic_vector(17 downto 0); 
    din: in std_logic_vector(17 downto 0); 
    sync: in std_logic; 
    sync_out: out std_logic; 
    tap_out: out std_logic_vector(35 downto 0)
  );
end pol1_in1_last_tap_entity_052c470427;

architecture structural of pol1_in1_last_tap_entity_052c470427 is
  signal ce_1_sg_x589: std_logic;
  signal clk_1_sg_x589: std_logic;
  signal delay_q_net_x1: std_logic;
  signal mult_p_net_x5: std_logic_vector(35 downto 0);
  signal mux_y_net_x0: std_logic;
  signal ram_data_out_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(17 downto 0);
  signal slice1_y_net_x0: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x589 <= ce_1;
  clk_1_sg_x589 <= clk_1;
  slice1_y_net_x0 <= coeff;
  ram_data_out_net_x0 <= din;
  mux_y_net_x0 <= sync;
  sync_out <= delay_q_net_x1;
  tap_out <= mult_p_net_x5;

  delay: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x589,
      clk => clk_1_sg_x589,
      clr => '0',
      d(0) => mux_y_net_x0,
      q(0) => delay_q_net_x1
    );

  mult: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret1_output_port_net,
      b => reinterpret_output_port_net,
      ce => ce_1_sg_x589,
      clk => clk_1_sg_x589,
      clr => '0',
      p => mult_p_net_x5
    );

  reinterpret: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net_x0,
      output_port => reinterpret_output_port_net
    );

  reinterpret1: entity work.reinterpret_120751dc4b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_data_out_net_x0,
      output_port => reinterpret1_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in1_tap2"

entity pol1_in1_tap2_entity_7dc3d635c1 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    coeff: in std_logic_vector(53 downto 0); 
    din: in std_logic_vector(17 downto 0); 
    sync: in std_logic; 
    coeff_out: out std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(17 downto 0); 
    sync_out: out std_logic; 
    taps_out: out std_logic_vector(35 downto 0)
  );
end pol1_in1_tap2_entity_7dc3d635c1;

architecture structural of pol1_in1_tap2_entity_7dc3d635c1 is
  signal ce_1_sg_x592: std_logic;
  signal clk_1_sg_x592: std_logic;
  signal mult_p_net_x6: std_logic_vector(35 downto 0);
  signal mux_y_net_x3: std_logic;
  signal mux_y_net_x4: std_logic;
  signal ram_data_out_net_x3: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x4: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(17 downto 0);
  signal slice1_y_net_x1: std_logic_vector(53 downto 0);
  signal slice1_y_net_x2: std_logic_vector(35 downto 0);
  signal slice_y_net: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x592 <= ce_1;
  clk_1_sg_x592 <= clk_1;
  slice1_y_net_x1 <= coeff;
  ram_data_out_net_x3 <= din;
  mux_y_net_x3 <= sync;
  coeff_out <= slice1_y_net_x2;
  dout <= ram_data_out_net_x4;
  sync_out <= mux_y_net_x4;
  taps_out <= mult_p_net_x6;

  delay_bram_70cae5a35b: entity work.delay_bram_entity_14d0e85ca6
    port map (
      ce_1 => ce_1_sg_x592,
      clk_1 => clk_1_sg_x592,
      din => ram_data_out_net_x3,
      dout => ram_data_out_net_x4
    );

  mult: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret1_output_port_net,
      b => reinterpret_output_port_net,
      ce => ce_1_sg_x592,
      clk => clk_1_sg_x592,
      clr => '0',
      p => mult_p_net_x6
    );

  reinterpret: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_y_net,
      output_port => reinterpret_output_port_net
    );

  reinterpret1: entity work.reinterpret_120751dc4b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_data_out_net_x3,
      output_port => reinterpret1_output_port_net
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 54,
      y_width => 18
    )
    port map (
      x => slice1_y_net_x1,
      y => slice_y_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 53,
      x_width => 54,
      y_width => 36
    )
    port map (
      x => slice1_y_net_x1,
      y => slice1_y_net_x2
    );

  sync_delay_c27713c354: entity work.sync_delay_entity_44e5b7c4aa
    port map (
      ce_1 => ce_1_sg_x592,
      clk_1 => clk_1_sg_x592,
      in_x0 => mux_y_net_x3,
      out_x0 => mux_y_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in1_tap3"

entity pol1_in1_tap3_entity_81eacbfb0d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    coeff: in std_logic_vector(35 downto 0); 
    din: in std_logic_vector(17 downto 0); 
    sync: in std_logic; 
    coeff_out: out std_logic_vector(17 downto 0); 
    dout: out std_logic_vector(17 downto 0); 
    sync_out: out std_logic; 
    taps_out: out std_logic_vector(35 downto 0)
  );
end pol1_in1_tap3_entity_81eacbfb0d;

architecture structural of pol1_in1_tap3_entity_81eacbfb0d is
  signal ce_1_sg_x595: std_logic;
  signal clk_1_sg_x595: std_logic;
  signal mult_p_net_x7: std_logic_vector(35 downto 0);
  signal mux_y_net_x2: std_logic;
  signal mux_y_net_x6: std_logic;
  signal ram_data_out_net_x2: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x6: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(17 downto 0);
  signal slice1_y_net_x3: std_logic_vector(35 downto 0);
  signal slice1_y_net_x4: std_logic_vector(17 downto 0);
  signal slice_y_net: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x595 <= ce_1;
  clk_1_sg_x595 <= clk_1;
  slice1_y_net_x3 <= coeff;
  ram_data_out_net_x6 <= din;
  mux_y_net_x6 <= sync;
  coeff_out <= slice1_y_net_x4;
  dout <= ram_data_out_net_x2;
  sync_out <= mux_y_net_x2;
  taps_out <= mult_p_net_x7;

  delay_bram_86af2ea276: entity work.delay_bram_entity_14d0e85ca6
    port map (
      ce_1 => ce_1_sg_x595,
      clk_1 => clk_1_sg_x595,
      din => ram_data_out_net_x6,
      dout => ram_data_out_net_x2
    );

  mult: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret1_output_port_net,
      b => reinterpret_output_port_net,
      ce => ce_1_sg_x595,
      clk => clk_1_sg_x595,
      clr => '0',
      p => mult_p_net_x7
    );

  reinterpret: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_y_net,
      output_port => reinterpret_output_port_net
    );

  reinterpret1: entity work.reinterpret_120751dc4b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_data_out_net_x6,
      output_port => reinterpret1_output_port_net
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => slice1_y_net_x3,
      y => slice_y_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 35,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => slice1_y_net_x3,
      y => slice1_y_net_x4
    );

  sync_delay_c2d7b3ee94: entity work.sync_delay_entity_44e5b7c4aa
    port map (
      ce_1 => ce_1_sg_x595,
      clk_1 => clk_1_sg_x595,
      in_x0 => mux_y_net_x6,
      out_x0 => mux_y_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in2_coeffs"

entity pol1_in2_coeffs_entity_9c1b410463 is
  port (
    ce_1: in std_logic; 
    ce_2500: in std_logic; 
    clk_1: in std_logic; 
    clk_2500: in std_logic; 
    din: in std_logic_vector(17 downto 0); 
    sync: in std_logic; 
    coeff: out std_logic_vector(71 downto 0); 
    dout: out std_logic_vector(17 downto 0)
  );
end pol1_in2_coeffs_entity_9c1b410463;

architecture structural of pol1_in2_coeffs_entity_9c1b410463 is
  signal ce_1_sg_x596: std_logic;
  signal ce_2500_sg_x5: std_logic;
  signal clk_1_sg_x596: std_logic;
  signal clk_2500_sg_x5: std_logic;
  signal concat_y_net: std_logic_vector(71 downto 0);
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal delay1_q_net_x0: std_logic_vector(17 downto 0);
  signal delay6_q_net_x0: std_logic_vector(17 downto 0);
  signal delay8_q_net_x1: std_logic;
  signal fan_delay1_q_net: std_logic_vector(9 downto 0);
  signal fan_delay2_q_net: std_logic_vector(9 downto 0);
  signal fan_delay3_q_net: std_logic_vector(9 downto 0);
  signal fan_delay4_q_net: std_logic_vector(9 downto 0);
  signal register_q_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(17 downto 0);
  signal rom1_data_net: std_logic_vector(17 downto 0);
  signal rom2_data_net: std_logic_vector(17 downto 0);
  signal rom3_data_net: std_logic_vector(17 downto 0);
  signal rom4_data_net: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x596 <= ce_1;
  ce_2500_sg_x5 <= ce_2500;
  clk_1_sg_x596 <= clk_1;
  clk_2500_sg_x5 <= clk_2500;
  delay6_q_net_x0 <= din;
  delay8_q_net_x1 <= sync;
  coeff <= register_q_net_x0;
  dout <= delay1_q_net_x0;

  concat: entity work.concat_a246e373e7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concat_y_net
    );

  counter: entity work.xlcounter_free_window_and_fft_test_v4
    generic map (
      core_name0 => "cntr_11_0_5c0d8fded7f0a054",
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x596,
      clk => clk_1_sg_x596,
      clr => '0',
      en => "1",
      rst(0) => delay8_q_net_x1,
      op => counter_op_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_2500_sg_x5,
      clk => clk_2500_sg_x5,
      d => delay6_q_net_x0,
      en => '1',
      rst => '1',
      q => delay1_q_net_x0
    );

  fan_delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x596,
      clk => clk_1_sg_x596,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay1_q_net
    );

  fan_delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x596,
      clk => clk_1_sg_x596,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay2_q_net
    );

  fan_delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x596,
      clk => clk_1_sg_x596,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay3_q_net
    );

  fan_delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x596,
      clk => clk_1_sg_x596,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay4_q_net
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 72,
      init_value => b"000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x596,
      clk => clk_1_sg_x596,
      d => concat_y_net,
      en => "1",
      rst => "0",
      q => register_q_net_x0
    );

  reinterpret1: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom1_data_net,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom2_data_net,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom3_data_net,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom4_data_net,
      output_port => reinterpret4_output_port_net
    );

  rom1: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_e9a0d6c7631bff5b",
      latency => 1
    )
    port map (
      addr => fan_delay1_q_net,
      ce => ce_1_sg_x596,
      clk => clk_1_sg_x596,
      en => "1",
      rst => "0",
      data => rom1_data_net
    );

  rom2: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_ed1b80fcdf1c3a46",
      latency => 1
    )
    port map (
      addr => fan_delay2_q_net,
      ce => ce_1_sg_x596,
      clk => clk_1_sg_x596,
      en => "1",
      rst => "0",
      data => rom2_data_net
    );

  rom3: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_f77670697183b527",
      latency => 1
    )
    port map (
      addr => fan_delay3_q_net,
      ce => ce_1_sg_x596,
      clk => clk_1_sg_x596,
      en => "1",
      rst => "0",
      data => rom3_data_net
    );

  rom4: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_51873a049072c953",
      latency => 1
    )
    port map (
      addr => fan_delay4_q_net,
      ce => ce_1_sg_x596,
      clk => clk_1_sg_x596,
      en => "1",
      rst => "0",
      data => rom4_data_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in2_first_tap"

entity pol1_in2_first_tap_entity_b598ad2e00 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    coeffs: in std_logic_vector(71 downto 0); 
    din: in std_logic_vector(17 downto 0); 
    coeff_out: out std_logic_vector(53 downto 0); 
    dout: out std_logic_vector(17 downto 0); 
    taps_out: out std_logic_vector(35 downto 0)
  );
end pol1_in2_first_tap_entity_b598ad2e00;

architecture structural of pol1_in2_first_tap_entity_b598ad2e00 is
  signal ce_1_sg_x598: std_logic;
  signal clk_1_sg_x598: std_logic;
  signal delay1_q_net_x2: std_logic_vector(17 downto 0);
  signal mult_p_net_x4: std_logic_vector(35 downto 0);
  signal ram_data_out_net_x1: std_logic_vector(17 downto 0);
  signal register_q_net_x1: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(17 downto 0);
  signal slice1_y_net_x0: std_logic_vector(53 downto 0);
  signal slice_y_net: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x598 <= ce_1;
  clk_1_sg_x598 <= clk_1;
  register_q_net_x1 <= coeffs;
  delay1_q_net_x2 <= din;
  coeff_out <= slice1_y_net_x0;
  dout <= ram_data_out_net_x1;
  taps_out <= mult_p_net_x4;

  delay_bram_10e84c989a: entity work.delay_bram_entity_14d0e85ca6
    port map (
      ce_1 => ce_1_sg_x598,
      clk_1 => clk_1_sg_x598,
      din => delay1_q_net_x2,
      dout => ram_data_out_net_x1
    );

  mult: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret2_output_port_net,
      b => reinterpret_output_port_net,
      ce => ce_1_sg_x598,
      clk => clk_1_sg_x598,
      clr => '0',
      p => mult_p_net_x4
    );

  reinterpret: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_y_net,
      output_port => reinterpret_output_port_net
    );

  reinterpret2: entity work.reinterpret_120751dc4b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay1_q_net_x2,
      output_port => reinterpret2_output_port_net
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => register_q_net_x1,
      y => slice_y_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 71,
      x_width => 72,
      y_width => 54
    )
    port map (
      x => register_q_net_x1,
      y => slice1_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in2_last_tap"

entity pol1_in2_last_tap_entity_d4e46031cf is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    coeff: in std_logic_vector(17 downto 0); 
    din: in std_logic_vector(17 downto 0); 
    tap_out: out std_logic_vector(35 downto 0)
  );
end pol1_in2_last_tap_entity_d4e46031cf;

architecture structural of pol1_in2_last_tap_entity_d4e46031cf is
  signal ce_1_sg_x599: std_logic;
  signal clk_1_sg_x599: std_logic;
  signal mult_p_net_x5: std_logic_vector(35 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(17 downto 0);
  signal slice1_y_net_x0: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x599 <= ce_1;
  clk_1_sg_x599 <= clk_1;
  slice1_y_net_x0 <= coeff;
  ram_data_out_net_x0 <= din;
  tap_out <= mult_p_net_x5;

  mult: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret1_output_port_net,
      b => reinterpret_output_port_net,
      ce => ce_1_sg_x599,
      clk => clk_1_sg_x599,
      clr => '0',
      p => mult_p_net_x5
    );

  reinterpret: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net_x0,
      output_port => reinterpret_output_port_net
    );

  reinterpret1: entity work.reinterpret_120751dc4b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_data_out_net_x0,
      output_port => reinterpret1_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in2_tap2"

entity pol1_in2_tap2_entity_aca9bffd0b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    coeff: in std_logic_vector(53 downto 0); 
    din: in std_logic_vector(17 downto 0); 
    coeff_out: out std_logic_vector(35 downto 0); 
    dout: out std_logic_vector(17 downto 0); 
    taps_out: out std_logic_vector(35 downto 0)
  );
end pol1_in2_tap2_entity_aca9bffd0b;

architecture structural of pol1_in2_tap2_entity_aca9bffd0b is
  signal ce_1_sg_x601: std_logic;
  signal clk_1_sg_x601: std_logic;
  signal mult_p_net_x6: std_logic_vector(35 downto 0);
  signal ram_data_out_net_x3: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x4: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(17 downto 0);
  signal slice1_y_net_x1: std_logic_vector(53 downto 0);
  signal slice1_y_net_x2: std_logic_vector(35 downto 0);
  signal slice_y_net: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x601 <= ce_1;
  clk_1_sg_x601 <= clk_1;
  slice1_y_net_x1 <= coeff;
  ram_data_out_net_x3 <= din;
  coeff_out <= slice1_y_net_x2;
  dout <= ram_data_out_net_x4;
  taps_out <= mult_p_net_x6;

  delay_bram_1f81bd2aeb: entity work.delay_bram_entity_14d0e85ca6
    port map (
      ce_1 => ce_1_sg_x601,
      clk_1 => clk_1_sg_x601,
      din => ram_data_out_net_x3,
      dout => ram_data_out_net_x4
    );

  mult: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret1_output_port_net,
      b => reinterpret_output_port_net,
      ce => ce_1_sg_x601,
      clk => clk_1_sg_x601,
      clr => '0',
      p => mult_p_net_x6
    );

  reinterpret: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_y_net,
      output_port => reinterpret_output_port_net
    );

  reinterpret1: entity work.reinterpret_120751dc4b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_data_out_net_x3,
      output_port => reinterpret1_output_port_net
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 54,
      y_width => 18
    )
    port map (
      x => slice1_y_net_x1,
      y => slice_y_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 53,
      x_width => 54,
      y_width => 36
    )
    port map (
      x => slice1_y_net_x1,
      y => slice1_y_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol1_in2_tap3"

entity pol1_in2_tap3_entity_f7161a8727 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    coeff: in std_logic_vector(35 downto 0); 
    din: in std_logic_vector(17 downto 0); 
    coeff_out: out std_logic_vector(17 downto 0); 
    dout: out std_logic_vector(17 downto 0); 
    taps_out: out std_logic_vector(35 downto 0)
  );
end pol1_in2_tap3_entity_f7161a8727;

architecture structural of pol1_in2_tap3_entity_f7161a8727 is
  signal ce_1_sg_x603: std_logic;
  signal clk_1_sg_x603: std_logic;
  signal mult_p_net_x7: std_logic_vector(35 downto 0);
  signal ram_data_out_net_x2: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x6: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(17 downto 0);
  signal slice1_y_net_x3: std_logic_vector(35 downto 0);
  signal slice1_y_net_x4: std_logic_vector(17 downto 0);
  signal slice_y_net: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x603 <= ce_1;
  clk_1_sg_x603 <= clk_1;
  slice1_y_net_x3 <= coeff;
  ram_data_out_net_x6 <= din;
  coeff_out <= slice1_y_net_x4;
  dout <= ram_data_out_net_x2;
  taps_out <= mult_p_net_x7;

  delay_bram_afed761e3e: entity work.delay_bram_entity_14d0e85ca6
    port map (
      ce_1 => ce_1_sg_x603,
      clk_1 => clk_1_sg_x603,
      din => ram_data_out_net_x6,
      dout => ram_data_out_net_x2
    );

  mult: entity work.mult_f295e5f0f2
    port map (
      a => reinterpret1_output_port_net,
      b => reinterpret_output_port_net,
      ce => ce_1_sg_x603,
      clk => clk_1_sg_x603,
      clr => '0',
      p => mult_p_net_x7
    );

  reinterpret: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_y_net,
      output_port => reinterpret_output_port_net
    );

  reinterpret1: entity work.reinterpret_120751dc4b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_data_out_net_x6,
      output_port => reinterpret1_output_port_net
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => slice1_y_net_x3,
      y => slice_y_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 35,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => slice1_y_net_x3,
      y => slice1_y_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1/pol2_in1_coeffs"

entity pol2_in1_coeffs_entity_ff63cdf37d is
  port (
    ce_1: in std_logic; 
    ce_2500: in std_logic; 
    clk_1: in std_logic; 
    clk_2500: in std_logic; 
    din: in std_logic_vector(17 downto 0); 
    sync: in std_logic; 
    coeff: out std_logic_vector(71 downto 0); 
    dout: out std_logic_vector(17 downto 0)
  );
end pol2_in1_coeffs_entity_ff63cdf37d;

architecture structural of pol2_in1_coeffs_entity_ff63cdf37d is
  signal ce_1_sg_x604: std_logic;
  signal ce_2500_sg_x6: std_logic;
  signal clk_1_sg_x604: std_logic;
  signal clk_2500_sg_x6: std_logic;
  signal concat_y_net: std_logic_vector(71 downto 0);
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal delay1_q_net_x0: std_logic_vector(17 downto 0);
  signal delay7_q_net_x0: std_logic_vector(17 downto 0);
  signal delay8_q_net_x2: std_logic;
  signal fan_delay1_q_net: std_logic_vector(9 downto 0);
  signal fan_delay2_q_net: std_logic_vector(9 downto 0);
  signal fan_delay3_q_net: std_logic_vector(9 downto 0);
  signal fan_delay4_q_net: std_logic_vector(9 downto 0);
  signal register_q_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(17 downto 0);
  signal rom1_data_net: std_logic_vector(17 downto 0);
  signal rom2_data_net: std_logic_vector(17 downto 0);
  signal rom3_data_net: std_logic_vector(17 downto 0);
  signal rom4_data_net: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x604 <= ce_1;
  ce_2500_sg_x6 <= ce_2500;
  clk_1_sg_x604 <= clk_1;
  clk_2500_sg_x6 <= clk_2500;
  delay7_q_net_x0 <= din;
  delay8_q_net_x2 <= sync;
  coeff <= register_q_net_x0;
  dout <= delay1_q_net_x0;

  concat: entity work.concat_a246e373e7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concat_y_net
    );

  counter: entity work.xlcounter_free_window_and_fft_test_v4
    generic map (
      core_name0 => "cntr_11_0_5c0d8fded7f0a054",
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x604,
      clk => clk_1_sg_x604,
      clr => '0',
      en => "1",
      rst(0) => delay8_q_net_x2,
      op => counter_op_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_2500_sg_x6,
      clk => clk_2500_sg_x6,
      d => delay7_q_net_x0,
      en => '1',
      rst => '1',
      q => delay1_q_net_x0
    );

  fan_delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x604,
      clk => clk_1_sg_x604,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay1_q_net
    );

  fan_delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x604,
      clk => clk_1_sg_x604,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay2_q_net
    );

  fan_delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x604,
      clk => clk_1_sg_x604,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay3_q_net
    );

  fan_delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 10
    )
    port map (
      ce => ce_1_sg_x604,
      clk => clk_1_sg_x604,
      d => counter_op_net,
      en => '1',
      rst => '1',
      q => fan_delay4_q_net
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 72,
      init_value => b"000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x604,
      clk => clk_1_sg_x604,
      d => concat_y_net,
      en => "1",
      rst => "0",
      q => register_q_net_x0
    );

  reinterpret1: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom1_data_net,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom2_data_net,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom3_data_net,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => rom4_data_net,
      output_port => reinterpret4_output_port_net
    );

  rom1: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_b7d413d71af73706",
      latency => 1
    )
    port map (
      addr => fan_delay1_q_net,
      ce => ce_1_sg_x604,
      clk => clk_1_sg_x604,
      en => "1",
      rst => "0",
      data => rom1_data_net
    );

  rom2: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_fba27241bcd4df38",
      latency => 1
    )
    port map (
      addr => fan_delay2_q_net,
      ce => ce_1_sg_x604,
      clk => clk_1_sg_x604,
      en => "1",
      rst => "0",
      data => rom2_data_net
    );

  rom3: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_5d708e36ddb23a80",
      latency => 1
    )
    port map (
      addr => fan_delay3_q_net,
      ce => ce_1_sg_x604,
      clk => clk_1_sg_x604,
      en => "1",
      rst => "0",
      data => rom3_data_net
    );

  rom4: entity work.xlsprom_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 18,
      core_name0 => "bmg_72_146e01525f281df8",
      latency => 1
    )
    port map (
      addr => fan_delay4_q_net,
      ce => ce_1_sg_x604,
      clk => clk_1_sg_x604,
      en => "1",
      rst => "0",
      data => rom4_data_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pfb_fir_real1"

entity pfb_fir_real1_entity_f049311348 is
  port (
    ce_1: in std_logic; 
    ce_2500: in std_logic; 
    clk_1: in std_logic; 
    clk_2500: in std_logic; 
    pol1_in1: in std_logic_vector(17 downto 0); 
    pol1_in2: in std_logic_vector(17 downto 0); 
    pol2_in1: in std_logic_vector(17 downto 0); 
    pol2_in2: in std_logic_vector(17 downto 0); 
    sync: in std_logic; 
    pol1_out1: out std_logic_vector(17 downto 0); 
    pol1_out2: out std_logic_vector(17 downto 0); 
    pol2_out1: out std_logic_vector(17 downto 0); 
    pol2_out2: out std_logic_vector(17 downto 0); 
    sync_out: out std_logic
  );
end pfb_fir_real1_entity_f049311348;

architecture structural of pfb_fir_real1_entity_f049311348 is
  signal addr3_s_net_x0: std_logic_vector(25 downto 0);
  signal addr3_s_net_x1: std_logic_vector(25 downto 0);
  signal addr3_s_net_x2: std_logic_vector(25 downto 0);
  signal addr3_s_net_x3: std_logic_vector(25 downto 0);
  signal ce_1_sg_x620: std_logic;
  signal ce_2500_sg_x8: std_logic;
  signal clk_1_sg_x620: std_logic;
  signal clk_2500_sg_x8: std_logic;
  signal convert_1_1_dout_net_x0: std_logic_vector(17 downto 0);
  signal convert_1_2_dout_net_x0: std_logic_vector(17 downto 0);
  signal convert_2_1_dout_net_x0: std_logic_vector(17 downto 0);
  signal convert_2_2_dout_net_x0: std_logic_vector(17 downto 0);
  signal delay1_q_net_x0: std_logic;
  signal delay1_q_net_x2: std_logic_vector(17 downto 0);
  signal delay1_q_net_x3: std_logic_vector(17 downto 0);
  signal delay1_q_net_x4: std_logic_vector(17 downto 0);
  signal delay1_q_net_x5: std_logic_vector(17 downto 0);
  signal delay4_q_net_x1: std_logic_vector(17 downto 0);
  signal delay5_q_net_x1: std_logic_vector(17 downto 0);
  signal delay6_q_net_x1: std_logic_vector(17 downto 0);
  signal delay7_q_net_x1: std_logic_vector(17 downto 0);
  signal delay8_q_net_x4: std_logic;
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal mult_p_net_x10: std_logic_vector(35 downto 0);
  signal mult_p_net_x11: std_logic_vector(35 downto 0);
  signal mult_p_net_x12: std_logic_vector(35 downto 0);
  signal mult_p_net_x13: std_logic_vector(35 downto 0);
  signal mult_p_net_x14: std_logic_vector(35 downto 0);
  signal mult_p_net_x15: std_logic_vector(35 downto 0);
  signal mult_p_net_x16: std_logic_vector(35 downto 0);
  signal mult_p_net_x17: std_logic_vector(35 downto 0);
  signal mult_p_net_x18: std_logic_vector(35 downto 0);
  signal mult_p_net_x19: std_logic_vector(35 downto 0);
  signal mult_p_net_x4: std_logic_vector(35 downto 0);
  signal mult_p_net_x5: std_logic_vector(35 downto 0);
  signal mult_p_net_x6: std_logic_vector(35 downto 0);
  signal mult_p_net_x7: std_logic_vector(35 downto 0);
  signal mult_p_net_x8: std_logic_vector(35 downto 0);
  signal mult_p_net_x9: std_logic_vector(35 downto 0);
  signal mux_y_net_x2: std_logic;
  signal mux_y_net_x3: std_logic;
  signal mux_y_net_x6: std_logic;
  signal ram_data_out_net_x10: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x11: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x12: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x13: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x14: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x2: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x3: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x4: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x6: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x7: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x8: std_logic_vector(17 downto 0);
  signal ram_data_out_net_x9: std_logic_vector(17 downto 0);
  signal register_q_net_x1: std_logic_vector(71 downto 0);
  signal register_q_net_x2: std_logic_vector(71 downto 0);
  signal register_q_net_x3: std_logic_vector(71 downto 0);
  signal register_q_net_x4: std_logic_vector(71 downto 0);
  signal scale_1_1_op_net: std_logic_vector(25 downto 0);
  signal scale_1_2_op_net: std_logic_vector(25 downto 0);
  signal scale_2_1_op_net: std_logic_vector(25 downto 0);
  signal scale_2_2_op_net: std_logic_vector(25 downto 0);
  signal slice1_y_net_x1: std_logic_vector(53 downto 0);
  signal slice1_y_net_x10: std_logic_vector(17 downto 0);
  signal slice1_y_net_x11: std_logic_vector(53 downto 0);
  signal slice1_y_net_x12: std_logic_vector(35 downto 0);
  signal slice1_y_net_x13: std_logic_vector(17 downto 0);
  signal slice1_y_net_x3: std_logic_vector(35 downto 0);
  signal slice1_y_net_x4: std_logic_vector(17 downto 0);
  signal slice1_y_net_x5: std_logic_vector(53 downto 0);
  signal slice1_y_net_x6: std_logic_vector(35 downto 0);
  signal slice1_y_net_x7: std_logic_vector(17 downto 0);
  signal slice1_y_net_x8: std_logic_vector(53 downto 0);
  signal slice1_y_net_x9: std_logic_vector(35 downto 0);
  signal sync_delay_q_net_x0: std_logic;

begin
  ce_1_sg_x620 <= ce_1;
  ce_2500_sg_x8 <= ce_2500;
  clk_1_sg_x620 <= clk_1;
  clk_2500_sg_x8 <= clk_2500;
  delay4_q_net_x1 <= pol1_in1;
  delay6_q_net_x1 <= pol1_in2;
  delay7_q_net_x1 <= pol2_in1;
  delay5_q_net_x1 <= pol2_in2;
  delay8_q_net_x4 <= sync;
  pol1_out1 <= convert_1_1_dout_net_x0;
  pol1_out2 <= convert_1_2_dout_net_x0;
  pol2_out1 <= convert_2_1_dout_net_x0;
  pol2_out2 <= convert_2_2_dout_net_x0;
  sync_out <= delay1_q_net_x0;

  adder_1_1_e699198897: entity work.adder_1_1_entity_e699198897
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      din1 => mult_p_net_x4,
      din2 => mult_p_net_x6,
      din3 => mult_p_net_x7,
      din4 => mult_p_net_x5,
      sync => delay_q_net_x1,
      dout => addr3_s_net_x0,
      sync_out => sync_delay_q_net_x0
    );

  adder_1_2_3e607ccf9a: entity work.adder_1_2_entity_3e607ccf9a
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      din1 => mult_p_net_x8,
      din2 => mult_p_net_x10,
      din3 => mult_p_net_x11,
      din4 => mult_p_net_x9,
      dout => addr3_s_net_x1
    );

  adder_2_1_5cf60f05c0: entity work.adder_1_2_entity_3e607ccf9a
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      din1 => mult_p_net_x12,
      din2 => mult_p_net_x14,
      din3 => mult_p_net_x15,
      din4 => mult_p_net_x13,
      dout => addr3_s_net_x2
    );

  adder_2_2_a82d276f11: entity work.adder_1_2_entity_3e607ccf9a
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      din1 => mult_p_net_x16,
      din2 => mult_p_net_x18,
      din3 => mult_p_net_x19,
      din4 => mult_p_net_x17,
      dout => addr3_s_net_x3
    );

  convert_1_1: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 25,
      din_width => 26,
      dout_arith => 2,
      dout_bin_pt => 17,
      dout_width => 18,
      latency => 1,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x620,
      clk => clk_1_sg_x620,
      clr => '0',
      din => scale_1_1_op_net,
      en => "1",
      dout => convert_1_1_dout_net_x0
    );

  convert_1_2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 25,
      din_width => 26,
      dout_arith => 2,
      dout_bin_pt => 17,
      dout_width => 18,
      latency => 1,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x620,
      clk => clk_1_sg_x620,
      clr => '0',
      din => scale_1_2_op_net,
      en => "1",
      dout => convert_1_2_dout_net_x0
    );

  convert_2_1: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 25,
      din_width => 26,
      dout_arith => 2,
      dout_bin_pt => 17,
      dout_width => 18,
      latency => 1,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x620,
      clk => clk_1_sg_x620,
      clr => '0',
      din => scale_2_1_op_net,
      en => "1",
      dout => convert_2_1_dout_net_x0
    );

  convert_2_2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 25,
      din_width => 26,
      dout_arith => 2,
      dout_bin_pt => 17,
      dout_width => 18,
      latency => 1,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x620,
      clk => clk_1_sg_x620,
      clr => '0',
      din => scale_2_2_op_net,
      en => "1",
      dout => convert_2_2_dout_net_x0
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x620,
      clk => clk_1_sg_x620,
      d(0) => sync_delay_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net_x0
    );

  pol1_in1_coeffs_ad249aca95: entity work.pol1_in1_coeffs_entity_ad249aca95
    port map (
      ce_1 => ce_1_sg_x620,
      ce_2500 => ce_2500_sg_x8,
      clk_1 => clk_1_sg_x620,
      clk_2500 => clk_2500_sg_x8,
      din => delay4_q_net_x1,
      sync => delay8_q_net_x4,
      coeff => register_q_net_x1,
      dout => delay1_q_net_x2,
      sync_out => delay_q_net_x2
    );

  pol1_in1_first_tap_68007830ab: entity work.pol1_in1_first_tap_entity_68007830ab
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeffs => register_q_net_x1,
      din => delay1_q_net_x2,
      sync => delay_q_net_x2,
      coeff_out => slice1_y_net_x1,
      dout => ram_data_out_net_x3,
      sync_out => mux_y_net_x3,
      taps_out => mult_p_net_x4
    );

  pol1_in1_last_tap_052c470427: entity work.pol1_in1_last_tap_entity_052c470427
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x4,
      din => ram_data_out_net_x2,
      sync => mux_y_net_x2,
      sync_out => delay_q_net_x1,
      tap_out => mult_p_net_x5
    );

  pol1_in1_tap2_7dc3d635c1: entity work.pol1_in1_tap2_entity_7dc3d635c1
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x1,
      din => ram_data_out_net_x3,
      sync => mux_y_net_x3,
      coeff_out => slice1_y_net_x3,
      dout => ram_data_out_net_x6,
      sync_out => mux_y_net_x6,
      taps_out => mult_p_net_x6
    );

  pol1_in1_tap3_81eacbfb0d: entity work.pol1_in1_tap3_entity_81eacbfb0d
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x3,
      din => ram_data_out_net_x6,
      sync => mux_y_net_x6,
      coeff_out => slice1_y_net_x4,
      dout => ram_data_out_net_x2,
      sync_out => mux_y_net_x2,
      taps_out => mult_p_net_x7
    );

  pol1_in2_coeffs_9c1b410463: entity work.pol1_in2_coeffs_entity_9c1b410463
    port map (
      ce_1 => ce_1_sg_x620,
      ce_2500 => ce_2500_sg_x8,
      clk_1 => clk_1_sg_x620,
      clk_2500 => clk_2500_sg_x8,
      din => delay6_q_net_x1,
      sync => delay8_q_net_x4,
      coeff => register_q_net_x2,
      dout => delay1_q_net_x3
    );

  pol1_in2_first_tap_b598ad2e00: entity work.pol1_in2_first_tap_entity_b598ad2e00
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeffs => register_q_net_x2,
      din => delay1_q_net_x3,
      coeff_out => slice1_y_net_x5,
      dout => ram_data_out_net_x7,
      taps_out => mult_p_net_x8
    );

  pol1_in2_last_tap_d4e46031cf: entity work.pol1_in2_last_tap_entity_d4e46031cf
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x7,
      din => ram_data_out_net_x4,
      tap_out => mult_p_net_x9
    );

  pol1_in2_tap2_aca9bffd0b: entity work.pol1_in2_tap2_entity_aca9bffd0b
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x5,
      din => ram_data_out_net_x7,
      coeff_out => slice1_y_net_x6,
      dout => ram_data_out_net_x8,
      taps_out => mult_p_net_x10
    );

  pol1_in2_tap3_f7161a8727: entity work.pol1_in2_tap3_entity_f7161a8727
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x6,
      din => ram_data_out_net_x8,
      coeff_out => slice1_y_net_x7,
      dout => ram_data_out_net_x4,
      taps_out => mult_p_net_x11
    );

  pol2_in1_coeffs_ff63cdf37d: entity work.pol2_in1_coeffs_entity_ff63cdf37d
    port map (
      ce_1 => ce_1_sg_x620,
      ce_2500 => ce_2500_sg_x8,
      clk_1 => clk_1_sg_x620,
      clk_2500 => clk_2500_sg_x8,
      din => delay7_q_net_x1,
      sync => delay8_q_net_x4,
      coeff => register_q_net_x3,
      dout => delay1_q_net_x4
    );

  pol2_in1_first_tap_abf4a9c2f9: entity work.pol1_in2_first_tap_entity_b598ad2e00
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeffs => register_q_net_x3,
      din => delay1_q_net_x4,
      coeff_out => slice1_y_net_x8,
      dout => ram_data_out_net_x9,
      taps_out => mult_p_net_x12
    );

  pol2_in1_last_tap_5d68d0ef65: entity work.pol1_in2_last_tap_entity_d4e46031cf
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x10,
      din => ram_data_out_net_x11,
      tap_out => mult_p_net_x13
    );

  pol2_in1_tap2_ef5e707762: entity work.pol1_in2_tap2_entity_aca9bffd0b
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x8,
      din => ram_data_out_net_x9,
      coeff_out => slice1_y_net_x9,
      dout => ram_data_out_net_x10,
      taps_out => mult_p_net_x14
    );

  pol2_in1_tap3_55d4577ec4: entity work.pol1_in2_tap3_entity_f7161a8727
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x9,
      din => ram_data_out_net_x10,
      coeff_out => slice1_y_net_x10,
      dout => ram_data_out_net_x11,
      taps_out => mult_p_net_x15
    );

  pol2_in2_coeffs_39e111adf1: entity work.pol1_in2_coeffs_entity_9c1b410463
    port map (
      ce_1 => ce_1_sg_x620,
      ce_2500 => ce_2500_sg_x8,
      clk_1 => clk_1_sg_x620,
      clk_2500 => clk_2500_sg_x8,
      din => delay5_q_net_x1,
      sync => delay8_q_net_x4,
      coeff => register_q_net_x4,
      dout => delay1_q_net_x5
    );

  pol2_in2_first_tap_3cd2d753cd: entity work.pol1_in2_first_tap_entity_b598ad2e00
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeffs => register_q_net_x4,
      din => delay1_q_net_x5,
      coeff_out => slice1_y_net_x11,
      dout => ram_data_out_net_x12,
      taps_out => mult_p_net_x16
    );

  pol2_in2_last_tap_b17af4ca23: entity work.pol1_in2_last_tap_entity_d4e46031cf
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x13,
      din => ram_data_out_net_x14,
      tap_out => mult_p_net_x17
    );

  pol2_in2_tap2_93f8b91f92: entity work.pol1_in2_tap2_entity_aca9bffd0b
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x11,
      din => ram_data_out_net_x12,
      coeff_out => slice1_y_net_x12,
      dout => ram_data_out_net_x13,
      taps_out => mult_p_net_x18
    );

  pol2_in2_tap3_adbe42185d: entity work.pol1_in2_tap3_entity_f7161a8727
    port map (
      ce_1 => ce_1_sg_x620,
      clk_1 => clk_1_sg_x620,
      coeff => slice1_y_net_x12,
      din => ram_data_out_net_x13,
      coeff_out => slice1_y_net_x13,
      dout => ram_data_out_net_x14,
      taps_out => mult_p_net_x19
    );

  scale_1_1: entity work.scale_f01f7ce486
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => addr3_s_net_x0,
      op => scale_1_1_op_net
    );

  scale_1_2: entity work.scale_f01f7ce486
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => addr3_s_net_x1,
      op => scale_1_2_op_net
    );

  scale_2_1: entity work.scale_f01f7ce486
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => addr3_s_net_x2,
      op => scale_2_1_op_net
    );

  scale_2_2: entity work.scale_f01f7ce486
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => addr3_s_net_x3,
      op => scale_2_2_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pipeline1"

entity pipeline1_entity_fd1e8cdd4b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic; 
    q: out std_logic
  );
end pipeline1_entity_fd1e8cdd4b;

architecture structural of pipeline1_entity_fd1e8cdd4b is
  signal ce_1_sg_x621: std_logic;
  signal clk_1_sg_x621: std_logic;
  signal delay1_q_net_x0: std_logic;
  signal register0_q_net_x0: std_logic;

begin
  ce_1_sg_x621 <= ce_1;
  clk_1_sg_x621 <= clk_1;
  delay1_q_net_x0 <= d;
  q <= register0_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x621,
      clk => clk_1_sg_x621,
      d(0) => delay1_q_net_x0,
      en => "1",
      rst => "0",
      q(0) => register0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pipeline19"

entity pipeline19_entity_9c44957711 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(63 downto 0); 
    q: out std_logic_vector(63 downto 0)
  );
end pipeline19_entity_9c44957711;

architecture structural of pipeline19_entity_9c44957711 is
  signal ce_1_sg_x623: std_logic;
  signal clk_1_sg_x623: std_logic;
  signal register0_q_net_x3: std_logic_vector(63 downto 0);
  signal reinterpret6_output_port_net_x0: std_logic_vector(63 downto 0);

begin
  ce_1_sg_x623 <= ce_1;
  clk_1_sg_x623 <= clk_1;
  reinterpret6_output_port_net_x0 <= d;
  q <= register0_q_net_x3;

  register0: entity work.xlregister
    generic map (
      d_width => 64,
      init_value => b"0000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x623,
      clk => clk_1_sg_x623,
      d => reinterpret6_output_port_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pipeline20"

entity pipeline20_entity_ed6ce63c1a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(9 downto 0); 
    q: out std_logic_vector(9 downto 0)
  );
end pipeline20_entity_ed6ce63c1a;

architecture structural of pipeline20_entity_ed6ce63c1a is
  signal ce_1_sg_x624: std_logic;
  signal clk_1_sg_x624: std_logic;
  signal register0_q_net_x4: std_logic_vector(9 downto 0);
  signal spect_cnt2_op_net_x0: std_logic_vector(9 downto 0);

begin
  ce_1_sg_x624 <= ce_1;
  clk_1_sg_x624 <= clk_1;
  spect_cnt2_op_net_x0 <= d;
  q <= register0_q_net_x4;

  register0: entity work.xlregister
    generic map (
      d_width => 10,
      init_value => b"0000000000"
    )
    port map (
      ce => ce_1_sg_x624,
      clk => clk_1_sg_x624,
      d => spect_cnt2_op_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/pipeline32"

entity pipeline32_entity_2d07f7b9aa is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(35 downto 0); 
    q: out std_logic_vector(35 downto 0)
  );
end pipeline32_entity_2d07f7b9aa;

architecture structural of pipeline32_entity_2d07f7b9aa is
  signal ce_1_sg_x626: std_logic;
  signal clk_1_sg_x626: std_logic;
  signal delay33_q_net_x0: std_logic_vector(35 downto 0);
  signal register0_q_net_x0: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x626 <= ce_1;
  clk_1_sg_x626 <= clk_1;
  delay33_q_net_x0 <= d;
  q <= register0_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 36,
      init_value => b"000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x626,
      clk => clk_1_sg_x626,
      d => delay33_q_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/posedge9"

entity posedge9_entity_b995cb784d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end posedge9_entity_b995cb784d;

architecture structural of posedge9_entity_b995cb784d is
  signal ce_1_sg_x633: std_logic;
  signal clk_1_sg_x633: std_logic;
  signal delay_q_net: std_logic;
  signal edge_op_y_net_x2: std_logic;
  signal inverter_op_net: std_logic;
  signal logical_y_net_x0: std_logic;

begin
  ce_1_sg_x633 <= ce_1;
  clk_1_sg_x633 <= clk_1;
  logical_y_net_x0 <= in_x0;
  out_x0 <= edge_op_y_net_x2;

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x633,
      clk => clk_1_sg_x633,
      d(0) => logical_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay_q_net
    );

  edge_op: entity work.logical_dfe2dded7f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => inverter_op_net,
      d1(0) => delay_q_net,
      y(0) => edge_op_y_net_x2
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x633,
      clk => clk_1_sg_x633,
      clr => '0',
      ip(0) => logical_y_net_x0,
      op(0) => inverter_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/power3"

entity power3_entity_b160c790c4 is
  port (
    c: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    power: out std_logic_vector(35 downto 0)
  );
end power3_entity_b160c790c4;

architecture structural of power3_entity_b160c790c4 is
  signal ce_1_sg_x634: std_logic;
  signal clk_1_sg_x634: std_logic;
  signal delay20_q_net_x1: std_logic_vector(35 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(17 downto 0);
  signal imag_square_p_net: std_logic_vector(35 downto 0);
  signal power_adder_s_net_x0: std_logic_vector(35 downto 0);
  signal real_square_p_net: std_logic_vector(35 downto 0);

begin
  delay20_q_net_x1 <= c;
  ce_1_sg_x634 <= ce_1;
  clk_1_sg_x634 <= clk_1;
  power <= power_adder_s_net_x0;

  c_to_ri_8ae4adf1bb: entity work.c_to_ri_entity_27418540ef
    port map (
      c => delay20_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  imag_square: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 18,
      b_arith => xlSigned,
      b_bin_pt => 17,
      b_width => 18,
      c_a_type => 0,
      c_a_width => 18,
      c_b_type => 0,
      c_b_width => 18,
      c_baat => 18,
      c_output_width => 36,
      c_type => 0,
      core_name0 => "mult_11_2_ecdcb40ad0958e64",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 34,
      p_width => 36,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x0,
      ce => ce_1_sg_x634,
      clk => clk_1_sg_x634,
      clr => '0',
      core_ce => ce_1_sg_x634,
      core_clk => clk_1_sg_x634,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => imag_square_p_net
    );

  power_adder: entity work.addsub_b9651d0357
    port map (
      a => real_square_p_net,
      b => imag_square_p_net,
      ce => ce_1_sg_x634,
      clk => clk_1_sg_x634,
      clr => '0',
      s => power_adder_s_net_x0
    );

  real_square: entity work.xlmult_window_and_fft_test_v4
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 18,
      b_arith => xlSigned,
      b_bin_pt => 17,
      b_width => 18,
      c_a_type => 0,
      c_a_width => 18,
      c_b_type => 0,
      c_b_width => 18,
      c_baat => 18,
      c_output_width => 36,
      c_type => 0,
      core_name0 => "mult_11_2_ecdcb40ad0958e64",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 34,
      p_width => 36,
      quantization => 1
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x0,
      ce => ce_1_sg_x634,
      clk => clk_1_sg_x634,
      clr => '0',
      core_ce => ce_1_sg_x634,
      core_clk => clk_1_sg_x634,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => real_square_p_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/simple_bram_vacc2/delay_bram"

entity delay_bram_entity_01c7d0f737 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(63 downto 0); 
    out1: out std_logic_vector(63 downto 0)
  );
end delay_bram_entity_01c7d0f737;

architecture structural of delay_bram_entity_01c7d0f737 is
  signal adder_s_net_x0: std_logic_vector(63 downto 0);
  signal ce_1_sg_x636: std_logic;
  signal clk_1_sg_x636: std_logic;
  signal constant2_op_net: std_logic;
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal single_port_ram_data_out_net_x0: std_logic_vector(63 downto 0);

begin
  ce_1_sg_x636 <= ce_1;
  clk_1_sg_x636 <= clk_1;
  adder_s_net_x0 <= in1;
  out1 <= single_port_ram_data_out_net_x0;

  constant2: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  counter: entity work.counter_9a68cae5d5
    port map (
      ce => ce_1_sg_x636,
      clk => clk_1_sg_x636,
      clr => '0',
      op => counter_op_net
    );

  single_port_ram: entity work.xlspram_window_and_fft_test_v4
    generic map (
      c_address_width => 10,
      c_width => 64,
      core_name0 => "bmg_72_a4cff0d500ff7adb",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x636,
      clk => clk_1_sg_x636,
      data_in => adder_s_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant2_op_net,
      data_out => single_port_ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/simple_bram_vacc2/pulse_ext/posedge"

entity posedge_entity_1a4321f057 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end posedge_entity_1a4321f057;

architecture structural of posedge_entity_1a4321f057 is
  signal ce_1_sg_x637: std_logic;
  signal clk_1_sg_x637: std_logic;
  signal delay_q_net: std_logic;
  signal inverter_op_net: std_logic;
  signal logical_y_net_x0: std_logic;
  signal register0_q_net_x1: std_logic;

begin
  ce_1_sg_x637 <= ce_1;
  clk_1_sg_x637 <= clk_1;
  register0_q_net_x1 <= in_x0;
  out_x0 <= logical_y_net_x0;

  delay: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x637,
      clk => clk_1_sg_x637,
      clr => '0',
      d(0) => register0_q_net_x1,
      q(0) => delay_q_net
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x637,
      clk => clk_1_sg_x637,
      clr => '0',
      ip(0) => delay_q_net,
      op(0) => inverter_op_net
    );

  logical: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => inverter_op_net,
      d1(0) => register0_q_net_x1,
      y(0) => logical_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/simple_bram_vacc2/pulse_ext"

entity pulse_ext_entity_40b6b52eb1 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end pulse_ext_entity_40b6b52eb1;

architecture structural of pulse_ext_entity_40b6b52eb1 is
  signal ce_1_sg_x638: std_logic;
  signal clk_1_sg_x638: std_logic;
  signal constant5_op_net: std_logic_vector(10 downto 0);
  signal counter3_op_net: std_logic_vector(10 downto 0);
  signal logical_y_net_x0: std_logic;
  signal register0_q_net_x2: std_logic;
  signal relational5_op_net_x1: std_logic;

begin
  ce_1_sg_x638 <= ce_1;
  clk_1_sg_x638 <= clk_1;
  register0_q_net_x2 <= in_x0;
  out_x0 <= relational5_op_net_x1;

  constant5: entity work.constant_0604807f72
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant5_op_net
    );

  counter3: entity work.counter_c962367f4b
    port map (
      ce => ce_1_sg_x638,
      clk => clk_1_sg_x638,
      clr => '0',
      en(0) => relational5_op_net_x1,
      rst(0) => logical_y_net_x0,
      op => counter3_op_net
    );

  posedge_1a4321f057: entity work.posedge_entity_1a4321f057
    port map (
      ce_1 => ce_1_sg_x638,
      clk_1 => clk_1_sg_x638,
      in_x0 => register0_q_net_x2,
      out_x0 => logical_y_net_x0
    );

  relational5: entity work.relational_b4b277ae0f
    port map (
      a => counter3_op_net,
      b => constant5_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational5_op_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4/simple_bram_vacc2"

entity simple_bram_vacc2_entity_b7c86c1381 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(35 downto 0); 
    new_acc: in std_logic; 
    dout: out std_logic_vector(63 downto 0); 
    valid: out std_logic
  );
end simple_bram_vacc2_entity_b7c86c1381;

architecture structural of simple_bram_vacc2_entity_b7c86c1381 is
  signal adder_s_net_x0: std_logic_vector(63 downto 0);
  signal ce_1_sg_x639: std_logic;
  signal clk_1_sg_x639: std_logic;
  signal constant_op_net: std_logic_vector(63 downto 0);
  signal mux_y_net: std_logic_vector(63 downto 0);
  signal register0_q_net_x4: std_logic;
  signal register0_q_net_x5: std_logic_vector(35 downto 0);
  signal relational5_op_net_x2: std_logic;
  signal single_port_ram_data_out_net_x1: std_logic_vector(63 downto 0);

begin
  ce_1_sg_x639 <= ce_1;
  clk_1_sg_x639 <= clk_1;
  register0_q_net_x5 <= din;
  register0_q_net_x4 <= new_acc;
  dout <= single_port_ram_data_out_net_x1;
  valid <= relational5_op_net_x2;

  adder: entity work.addsub_e8b4940472
    port map (
      a => register0_q_net_x5,
      b => mux_y_net,
      ce => ce_1_sg_x639,
      clk => clk_1_sg_x639,
      clr => '0',
      s => adder_s_net_x0
    );

  constant_x0: entity work.constant_c4c603edf2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  delay_bram_01c7d0f737: entity work.delay_bram_entity_01c7d0f737
    port map (
      ce_1 => ce_1_sg_x639,
      clk_1 => clk_1_sg_x639,
      in1 => adder_s_net_x0,
      out1 => single_port_ram_data_out_net_x1
    );

  mux: entity work.mux_66e06093b2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => single_port_ram_data_out_net_x1,
      d1 => constant_op_net,
      sel(0) => relational5_op_net_x2,
      y => mux_y_net
    );

  pulse_ext_40b6b52eb1: entity work.pulse_ext_entity_40b6b52eb1
    port map (
      ce_1 => ce_1_sg_x639,
      clk_1 => clk_1_sg_x639,
      in_x0 => register0_q_net_x4,
      out_x0 => relational5_op_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "window_and_fft_test_v4"

entity window_and_fft_test_v4 is
  port (
    ce_1: in std_logic; 
    ce_2500: in std_logic; 
    ce_50: in std_logic; 
    ce_logic_1: in std_logic; 
    clk_1: in std_logic; 
    clk_2500: in std_logic; 
    clk_50: in std_logic; 
    window_and_fft_test_v4_adc_user_data_valid: in std_logic; 
    window_and_fft_test_v4_adc_user_datai0: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_datai1: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_datai2: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_datai3: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_dataq0: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_dataq1: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_dataq2: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_dataq3: in std_logic_vector(7 downto 0); 
    window_and_fft_test_v4_adc_user_outofrangei0: in std_logic; 
    window_and_fft_test_v4_adc_user_outofrangei1: in std_logic; 
    window_and_fft_test_v4_adc_user_outofrangeq0: in std_logic; 
    window_and_fft_test_v4_adc_user_outofrangeq1: in std_logic; 
    window_and_fft_test_v4_adc_user_sync0: in std_logic; 
    window_and_fft_test_v4_adc_user_sync1: in std_logic; 
    window_and_fft_test_v4_adc_user_sync2: in std_logic; 
    window_and_fft_test_v4_adc_user_sync3: in std_logic; 
    window_and_fft_test_v4_bypass_pfb_user_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_coarse_fft_shift_mask1_user_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_even_window1_data_out: in std_logic_vector(63 downto 0); 
    window_and_fft_test_v4_gpio_gateway: in std_logic; 
    window_and_fft_test_v4_mixer_cnt_user_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_odd_window1_data_out: in std_logic_vector(63 downto 0); 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out: in std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out: in std_logic_vector(31 downto 0); 
    gateway_out: out std_logic_vector(31 downto 0); 
    gateway_out1: out std_logic_vector(15 downto 0); 
    gateway_out10: out std_logic_vector(15 downto 0); 
    gateway_out10_x0: out std_logic_vector(7 downto 0); 
    gateway_out11: out std_logic_vector(17 downto 0); 
    gateway_out11_x0: out std_logic_vector(7 downto 0); 
    gateway_out12: out std_logic_vector(15 downto 0); 
    gateway_out12_x0: out std_logic_vector(7 downto 0); 
    gateway_out13: out std_logic; 
    gateway_out13_x0: out std_logic_vector(7 downto 0); 
    gateway_out14: out std_logic_vector(15 downto 0); 
    gateway_out14_x0: out std_logic_vector(15 downto 0); 
    gateway_out15: out std_logic_vector(15 downto 0); 
    gateway_out16: out std_logic_vector(15 downto 0); 
    gateway_out16_x0: out std_logic_vector(15 downto 0); 
    gateway_out17: out std_logic_vector(17 downto 0); 
    gateway_out17_x0: out std_logic_vector(15 downto 0); 
    gateway_out18: out std_logic_vector(15 downto 0); 
    gateway_out18_x0: out std_logic_vector(15 downto 0); 
    gateway_out19: out std_logic_vector(15 downto 0); 
    gateway_out19_x0: out std_logic_vector(15 downto 0); 
    gateway_out1_x0: out std_logic_vector(7 downto 0); 
    gateway_out1_x1: out std_logic_vector(31 downto 0); 
    gateway_out1_x2: out std_logic_vector(31 downto 0); 
    gateway_out1_x3: out std_logic_vector(31 downto 0); 
    gateway_out1_x4: out std_logic_vector(31 downto 0); 
    gateway_out2: out std_logic_vector(7 downto 0); 
    gateway_out20: out std_logic_vector(17 downto 0); 
    gateway_out20_x0: out std_logic_vector(15 downto 0); 
    gateway_out21: out std_logic_vector(15 downto 0); 
    gateway_out21_x0: out std_logic_vector(15 downto 0); 
    gateway_out22: out std_logic_vector(15 downto 0); 
    gateway_out22_x0: out std_logic_vector(15 downto 0); 
    gateway_out23: out std_logic_vector(15 downto 0); 
    gateway_out24: out std_logic_vector(15 downto 0); 
    gateway_out25: out std_logic_vector(15 downto 0); 
    gateway_out2_x0: out std_logic_vector(31 downto 0); 
    gateway_out2_x1: out std_logic_vector(31 downto 0); 
    gateway_out2_x2: out std_logic_vector(31 downto 0); 
    gateway_out2_x3: out std_logic_vector(31 downto 0); 
    gateway_out3: out std_logic_vector(15 downto 0); 
    gateway_out31: out std_logic_vector(15 downto 0); 
    gateway_out32: out std_logic_vector(7 downto 0); 
    gateway_out33: out std_logic_vector(7 downto 0); 
    gateway_out34: out std_logic_vector(7 downto 0); 
    gateway_out35: out std_logic_vector(7 downto 0); 
    gateway_out36: out std_logic_vector(7 downto 0); 
    gateway_out37: out std_logic_vector(7 downto 0); 
    gateway_out38: out std_logic_vector(7 downto 0); 
    gateway_out39: out std_logic_vector(7 downto 0); 
    gateway_out3_x0: out std_logic_vector(31 downto 0); 
    gateway_out3_x1: out std_logic_vector(31 downto 0); 
    gateway_out3_x2: out std_logic_vector(31 downto 0); 
    gateway_out3_x3: out std_logic_vector(31 downto 0); 
    gateway_out4: out std_logic_vector(15 downto 0); 
    gateway_out4_x0: out std_logic_vector(15 downto 0); 
    gateway_out5: out std_logic_vector(15 downto 0); 
    gateway_out6: out std_logic_vector(15 downto 0); 
    gateway_out7: out std_logic_vector(15 downto 0); 
    gateway_out7_x0: out std_logic_vector(15 downto 0); 
    gateway_out8: out std_logic_vector(17 downto 0); 
    gateway_out8_x0: out std_logic_vector(7 downto 0); 
    gateway_out9: out std_logic_vector(15 downto 0); 
    gateway_out9_x0: out std_logic_vector(7 downto 0); 
    gateway_out_x0: out std_logic_vector(31 downto 0); 
    gateway_out_x1: out std_logic_vector(31 downto 0); 
    gateway_out_x2: out std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_even_window1_addr: out std_logic_vector(9 downto 0); 
    window_and_fft_test_v4_even_window1_data_in: out std_logic_vector(63 downto 0); 
    window_and_fft_test_v4_even_window1_we: out std_logic; 
    window_and_fft_test_v4_odd_window1_addr: out std_logic_vector(9 downto 0); 
    window_and_fft_test_v4_odd_window1_data_in: out std_logic_vector(63 downto 0); 
    window_and_fft_test_v4_odd_window1_we: out std_logic; 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram1_addr: out std_logic_vector(9 downto 0); 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_in: out std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram1_we: out std_logic; 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram_addr: out std_logic_vector(9 downto 0); 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_in: out std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_1_shared_bram_we: out std_logic; 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram1_addr: out std_logic_vector(9 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_in: out std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram1_we: out std_logic; 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram_addr: out std_logic_vector(9 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_in: out std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_2_shared_bram_we: out std_logic; 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram1_addr: out std_logic_vector(9 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_in: out std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram1_we: out std_logic; 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram_addr: out std_logic_vector(9 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_in: out std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_3_shared_bram_we: out std_logic; 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram1_addr: out std_logic_vector(9 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_in: out std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram1_we: out std_logic; 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram_addr: out std_logic_vector(9 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_in: out std_logic_vector(31 downto 0); 
    window_and_fft_test_v4_subsystem_lo_4_shared_bram_we: out std_logic
  );
end window_and_fft_test_v4;

architecture structural of window_and_fft_test_v4 is
  attribute core_generation_info: string;
  attribute core_generation_info of structural : architecture is "window_and_fft_test_v4,sysgen_core,{clock_period=5.00000000,clocking=Clock_Enables,compilation=NGC_Netlist,sample_periods=1.00000000000 50.00000000000 2500.00000000000,testbench=0,total_blocks=15104,xilinx_adder_subtracter_block=332,xilinx_arithmetic_relational_operator_block=74,xilinx_assert_block=7,xilinx_binary_shift_operator_block=4,xilinx_bit_slice_extractor_block=1488,xilinx_bus_concatenator_block=471,xilinx_bus_multiplexer_block=158,xilinx_constant_block_block=558,xilinx_counter_block=77,xilinx_delay_block=612,xilinx_disregard_subsystem_for_generation_block=10,xilinx_down_sampler_block=4,xilinx_dual_port_random_access_memory_block=7,xilinx_fdatool_interface_block=3,xilinx_fir_compiler_5_0_block=4,xilinx_gateway_in_block=61,xilinx_gateway_out_block=107,xilinx_input_scaler_block=64,xilinx_inverter_block=161,xilinx_logical_block_block=343,xilinx_multiplier_block=124,xilinx_negate_block_block=19,xilinx_register_block=81,xilinx_single_port_random_access_memory_block=34,xilinx_single_port_read_only_memory_block=27,xilinx_system_generator_block=1,xilinx_type_converter_block=156,xilinx_type_reinterpreter_block=2375,}";

  signal ce_1_sg_x644: std_logic;
  signal ce_2500_sg_x9: std_logic;
  signal ce_50_sg_x0: std_logic;
  signal ce_logic_1_sg_x0: std_logic;
  signal clk_1_sg_x644: std_logic;
  signal clk_2500_sg_x9: std_logic;
  signal clk_50_sg_x0: std_logic;
  signal concat_y_net_x2: std_logic_vector(31 downto 0);
  signal concat_y_net_x3: std_logic_vector(31 downto 0);
  signal convert_1_1_dout_net_x0: std_logic_vector(17 downto 0);
  signal convert_1_2_dout_net_x0: std_logic_vector(17 downto 0);
  signal convert_2_1_dout_net_x0: std_logic_vector(17 downto 0);
  signal convert_2_2_dout_net_x0: std_logic_vector(17 downto 0);
  signal convert_dout_net_x0: std_logic_vector(17 downto 0);
  signal convert_dout_net_x1: std_logic_vector(17 downto 0);
  signal convert_dout_net_x2: std_logic_vector(17 downto 0);
  signal convert_dout_net_x3: std_logic_vector(17 downto 0);
  signal delay10_q_net_x3: std_logic;
  signal delay11_q_net_x11: std_logic_vector(10 downto 0);
  signal delay12_q_net: std_logic_vector(17 downto 0);
  signal delay13_q_net: std_logic_vector(17 downto 0);
  signal delay14_q_net: std_logic_vector(17 downto 0);
  signal delay15_q_net: std_logic_vector(17 downto 0);
  signal delay16_q_net_x2: std_logic_vector(17 downto 0);
  signal delay17_q_net_x2: std_logic_vector(17 downto 0);
  signal delay18_q_net_x2: std_logic_vector(17 downto 0);
  signal delay19_q_net_x2: std_logic_vector(17 downto 0);
  signal delay1_q_net_x0: std_logic;
  signal delay1_q_net_x1: std_logic;
  signal delay20_q_net_x1: std_logic_vector(35 downto 0);
  signal delay248_q_net: std_logic_vector(10 downto 0);
  signal delay2_q_net: std_logic_vector(35 downto 0);
  signal delay32_q_net_x1: std_logic_vector(35 downto 0);
  signal delay33_q_net_x0: std_logic_vector(35 downto 0);
  signal delay35_q_net_x0: std_logic_vector(35 downto 0);
  signal delay3_q_net: std_logic_vector(35 downto 0);
  signal delay4_q_net_x1: std_logic_vector(17 downto 0);
  signal delay5_q_net_x1: std_logic_vector(17 downto 0);
  signal delay6_q_net_x1: std_logic_vector(17 downto 0);
  signal delay7_q_net_x1: std_logic_vector(17 downto 0);
  signal delay80_q_net_x21: std_logic_vector(15 downto 0);
  signal delay8_q_net_x4: std_logic;
  signal delay9_q_net: std_logic;
  signal down_sample1_q_net_x0: std_logic_vector(17 downto 0);
  signal down_sample2_q_net_x0: std_logic_vector(17 downto 0);
  signal down_sample3_q_net_x0: std_logic_vector(17 downto 0);
  signal down_sample_q_net_x0: std_logic_vector(17 downto 0);
  signal edge_op_y_net_x2: std_logic;
  signal force_im_output_port_net_x2: std_logic_vector(15 downto 0);
  signal force_im_output_port_net_x3: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x2: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x3: std_logic_vector(15 downto 0);
  signal gateway_out11_net: std_logic_vector(17 downto 0);
  signal gateway_out13_net: std_logic;
  signal gateway_out14_x0_net: std_logic_vector(15 downto 0);
  signal gateway_out15_net: std_logic_vector(15 downto 0);
  signal gateway_out16_x0_net: std_logic_vector(15 downto 0);
  signal gateway_out17_net: std_logic_vector(17 downto 0);
  signal gateway_out17_x0_net: std_logic_vector(15 downto 0);
  signal gateway_out18_x0_net: std_logic_vector(15 downto 0);
  signal gateway_out19_x0_net: std_logic_vector(15 downto 0);
  signal gateway_out20_net: std_logic_vector(17 downto 0);
  signal gateway_out20_x0_net: std_logic_vector(15 downto 0);
  signal gateway_out21_x0_net: std_logic_vector(15 downto 0);
  signal gateway_out22_x0_net: std_logic_vector(15 downto 0);
  signal gateway_out23_net: std_logic_vector(15 downto 0);
  signal gateway_out24_net: std_logic_vector(15 downto 0);
  signal gateway_out25_net: std_logic_vector(15 downto 0);
  signal gateway_out4_x0_net: std_logic_vector(15 downto 0);
  signal gateway_out5_net: std_logic_vector(15 downto 0);
  signal gateway_out6_net: std_logic_vector(15 downto 0);
  signal gateway_out7_x0_net: std_logic_vector(15 downto 0);
  signal gateway_out8_net: std_logic_vector(17 downto 0);
  signal gateway_out8_x0_net: std_logic_vector(7 downto 0);
  signal logical_y_net_x0: std_logic;
  signal mixer_addr_op_net: std_logic_vector(15 downto 0);
  signal mux1_y_net: std_logic_vector(17 downto 0);
  signal mux3_y_net: std_logic_vector(17 downto 0);
  signal mux6_y_net: std_logic_vector(17 downto 0);
  signal mux7_y_net: std_logic_vector(17 downto 0);
  signal post_sync_delay_q_net_x2: std_logic;
  signal power_adder_s_net_x0: std_logic_vector(35 downto 0);
  signal power_adder_s_net_x1: std_logic_vector(35 downto 0);
  signal register0_q_net_x1: std_logic_vector(35 downto 0);
  signal register0_q_net_x10: std_logic_vector(35 downto 0);
  signal register0_q_net_x11: std_logic;
  signal register0_q_net_x12: std_logic_vector(35 downto 0);
  signal register0_q_net_x13: std_logic_vector(63 downto 0);
  signal register0_q_net_x3: std_logic;
  signal register0_q_net_x4: std_logic;
  signal register0_q_net_x5: std_logic_vector(63 downto 0);
  signal register0_q_net_x6: std_logic_vector(9 downto 0);
  signal register0_q_net_x7: std_logic_vector(9 downto 0);
  signal register0_q_net_x8: std_logic_vector(35 downto 0);
  signal register0_q_net_x9: std_logic;
  signal reint1_output_port_net_x0: std_logic_vector(10 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(10 downto 0);
  signal reint1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x24: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net_x25: std_logic_vector(35 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret6_output_port_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret_out_output_port_net_x20: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x21: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x22: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x23: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x24: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x25: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x26: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x27: std_logic_vector(31 downto 0);
  signal reinterpret_output_port_net_x26: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x28: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x29: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x30: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x31: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x32: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x33: std_logic_vector(7 downto 0);
  signal relational5_op_net_x2: std_logic;
  signal relational5_op_net_x3: std_logic;
  signal relational_op_net: std_logic;
  signal single_port_ram_data_out_net_x1: std_logic_vector(63 downto 0);
  signal single_port_ram_data_out_net_x2: std_logic_vector(63 downto 0);
  signal slice35_y_net: std_logic;
  signal spect_cnt2_op_net_x1: std_logic_vector(9 downto 0);
  signal sync_delay_q_net_x1: std_logic;
  signal window_and_fft_test_v4_adc_user_data_valid_net: std_logic;
  signal window_and_fft_test_v4_adc_user_datai0_net: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_datai1_net: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_datai2_net: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_datai3_net: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_dataq0_net: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_dataq1_net: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_dataq2_net: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_dataq3_net: std_logic_vector(7 downto 0);
  signal window_and_fft_test_v4_adc_user_outofrangei0_net: std_logic;
  signal window_and_fft_test_v4_adc_user_outofrangei1_net: std_logic;
  signal window_and_fft_test_v4_adc_user_outofrangeq0_net: std_logic;
  signal window_and_fft_test_v4_adc_user_outofrangeq1_net: std_logic;
  signal window_and_fft_test_v4_adc_user_sync0_net: std_logic;
  signal window_and_fft_test_v4_adc_user_sync1_net: std_logic;
  signal window_and_fft_test_v4_adc_user_sync2_net: std_logic;
  signal window_and_fft_test_v4_adc_user_sync3_net: std_logic;
  signal window_and_fft_test_v4_bypass_pfb_user_data_out_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_coarse_fft_shift_mask1_user_data_out_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_even_window1_addr_net: std_logic_vector(9 downto 0);
  signal window_and_fft_test_v4_even_window1_data_in_net: std_logic_vector(63 downto 0);
  signal window_and_fft_test_v4_even_window1_data_out_net: std_logic_vector(63 downto 0);
  signal window_and_fft_test_v4_even_window1_we_net: std_logic;
  signal window_and_fft_test_v4_gpio_gateway_net: std_logic;
  signal window_and_fft_test_v4_mixer_cnt_user_data_out_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_odd_window1_addr_net: std_logic_vector(9 downto 0);
  signal window_and_fft_test_v4_odd_window1_data_in_net: std_logic_vector(63 downto 0);
  signal window_and_fft_test_v4_odd_window1_data_out_net: std_logic_vector(63 downto 0);
  signal window_and_fft_test_v4_odd_window1_we_net: std_logic;
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram1_addr_net: std_logic_vector(9 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_in_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram1_we_net: std_logic;
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram_addr_net: std_logic_vector(9 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_in_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_1_shared_bram_we_net: std_logic;
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram1_addr_net: std_logic_vector(9 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_in_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram1_we_net: std_logic;
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram_addr_net: std_logic_vector(9 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_in_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_2_shared_bram_we_net: std_logic;
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram1_addr_net: std_logic_vector(9 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_in_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram1_we_net: std_logic;
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram_addr_net: std_logic_vector(9 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_in_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_3_shared_bram_we_net: std_logic;
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram1_addr_net: std_logic_vector(9 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_in_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram1_we_net: std_logic;
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram_addr_net: std_logic_vector(9 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_in_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net: std_logic_vector(31 downto 0);
  signal window_and_fft_test_v4_subsystem_lo_4_shared_bram_we_net: std_logic;

begin
  ce_1_sg_x644 <= ce_1;
  ce_2500_sg_x9 <= ce_2500;
  ce_50_sg_x0 <= ce_50;
  ce_logic_1_sg_x0 <= ce_logic_1;
  clk_1_sg_x644 <= clk_1;
  clk_2500_sg_x9 <= clk_2500;
  clk_50_sg_x0 <= clk_50;
  window_and_fft_test_v4_adc_user_data_valid_net <= window_and_fft_test_v4_adc_user_data_valid;
  window_and_fft_test_v4_adc_user_datai0_net <= window_and_fft_test_v4_adc_user_datai0;
  window_and_fft_test_v4_adc_user_datai1_net <= window_and_fft_test_v4_adc_user_datai1;
  window_and_fft_test_v4_adc_user_datai2_net <= window_and_fft_test_v4_adc_user_datai2;
  window_and_fft_test_v4_adc_user_datai3_net <= window_and_fft_test_v4_adc_user_datai3;
  window_and_fft_test_v4_adc_user_dataq0_net <= window_and_fft_test_v4_adc_user_dataq0;
  window_and_fft_test_v4_adc_user_dataq1_net <= window_and_fft_test_v4_adc_user_dataq1;
  window_and_fft_test_v4_adc_user_dataq2_net <= window_and_fft_test_v4_adc_user_dataq2;
  window_and_fft_test_v4_adc_user_dataq3_net <= window_and_fft_test_v4_adc_user_dataq3;
  window_and_fft_test_v4_adc_user_outofrangei0_net <= window_and_fft_test_v4_adc_user_outofrangei0;
  window_and_fft_test_v4_adc_user_outofrangei1_net <= window_and_fft_test_v4_adc_user_outofrangei1;
  window_and_fft_test_v4_adc_user_outofrangeq0_net <= window_and_fft_test_v4_adc_user_outofrangeq0;
  window_and_fft_test_v4_adc_user_outofrangeq1_net <= window_and_fft_test_v4_adc_user_outofrangeq1;
  window_and_fft_test_v4_adc_user_sync0_net <= window_and_fft_test_v4_adc_user_sync0;
  window_and_fft_test_v4_adc_user_sync1_net <= window_and_fft_test_v4_adc_user_sync1;
  window_and_fft_test_v4_adc_user_sync2_net <= window_and_fft_test_v4_adc_user_sync2;
  window_and_fft_test_v4_adc_user_sync3_net <= window_and_fft_test_v4_adc_user_sync3;
  window_and_fft_test_v4_bypass_pfb_user_data_out_net <= window_and_fft_test_v4_bypass_pfb_user_data_out;
  window_and_fft_test_v4_coarse_fft_shift_mask1_user_data_out_net <= window_and_fft_test_v4_coarse_fft_shift_mask1_user_data_out;
  window_and_fft_test_v4_even_window1_data_out_net <= window_and_fft_test_v4_even_window1_data_out;
  window_and_fft_test_v4_gpio_gateway_net <= window_and_fft_test_v4_gpio_gateway;
  window_and_fft_test_v4_mixer_cnt_user_data_out_net <= window_and_fft_test_v4_mixer_cnt_user_data_out;
  window_and_fft_test_v4_odd_window1_data_out_net <= window_and_fft_test_v4_odd_window1_data_out;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net <= window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net <= window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net <= window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net <= window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net <= window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net <= window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net <= window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net <= window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out;
  gateway_out <= reinterpret_out_output_port_net_x20;
  gateway_out1 <= force_re_output_port_net_x2;
  gateway_out10 <= force_re_output_port_net_x2;
  gateway_out10_x0 <= reinterpret_output_port_net_x28;
  gateway_out11 <= gateway_out11_net;
  gateway_out11_x0 <= reinterpret_output_port_net_x32;
  gateway_out12 <= force_re_output_port_net_x3;
  gateway_out12_x0 <= reinterpret_output_port_net_x29;
  gateway_out13 <= gateway_out13_net;
  gateway_out13_x0 <= reinterpret_output_port_net_x33;
  gateway_out14 <= force_im_output_port_net_x2;
  gateway_out14_x0 <= gateway_out14_x0_net;
  gateway_out15 <= gateway_out15_net;
  gateway_out16 <= force_re_output_port_net_x3;
  gateway_out16_x0 <= gateway_out16_x0_net;
  gateway_out17 <= gateway_out17_net;
  gateway_out17_x0 <= gateway_out17_x0_net;
  gateway_out18 <= force_re_output_port_net_x3;
  gateway_out18_x0 <= gateway_out18_x0_net;
  gateway_out19 <= force_im_output_port_net_x3;
  gateway_out19_x0 <= gateway_out19_x0_net;
  gateway_out1_x0 <= reinterpret_output_port_net_x26;
  gateway_out1_x1 <= reinterpret_out_output_port_net_x21;
  gateway_out1_x2 <= reinterpret_out_output_port_net_x23;
  gateway_out1_x3 <= reinterpret_out_output_port_net_x25;
  gateway_out1_x4 <= reinterpret_out_output_port_net_x27;
  gateway_out2 <= reinterpret_output_port_net_x30;
  gateway_out20 <= gateway_out20_net;
  gateway_out20_x0 <= gateway_out20_x0_net;
  gateway_out21 <= force_im_output_port_net_x3;
  gateway_out21_x0 <= gateway_out21_x0_net;
  gateway_out22 <= force_im_output_port_net_x3;
  gateway_out22_x0 <= gateway_out22_x0_net;
  gateway_out23 <= gateway_out23_net;
  gateway_out24 <= gateway_out24_net;
  gateway_out25 <= gateway_out25_net;
  gateway_out2_x0 <= reinterpret_out_output_port_net_x20;
  gateway_out2_x1 <= reinterpret_out_output_port_net_x22;
  gateway_out2_x2 <= reinterpret_out_output_port_net_x24;
  gateway_out2_x3 <= reinterpret_out_output_port_net_x26;
  gateway_out3 <= delay80_q_net_x21;
  gateway_out31 <= delay80_q_net_x21;
  gateway_out32 <= reinterpret_output_port_net_x28;
  gateway_out33 <= reinterpret_output_port_net_x29;
  gateway_out34 <= reinterpret_output_port_net_x31;
  gateway_out35 <= reinterpret_output_port_net_x30;
  gateway_out36 <= reinterpret_output_port_net_x26;
  gateway_out37 <= reinterpret_output_port_net_x26;
  gateway_out38 <= reinterpret_output_port_net_x33;
  gateway_out39 <= reinterpret_output_port_net_x32;
  gateway_out3_x0 <= reinterpret_out_output_port_net_x21;
  gateway_out3_x1 <= reinterpret_out_output_port_net_x23;
  gateway_out3_x2 <= reinterpret_out_output_port_net_x25;
  gateway_out3_x3 <= reinterpret_out_output_port_net_x27;
  gateway_out4 <= force_re_output_port_net_x2;
  gateway_out4_x0 <= gateway_out4_x0_net;
  gateway_out5 <= gateway_out5_net;
  gateway_out6 <= gateway_out6_net;
  gateway_out7 <= force_im_output_port_net_x2;
  gateway_out7_x0 <= gateway_out7_x0_net;
  gateway_out8 <= gateway_out8_net;
  gateway_out8_x0 <= gateway_out8_x0_net;
  gateway_out9 <= force_im_output_port_net_x2;
  gateway_out9_x0 <= reinterpret_output_port_net_x31;
  gateway_out_x0 <= reinterpret_out_output_port_net_x22;
  gateway_out_x1 <= reinterpret_out_output_port_net_x24;
  gateway_out_x2 <= reinterpret_out_output_port_net_x26;
  window_and_fft_test_v4_even_window1_addr <= window_and_fft_test_v4_even_window1_addr_net;
  window_and_fft_test_v4_even_window1_data_in <= window_and_fft_test_v4_even_window1_data_in_net;
  window_and_fft_test_v4_even_window1_we <= window_and_fft_test_v4_even_window1_we_net;
  window_and_fft_test_v4_odd_window1_addr <= window_and_fft_test_v4_odd_window1_addr_net;
  window_and_fft_test_v4_odd_window1_data_in <= window_and_fft_test_v4_odd_window1_data_in_net;
  window_and_fft_test_v4_odd_window1_we <= window_and_fft_test_v4_odd_window1_we_net;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram1_addr <= window_and_fft_test_v4_subsystem_lo_1_shared_bram1_addr_net;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_in <= window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_in_net;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram1_we <= window_and_fft_test_v4_subsystem_lo_1_shared_bram1_we_net;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram_addr <= window_and_fft_test_v4_subsystem_lo_1_shared_bram_addr_net;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_in <= window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_in_net;
  window_and_fft_test_v4_subsystem_lo_1_shared_bram_we <= window_and_fft_test_v4_subsystem_lo_1_shared_bram_we_net;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram1_addr <= window_and_fft_test_v4_subsystem_lo_2_shared_bram1_addr_net;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_in <= window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_in_net;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram1_we <= window_and_fft_test_v4_subsystem_lo_2_shared_bram1_we_net;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram_addr <= window_and_fft_test_v4_subsystem_lo_2_shared_bram_addr_net;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_in <= window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_in_net;
  window_and_fft_test_v4_subsystem_lo_2_shared_bram_we <= window_and_fft_test_v4_subsystem_lo_2_shared_bram_we_net;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram1_addr <= window_and_fft_test_v4_subsystem_lo_3_shared_bram1_addr_net;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_in <= window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_in_net;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram1_we <= window_and_fft_test_v4_subsystem_lo_3_shared_bram1_we_net;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram_addr <= window_and_fft_test_v4_subsystem_lo_3_shared_bram_addr_net;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_in <= window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_in_net;
  window_and_fft_test_v4_subsystem_lo_3_shared_bram_we <= window_and_fft_test_v4_subsystem_lo_3_shared_bram_we_net;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram1_addr <= window_and_fft_test_v4_subsystem_lo_4_shared_bram1_addr_net;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_in <= window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_in_net;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram1_we <= window_and_fft_test_v4_subsystem_lo_4_shared_bram1_we_net;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram_addr <= window_and_fft_test_v4_subsystem_lo_4_shared_bram_addr_net;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_in <= window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_in_net;
  window_and_fft_test_v4_subsystem_lo_4_shared_bram_we <= window_and_fft_test_v4_subsystem_lo_4_shared_bram_we_net;

  adc_e5ed0846c4: entity work.adc_entity_e5ed0846c4
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      window_and_fft_test_v4_adc_user_datai0 => window_and_fft_test_v4_adc_user_datai0_net,
      window_and_fft_test_v4_adc_user_datai1 => window_and_fft_test_v4_adc_user_datai1_net,
      window_and_fft_test_v4_adc_user_datai2 => window_and_fft_test_v4_adc_user_datai2_net,
      window_and_fft_test_v4_adc_user_datai3 => window_and_fft_test_v4_adc_user_datai3_net,
      window_and_fft_test_v4_adc_user_dataq0 => window_and_fft_test_v4_adc_user_dataq0_net,
      window_and_fft_test_v4_adc_user_dataq1 => window_and_fft_test_v4_adc_user_dataq1_net,
      window_and_fft_test_v4_adc_user_dataq2 => window_and_fft_test_v4_adc_user_dataq2_net,
      window_and_fft_test_v4_adc_user_dataq3 => window_and_fft_test_v4_adc_user_dataq3_net,
      i0 => reinterpret_output_port_net_x26,
      i1 => gateway_out8_x0_net,
      i2 => reinterpret_output_port_net_x28,
      i3 => reinterpret_output_port_net_x29,
      q0 => reinterpret_output_port_net_x30,
      q1 => reinterpret_output_port_net_x31,
      q2 => reinterpret_output_port_net_x32,
      q3 => reinterpret_output_port_net_x33
    );

  bypass_pfb_fb69df1916: entity work.bypass_pfb_entity_fb69df1916
    port map (
      window_and_fft_test_v4_bypass_pfb_user_data_out => window_and_fft_test_v4_bypass_pfb_user_data_out_net,
      in_reg => reint1_output_port_net_x0
    );

  c_to_ri1_97e44d2383: entity work.c_to_ri_entity_98aa64f433
    port map (
      c => concat_y_net_x3,
      im => force_im_output_port_net_x3,
      re => force_re_output_port_net_x3
    );

  c_to_ri_98aa64f433: entity work.c_to_ri_entity_98aa64f433
    port map (
      c => concat_y_net_x2,
      im => force_im_output_port_net_x2,
      re => force_re_output_port_net_x2
    );

  coarse_fft_shift_mask1_5051420c9e: entity work.coarse_fft_shift_mask1_entity_5051420c9e
    port map (
      window_and_fft_test_v4_coarse_fft_shift_mask1_user_data_out => window_and_fft_test_v4_coarse_fft_shift_mask1_user_data_out_net,
      in_reg => reint1_output_port_net_x1
    );

  convert_of10_dfa7148607: entity work.convert_of10_entity_dfa7148607
    port map (
      ce_2500 => ce_2500_sg_x9,
      clk_2500 => clk_2500_sg_x9,
      din => down_sample2_q_net_x0,
      dout => convert_dout_net_x0
    );

  convert_of11_b834127c92: entity work.convert_of10_entity_dfa7148607
    port map (
      ce_2500 => ce_2500_sg_x9,
      clk_2500 => clk_2500_sg_x9,
      din => down_sample3_q_net_x0,
      dout => convert_dout_net_x1
    );

  convert_of8_b71b88c5a1: entity work.convert_of10_entity_dfa7148607
    port map (
      ce_2500 => ce_2500_sg_x9,
      clk_2500 => clk_2500_sg_x9,
      din => down_sample1_q_net_x0,
      dout => convert_dout_net_x2
    );

  convert_of9_537d0575b1: entity work.convert_of10_entity_dfa7148607
    port map (
      ce_2500 => ce_2500_sg_x9,
      clk_2500 => clk_2500_sg_x9,
      din => down_sample_q_net_x0,
      dout => convert_dout_net_x3
    );

  dec_fir1_a748e0413b: entity work.dec_fir_entity_ce31f24969
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      imag1 => gateway_out5_net,
      imag2 => gateway_out15_net,
      imag3 => gateway_out18_x0_net,
      imag4 => gateway_out23_net,
      real1 => gateway_out7_x0_net,
      real2 => gateway_out17_x0_net,
      real3 => gateway_out21_x0_net,
      real4 => gateway_out25_net,
      sync_in => edge_op_y_net_x2,
      dout => concat_y_net_x3,
      sync_out => gateway_out13_net
    );

  dec_fir_ce31f24969: entity work.dec_fir_entity_ce31f24969
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      imag1 => gateway_out4_x0_net,
      imag2 => gateway_out14_x0_net,
      imag3 => gateway_out18_x0_net,
      imag4 => gateway_out22_x0_net,
      real1 => gateway_out6_net,
      real2 => gateway_out16_x0_net,
      real3 => gateway_out20_x0_net,
      real4 => gateway_out24_net,
      sync_in => edge_op_y_net_x2,
      dout => concat_y_net_x2,
      sync_out => sync_delay_q_net_x1
    );

  delay1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d(0) => post_sync_delay_q_net_x2,
      q(0) => delay1_q_net_x1
    );

  delay10: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d(0) => delay9_q_net,
      q(0) => delay10_q_net_x3
    );

  delay11: entity work.delay_49cb1051e0
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => reint1_output_port_net_x1,
      q => delay11_q_net_x11
    );

  delay12: entity work.delay_cbdfa55dc3
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => convert_2_2_dout_net_x0,
      q => delay12_q_net
    );

  delay13: entity work.delay_cbdfa55dc3
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => convert_1_1_dout_net_x0,
      q => delay13_q_net
    );

  delay14: entity work.delay_cbdfa55dc3
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => convert_1_2_dout_net_x0,
      q => delay14_q_net
    );

  delay15: entity work.delay_cbdfa55dc3
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => convert_2_1_dout_net_x0,
      q => delay15_q_net
    );

  delay16: entity work.delay_b6092ad150
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => mux1_y_net,
      q => delay16_q_net_x2
    );

  delay17: entity work.delay_b6092ad150
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => mux3_y_net,
      q => delay17_q_net_x2
    );

  delay18: entity work.delay_b6092ad150
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => mux6_y_net,
      q => delay18_q_net_x2
    );

  delay19: entity work.delay_b6092ad150
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => mux7_y_net,
      q => delay19_q_net_x2
    );

  delay2: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => reinterpret1_output_port_net_x24,
      q => delay2_q_net
    );

  delay20: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => delay2_q_net,
      q => delay20_q_net_x1
    );

  delay248: entity work.delay_49cb1051e0
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => reint1_output_port_net_x0,
      q => delay248_q_net
    );

  delay3: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => reinterpret1_output_port_net_x25,
      q => delay3_q_net
    );

  delay32: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => delay3_q_net,
      q => delay32_q_net_x1
    );

  delay33: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => power_adder_s_net_x0,
      q => delay33_q_net_x0
    );

  delay35: entity work.delay_e4b9fcaf02
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => power_adder_s_net_x1,
      q => delay35_q_net_x0
    );

  delay4: entity work.delay_b6092ad150
    port map (
      ce => ce_2500_sg_x9,
      clk => clk_2500_sg_x9,
      clr => '0',
      d => down_sample1_q_net_x0,
      q => delay4_q_net_x1
    );

  delay5: entity work.delay_b6092ad150
    port map (
      ce => ce_2500_sg_x9,
      clk => clk_2500_sg_x9,
      clr => '0',
      d => down_sample3_q_net_x0,
      q => delay5_q_net_x1
    );

  delay6: entity work.delay_b6092ad150
    port map (
      ce => ce_2500_sg_x9,
      clk => clk_2500_sg_x9,
      clr => '0',
      d => down_sample_q_net_x0,
      q => delay6_q_net_x1
    );

  delay7: entity work.delay_b6092ad150
    port map (
      ce => ce_2500_sg_x9,
      clk => clk_2500_sg_x9,
      clr => '0',
      d => down_sample2_q_net_x0,
      q => delay7_q_net_x1
    );

  delay8: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d(0) => sync_delay_q_net_x1,
      q(0) => delay8_q_net_x4
    );

  delay80: entity work.delay_ec5089319a
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d => mixer_addr_op_net,
      q => delay80_q_net_x21
    );

  delay9: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      d(0) => delay1_q_net_x0,
      q(0) => delay9_q_net
    );

  down_sample: entity work.xldsamp
    generic map (
      d_arith => xlSigned,
      d_bin_pt => 17,
      d_width => 18,
      ds_ratio => 50,
      latency => 1,
      phase => 49,
      q_arith => xlSigned,
      q_bin_pt => 17,
      q_width => 18
    )
    port map (
      d => gateway_out8_net,
      dest_ce => ce_2500_sg_x9,
      dest_clk => clk_2500_sg_x9,
      dest_clr => '0',
      en => "1",
      src_ce => ce_50_sg_x0,
      src_clk => clk_50_sg_x0,
      src_clr => '0',
      q => down_sample_q_net_x0
    );

  down_sample1: entity work.xldsamp
    generic map (
      d_arith => xlSigned,
      d_bin_pt => 17,
      d_width => 18,
      ds_ratio => 50,
      latency => 1,
      phase => 49,
      q_arith => xlSigned,
      q_bin_pt => 17,
      q_width => 18
    )
    port map (
      d => gateway_out11_net,
      dest_ce => ce_2500_sg_x9,
      dest_clk => clk_2500_sg_x9,
      dest_clr => '0',
      en => "1",
      src_ce => ce_50_sg_x0,
      src_clk => clk_50_sg_x0,
      src_clr => '0',
      q => down_sample1_q_net_x0
    );

  down_sample2: entity work.xldsamp
    generic map (
      d_arith => xlSigned,
      d_bin_pt => 17,
      d_width => 18,
      ds_ratio => 50,
      latency => 1,
      phase => 49,
      q_arith => xlSigned,
      q_bin_pt => 17,
      q_width => 18
    )
    port map (
      d => gateway_out17_net,
      dest_ce => ce_2500_sg_x9,
      dest_clk => clk_2500_sg_x9,
      dest_clr => '0',
      en => "1",
      src_ce => ce_50_sg_x0,
      src_clk => clk_50_sg_x0,
      src_clr => '0',
      q => down_sample2_q_net_x0
    );

  down_sample3: entity work.xldsamp
    generic map (
      d_arith => xlSigned,
      d_bin_pt => 17,
      d_width => 18,
      ds_ratio => 50,
      latency => 1,
      phase => 49,
      q_arith => xlSigned,
      q_bin_pt => 17,
      q_width => 18
    )
    port map (
      d => gateway_out20_net,
      dest_ce => ce_2500_sg_x9,
      dest_clk => clk_2500_sg_x9,
      dest_clr => '0',
      en => "1",
      src_ce => ce_50_sg_x0,
      src_clk => clk_50_sg_x0,
      src_clr => '0',
      q => down_sample3_q_net_x0
    );

  even_window1_a08cd2ecfc: entity work.even_window1_entity_a08cd2ecfc
    port map (
      addr => register0_q_net_x6,
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      data_in => register0_q_net_x13,
      we => register0_q_net_x3,
      convert_addr_x0 => window_and_fft_test_v4_even_window1_addr_net,
      convert_din1_x0 => window_and_fft_test_v4_even_window1_data_in_net,
      convert_we_x0 => window_and_fft_test_v4_even_window1_we_net
    );

  fft_wideband_real1_41856fd605: entity work.fft_wideband_real1_entity_41856fd605
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      in00 => delay16_q_net_x2,
      in01 => delay17_q_net_x2,
      in02 => delay18_q_net_x2,
      in03 => delay19_q_net_x2,
      shift => delay11_q_net_x11,
      sync => delay10_q_net_x3,
      out00 => reinterpret1_output_port_net_x24,
      out01 => reinterpret1_output_port_net_x25,
      sync_out => post_sync_delay_q_net_x2
    );

  fir_compiler_5_0: entity work.xlfir_compiler_fe9d317252ca97985c8e1f77f6cc0a64
    port map (
      ce => ce_1_sg_x644,
      ce_50 => ce_50_sg_x0,
      ce_logic_1 => ce_logic_1_sg_x0,
      clk => clk_1_sg_x644,
      clk_50 => clk_50_sg_x0,
      clk_logic_1 => clk_1_sg_x644,
      din => force_re_output_port_net_x2,
      src_ce => ce_1_sg_x644,
      src_clk => clk_1_sg_x644,
      dout => gateway_out11_net
    );

  fir_compiler_5_0_1: entity work.xlfir_compiler_fe9d317252ca97985c8e1f77f6cc0a64
    port map (
      ce => ce_1_sg_x644,
      ce_50 => ce_50_sg_x0,
      ce_logic_1 => ce_logic_1_sg_x0,
      clk => clk_1_sg_x644,
      clk_50 => clk_50_sg_x0,
      clk_logic_1 => clk_1_sg_x644,
      din => force_re_output_port_net_x3,
      src_ce => ce_1_sg_x644,
      src_clk => clk_1_sg_x644,
      dout => gateway_out17_net
    );

  fir_compiler_5_0_2: entity work.xlfir_compiler_fe9d317252ca97985c8e1f77f6cc0a64
    port map (
      ce => ce_1_sg_x644,
      ce_50 => ce_50_sg_x0,
      ce_logic_1 => ce_logic_1_sg_x0,
      clk => clk_1_sg_x644,
      clk_50 => clk_50_sg_x0,
      clk_logic_1 => clk_1_sg_x644,
      din => force_im_output_port_net_x2,
      src_ce => ce_1_sg_x644,
      src_clk => clk_1_sg_x644,
      dout => gateway_out8_net
    );

  fir_compiler_5_0_3: entity work.xlfir_compiler_fe9d317252ca97985c8e1f77f6cc0a64
    port map (
      ce => ce_1_sg_x644,
      ce_50 => ce_50_sg_x0,
      ce_logic_1 => ce_logic_1_sg_x0,
      clk => clk_1_sg_x644,
      clk_50 => clk_50_sg_x0,
      clk_logic_1 => clk_1_sg_x644,
      din => force_im_output_port_net_x3,
      src_ce => ce_1_sg_x644,
      src_clk => clk_1_sg_x644,
      dout => gateway_out20_net
    );

  logical: entity work.logical_a6d07705dd
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => window_and_fft_test_v4_adc_user_sync0_net,
      d1(0) => window_and_fft_test_v4_adc_user_sync1_net,
      d2(0) => window_and_fft_test_v4_adc_user_sync2_net,
      d3(0) => window_and_fft_test_v4_adc_user_sync3_net,
      y(0) => logical_y_net_x0
    );

  mixer_addr: entity work.xlcounter_free_window_and_fft_test_v4
    generic map (
      core_name0 => "cntr_11_0_457d1583b36d1c7c",
      op_arith => xlSigned,
      op_width => 16
    )
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      en => "1",
      rst(0) => relational_op_net,
      op => mixer_addr_op_net
    );

  mixer_cnt_cb8600b24e: entity work.mixer_cnt_entity_cb8600b24e
    port map (
      window_and_fft_test_v4_mixer_cnt_user_data_out => window_and_fft_test_v4_mixer_cnt_user_data_out_net,
      in_reg => reint1_output_port_net_x2
    );

  mux1: entity work.mux_0b0063065e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => delay13_q_net,
      d1 => convert_dout_net_x2,
      sel(0) => slice35_y_net,
      y => mux1_y_net
    );

  mux3: entity work.mux_0b0063065e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => delay14_q_net,
      d1 => convert_dout_net_x3,
      sel(0) => slice35_y_net,
      y => mux3_y_net
    );

  mux6: entity work.mux_0b0063065e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => delay15_q_net,
      d1 => convert_dout_net_x0,
      sel(0) => slice35_y_net,
      y => mux6_y_net
    );

  mux7: entity work.mux_0b0063065e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => delay12_q_net,
      d1 => convert_dout_net_x1,
      sel(0) => slice35_y_net,
      y => mux7_y_net
    );

  odd_window1_fe53f43626: entity work.even_window1_entity_a08cd2ecfc
    port map (
      addr => register0_q_net_x7,
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      data_in => register0_q_net_x5,
      we => register0_q_net_x9,
      convert_addr_x0 => window_and_fft_test_v4_odd_window1_addr_net,
      convert_din1_x0 => window_and_fft_test_v4_odd_window1_data_in_net,
      convert_we_x0 => window_and_fft_test_v4_odd_window1_we_net
    );

  pfb_fir_real1_f049311348: entity work.pfb_fir_real1_entity_f049311348
    port map (
      ce_1 => ce_1_sg_x644,
      ce_2500 => ce_2500_sg_x9,
      clk_1 => clk_1_sg_x644,
      clk_2500 => clk_2500_sg_x9,
      pol1_in1 => delay4_q_net_x1,
      pol1_in2 => delay6_q_net_x1,
      pol2_in1 => delay7_q_net_x1,
      pol2_in2 => delay5_q_net_x1,
      sync => delay8_q_net_x4,
      pol1_out1 => convert_1_1_dout_net_x0,
      pol1_out2 => convert_1_2_dout_net_x0,
      pol2_out1 => convert_2_1_dout_net_x0,
      pol2_out2 => convert_2_2_dout_net_x0,
      sync_out => delay1_q_net_x0
    );

  pipeline18_449c822a97: entity work.pipeline1_entity_fd1e8cdd4b
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => relational5_op_net_x3,
      q => register0_q_net_x3
    );

  pipeline19_9c44957711: entity work.pipeline19_entity_9c44957711
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => reinterpret6_output_port_net_x0,
      q => register0_q_net_x5
    );

  pipeline1_fd1e8cdd4b: entity work.pipeline1_entity_fd1e8cdd4b
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => delay1_q_net_x1,
      q => register0_q_net_x4
    );

  pipeline20_ed6ce63c1a: entity work.pipeline20_entity_ed6ce63c1a
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => spect_cnt2_op_net_x1,
      q => register0_q_net_x6
    );

  pipeline27_03a229182e: entity work.pipeline20_entity_ed6ce63c1a
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => spect_cnt2_op_net_x1,
      q => register0_q_net_x7
    );

  pipeline32_2d07f7b9aa: entity work.pipeline32_entity_2d07f7b9aa
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => delay33_q_net_x0,
      q => register0_q_net_x1
    );

  pipeline33_a5c811f9db: entity work.pipeline32_entity_2d07f7b9aa
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => delay35_q_net_x0,
      q => register0_q_net_x8
    );

  pipeline34_16ae506fde: entity work.pipeline1_entity_fd1e8cdd4b
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => relational5_op_net_x2,
      q => register0_q_net_x9
    );

  pipeline35_cd3a695c18: entity work.pipeline32_entity_2d07f7b9aa
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => register0_q_net_x1,
      q => register0_q_net_x10
    );

  pipeline36_ace00e38c1: entity work.pipeline1_entity_fd1e8cdd4b
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => delay1_q_net_x1,
      q => register0_q_net_x11
    );

  pipeline8_a3eb9b6d34: entity work.pipeline32_entity_2d07f7b9aa
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => register0_q_net_x8,
      q => register0_q_net_x12
    );

  pipeline9_b204172a4a: entity work.pipeline19_entity_9c44957711
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      d => reinterpret3_output_port_net_x0,
      q => register0_q_net_x13
    );

  posedge9_b995cb784d: entity work.posedge9_entity_b995cb784d
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      in_x0 => logical_y_net_x0,
      out_x0 => edge_op_y_net_x2
    );

  power3_b160c790c4: entity work.power3_entity_b160c790c4
    port map (
      c => delay20_q_net_x1,
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      power => power_adder_s_net_x0
    );

  power4_150eae3e27: entity work.power3_entity_b160c790c4
    port map (
      c => delay32_q_net_x1,
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      power => power_adder_s_net_x1
    );

  reinterpret3: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => single_port_ram_data_out_net_x2,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret6: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => single_port_ram_data_out_net_x1,
      output_port => reinterpret6_output_port_net_x0
    );

  relational: entity work.relational_e1b91ef670
    port map (
      a => mixer_addr_op_net,
      b => reint1_output_port_net_x2,
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      op(0) => relational_op_net
    );

  simple_bram_vacc2_b7c86c1381: entity work.simple_bram_vacc2_entity_b7c86c1381
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      din => register0_q_net_x12,
      new_acc => register0_q_net_x4,
      dout => single_port_ram_data_out_net_x1,
      valid => relational5_op_net_x2
    );

  simple_bram_vacc4_69e504a5d1: entity work.simple_bram_vacc2_entity_b7c86c1381
    port map (
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      din => register0_q_net_x10,
      new_acc => register0_q_net_x11,
      dout => single_port_ram_data_out_net_x2,
      valid => relational5_op_net_x3
    );

  slice35: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 11,
      y_width => 1
    )
    port map (
      x => delay248_q_net,
      y(0) => slice35_y_net
    );

  spect_cnt2: entity work.xlcounter_free_window_and_fft_test_v4
    generic map (
      core_name0 => "cntr_11_0_5c0d8fded7f0a054",
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x644,
      clk => clk_1_sg_x644,
      clr => '0',
      en(0) => relational5_op_net_x3,
      rst(0) => delay1_q_net_x1,
      op => spect_cnt2_op_net_x1
    );

  subsystem_1d58a904b1: entity work.subsystem_entity_1d58a904b1
    port map (
      adc_data1_2 => reinterpret_output_port_net_x32,
      adc_data_0_0 => reinterpret_output_port_net_x26,
      adc_data_0_1 => reinterpret_output_port_net_x30,
      adc_data_0_2 => reinterpret_output_port_net_x28,
      adc_data_0_3 => reinterpret_output_port_net_x29,
      adc_data_1_0 => gateway_out8_x0_net,
      adc_data_1_1 => reinterpret_output_port_net_x31,
      adc_data_1_3 => reinterpret_output_port_net_x33,
      addr => delay80_q_net_x21,
      ce_1 => ce_1_sg_x644,
      clk_1 => clk_1_sg_x644,
      window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_out_net,
      window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_out_net,
      window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_out_net,
      window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_out_net,
      window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_out_net,
      window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_out_net,
      window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out => window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_out_net,
      window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out => window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_out_net,
      lo_1 => window_and_fft_test_v4_subsystem_lo_1_shared_bram_addr_net,
      lo_1_x0 => window_and_fft_test_v4_subsystem_lo_1_shared_bram_data_in_net,
      lo_1_x1 => window_and_fft_test_v4_subsystem_lo_1_shared_bram_we_net,
      lo_1_x2 => reinterpret_out_output_port_net_x20,
      lo_1_x3 => window_and_fft_test_v4_subsystem_lo_1_shared_bram1_addr_net,
      lo_1_x4 => window_and_fft_test_v4_subsystem_lo_1_shared_bram1_data_in_net,
      lo_1_x5 => window_and_fft_test_v4_subsystem_lo_1_shared_bram1_we_net,
      lo_1_x6 => reinterpret_out_output_port_net_x21,
      lo_2 => window_and_fft_test_v4_subsystem_lo_2_shared_bram_addr_net,
      lo_2_x0 => window_and_fft_test_v4_subsystem_lo_2_shared_bram_data_in_net,
      lo_2_x1 => window_and_fft_test_v4_subsystem_lo_2_shared_bram_we_net,
      lo_2_x2 => reinterpret_out_output_port_net_x22,
      lo_2_x3 => window_and_fft_test_v4_subsystem_lo_2_shared_bram1_addr_net,
      lo_2_x4 => window_and_fft_test_v4_subsystem_lo_2_shared_bram1_data_in_net,
      lo_2_x5 => window_and_fft_test_v4_subsystem_lo_2_shared_bram1_we_net,
      lo_2_x6 => reinterpret_out_output_port_net_x23,
      lo_3 => window_and_fft_test_v4_subsystem_lo_3_shared_bram_addr_net,
      lo_3_x0 => window_and_fft_test_v4_subsystem_lo_3_shared_bram_data_in_net,
      lo_3_x1 => window_and_fft_test_v4_subsystem_lo_3_shared_bram_we_net,
      lo_3_x2 => reinterpret_out_output_port_net_x24,
      lo_3_x3 => window_and_fft_test_v4_subsystem_lo_3_shared_bram1_addr_net,
      lo_3_x4 => window_and_fft_test_v4_subsystem_lo_3_shared_bram1_data_in_net,
      lo_3_x5 => window_and_fft_test_v4_subsystem_lo_3_shared_bram1_we_net,
      lo_3_x6 => reinterpret_out_output_port_net_x25,
      lo_4 => window_and_fft_test_v4_subsystem_lo_4_shared_bram_addr_net,
      lo_4_x0 => window_and_fft_test_v4_subsystem_lo_4_shared_bram_data_in_net,
      lo_4_x1 => window_and_fft_test_v4_subsystem_lo_4_shared_bram_we_net,
      lo_4_x2 => reinterpret_out_output_port_net_x26,
      lo_4_x3 => window_and_fft_test_v4_subsystem_lo_4_shared_bram1_addr_net,
      lo_4_x4 => window_and_fft_test_v4_subsystem_lo_4_shared_bram1_data_in_net,
      lo_4_x5 => window_and_fft_test_v4_subsystem_lo_4_shared_bram1_we_net,
      lo_4_x6 => reinterpret_out_output_port_net_x27,
      pol1_imag_1 => gateway_out4_x0_net,
      pol1_imag_2 => gateway_out14_x0_net,
      pol1_imag_3 => gateway_out18_x0_net,
      pol1_imag_4 => gateway_out22_x0_net,
      pol1_real_1 => gateway_out6_net,
      pol1_real_2 => gateway_out16_x0_net,
      pol1_real_3 => gateway_out20_x0_net,
      pol1_real_4 => gateway_out24_net,
      pol2_imag_2 => gateway_out5_net,
      pol2_imag_2_x0 => gateway_out15_net,
      pol2_imag_3 => gateway_out19_x0_net,
      pol2_imag_4 => gateway_out23_net,
      pol2_real_1 => gateway_out7_x0_net,
      pol2_real_2 => gateway_out17_x0_net,
      pol2_real_3 => gateway_out21_x0_net,
      pol2_real_4 => gateway_out25_net
    );

end structural;
